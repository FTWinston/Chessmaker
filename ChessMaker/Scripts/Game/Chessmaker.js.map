{"version":3,"file":"../ChessMaker/Scripts/chessmaker.js","sources":["AI.cpp","./Game.h","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\list","./Move.h","./GameState.h","./Player.h","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\set","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\__tree","./Piece.h","./PieceType.h","./AI.h","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\memory","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\__functional_base","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\new","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\type_traits","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\iterator","Board.cpp","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\map","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\utility","Cell.cpp","Distance.cpp","EndOfGame.cpp","./StateConditions.h","./EndOfGame.h","Game.cpp","GameParser.cpp","./TurnOrder.h","./MoveConditions.h","./MoveDefinition.h","./rapidxml\\rapidxml.hpp","./GameParser.h","./rapidxml\\rapidxml_print.hpp","./Cell.h","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\tuple","./Definitions.h","GameState.cpp","Interface.cpp","./ai.h","Move.cpp","./MoveStep.h","C:\\Program Files\\Emscripten\\emscripten\\1.29.0\\system\\include\\libcxx\\__tuple","MoveConditions.cpp","MoveDefinition.cpp","MoveStep.cpp","Piece.cpp","PieceType.cpp","Player.cpp","StateConditions.cpp","TurnOrder.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAA;;;;;;AAgIA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AA/HA;AAEA;AAAA;AACA;AAEA;;AAAA;;;;;AAAA;;AAEA;AAAA;;;;AAEA;;AAAA;;;;;;;AAAA;;;;;;AAAA;;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AACA;;AAAA;;;;;;;AAAA;;;;;;AAGA;;AAAA;;;;;;AAAA;;AACA;AAAA;;;;AAEA;;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;AAEA;;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;AAEA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAEA;;AAAA;;;;;;AAAA;;AAKA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAGA;AAAA;;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAEA;;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;;AAAA;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAGA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAIA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;AAIA;;AAAA;;;;;;;AAAA;;;;;;AAAA;;AAEA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAEA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;AAEA;AAAA;;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;;AAAA;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;;AAGA;;AAAA;;;;;;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;;;AAEA;;;;;;AAAA;;AACA;;;;;;AAEA;AAAA;;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;;AAEA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAIA;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;;AAAA;;;;;;;AAAA;;AACA;AAAA;;;;AAEA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAEA;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;AAAA;;AAEA;;;;;;;;AAAA;;;;;;;AAEA;;AAAA;;;;;;;AAAA;;AAGA;A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A;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAIA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;;;AACA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AA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AAAA;AAAA;AAAA;AADA;AAAA;;;;;;;;;;;;;ADoiBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;Af4gBA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AyB/+CA;;AAAA;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAaA;;AAAA;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAaA;;AAAA;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAcA;;AAAA;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAeA;;AAAA;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAcA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;ALnGA;;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ApB6+CA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;AAAA;;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AwB5gDA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AxBqgDA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AA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;;AgBvWA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AFwYA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;AAAA;;;;;;;;;;;;;;;;AE3pBA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;AhBymBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAOA;AAAA;;;;;;;;;;;;;;AgBlkBA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiMA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjCA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA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AvYA;;;;;;;;;;;;;AVqqBA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AIsqCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AGnsBA;AAAA;;;;;;;;;;;;;AHkhBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AA2KA;AAAA;;;;;;;;;AAnLA;AAAA;AAAA;;;;;;;;AA7fA;;;;;;;;;;;;AMhxBA;AAAA;AAAA;AAAA;;;;;;;;;AAvYA;;;;;;;;;;;;;AVqqBA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AIsqCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AGnsBA;AAAA;;;;;;;;;;;;;AHkhBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AA2KA;AAAA;;;;;;;;;AAnLA;AAAA;AAAA;;;;;;;;AA7fA;;;;;;;;;;;;AMhxBA;AAAA;AAAA;AAAA;;;;;;;;;AAvYA;;;;;;;;;;;;;AVqqBA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AIsqCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AGnsBA;AAAA;;;;;;;;;;;;;AHkhBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AA2KA;AAAA;;;;;;;;;AAnLA;AAAA;AAAA;;;;;;;;AA7fA;;;;;;;;;;;;AMhxBA;AAAA;AAAA;AAAA;;;;;;;;;AAvYA;;;;;;;;;;;;;AVqqBA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AIsqCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AGnsBA;AAAA;;;;;;;;;;;;;AHkhBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AA2KA;AAAA;;;;;;;;;AAnLA;AAAA;AAAA;;;;;;;;AA7fA;;;;;;;;;;;;;;;;;A2BnlDA;AAAA;AAAA;AAAA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","sourcesContent":["#include \"AI.h\"\r\n#include \"Game.h\"\r\n#include \"GameState.h\"\r\n#include \"Move.h\"\r\n#include \"Piece.h\"\r\n#include \"PieceType.h\"\r\n#include \"Player.h\"\r\n#include <float.h>\r\n\r\n\r\nMove *AI_Random::SelectMove()\r\n{\r\n\tauto moves = game->GetPossibleMoves();\r\n\tint selectedIndex = rand() % moves->size(), index = 0;\r\n\t\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tif (index == selectedIndex)\r\n\t\t\treturn *it;\r\n\r\n\t\tindex++;\r\n\t}\r\n\r\n\tReportError(\"Random AI failed to select a move\\n\");\r\n\treturn 0;\r\n}\r\n\r\n\r\nMove *AI_RandomCapture::SelectMove()\r\n{\r\n\tauto moves = game->GetPossibleMoves();\r\n\tint numCaptures = 0;\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n\t\tif (move->IsCapture())\r\n\t\t\tnumCaptures++;\r\n\t}\r\n\r\n\tif (numCaptures == 0)\r\n\t\treturn AI_Random::SelectMove();\r\n\r\n\tint selectedIndex = rand() % numCaptures, index = 0;\r\n\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n\t\tif (!move->IsCapture())\r\n\t\t\tcontinue;\r\n\r\n\t\tif (index == selectedIndex)\r\n\t\t\treturn *it;\r\n\r\n\t\tindex++;\r\n\t}\r\n\r\n\tReportError(\"Random Capture AI failed to select a move\\n\");\r\n\treturn 0;\r\n}\r\n\r\n\r\nMove *AI_AlphaBeta::SelectMove()\r\n{\r\n\tdouble alpha = DBL_MIN;\r\n\tdouble beta = DBL_MAX;\r\n\r\n    double bestScore = DBL_MIN;\r\n\tstd::list<Move*> bestMoves;\r\n    \r\n\tauto moves = game->GetPossibleMoves();\r\n\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n        double score = GetMoveScore(move, alpha, beta, ply);\r\n\r\n        if (score > bestScore) {\r\n            bestScore = score;\r\n\t\t\tbestMoves.clear();\r\n\t\t\tbestMoves.push_back(move);\r\n        }\r\n        else if (score == bestScore)\r\n            bestMoves.push_back(move);\r\n    }\r\n\r\n\tint selectedIndex = rand() % moves->size(), index = 0;\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tif (index == selectedIndex)\r\n\t\t\treturn *it;\r\n\r\n\t\tindex++;\r\n\t}\r\n\r\n\tReportError(\"Alpha-Beta AI failed to select a move\\n\");\r\n\treturn 0;\r\n}\r\n\r\n\r\ndouble AI_AlphaBeta::FindBestScore(GameState *state, double alpha, double beta, int depth)\r\n{\r\n\t\r\n\tif (depth == 0)\r\n        return EvaluateBoard(state);\r\n    \r\n\tbool anyMoves = false;\r\n    auto moves = state->DeterminePossibleMoves();\r\n\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n    {\r\n\t\tMove *move = *it;\r\n        if (!anyMoves)\r\n\t\t{\r\n            anyMoves = true;\r\n\r\n\t\t\tEndOfGame::CheckType_t gameEnd = game->GetEndOfGame()->CheckStartOfTurn(state, anyMoves);\r\n\t\t\tif (gameEnd != EndOfGame::None)\r\n\t\t\t{\r\n\t\t\t\tfor (; it != moves->end(); it++)\r\n\t\t\t\t\tdelete *it;\r\n\t\t\t\tdelete moves;\r\n\r\n\t\t\t\treturn GetScoreForEndOfGame(gameEnd);\r\n\t\t\t}\r\n        }\r\n\r\n        double score = GetMoveScore(move, alpha, beta, depth);\r\n\t\tdelete move;\r\n\r\n\t\tif (score >= beta)\r\n\t\t{\r\n\t\t\tfor (it++; it != moves->end(); it++)\r\n\t\t\t\tdelete *it;\r\n\t\t\tdelete moves;\r\n\r\n\t\t\treturn beta;\r\n\t\t}\r\n        if (score > alpha)\r\n            alpha = score;\r\n    }\r\n\r\n\tdelete moves;\r\n\r\n    if (!anyMoves)\r\n        return GetScoreForEndOfGame(game->GetEndOfGame()->CheckStartOfTurn(state, anyMoves));\r\n\r\n    return alpha;\r\n}\r\n\r\n\r\ndouble AI_AlphaBeta::GetMoveScore(Move *move, double alpha, double beta, int depth)\r\n{\r\n\tGameState *subsequentState = move->Perform(false);\r\n\r\n\tEndOfGame::CheckType_t gameEnd = game->GetEndOfGame()->CheckEndOfTurn(move->GetPrevState(), move);\r\n\tdouble score;\r\n\r\n\tif (gameEnd == EndOfGame::None)\r\n\t{\r\n        if (move->GetPlayer()->GetRelationship(subsequentState->GetCurrentPlayer()) == Player::Enemy)\r\n            score = -FindBestScore(subsequentState, -beta, -alpha, depth - 1);\r\n        else\r\n            score = FindBestScore(subsequentState, alpha, beta, depth - 1);\r\n    }\r\n\telse\r\n\t\tscore = GetScoreForEndOfGame(gameEnd);\r\n\r\n    move->Reverse(false);\r\n\tdelete subsequentState;\r\n    return score;\r\n}\r\n\r\n\r\ndouble AI_AlphaBeta::GetScoreForEndOfGame(EndOfGame::CheckType_t result)\r\n{\r\n\tswitch (result)\r\n\t{\r\n\tcase EndOfGame::Win:\r\n\t\treturn DBL_MAX;\r\n\tcase EndOfGame::Lose:\r\n\t\treturn DBL_MIN;\r\n\tcase EndOfGame::Draw:\r\n\tdefault:\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n\r\ndouble AI_AlphaBeta::EvaluateBoard(GameState *state)\r\n{\r\n\tdouble score = 0;\r\n\r\n\tPlayer *current = state->GetCurrentPlayer();\r\n\r\n\tauto players = game->GetPlayers();\r\n\tfor (auto itPlayers = players.begin(); itPlayers != players.end(); itPlayers++)\r\n    {\r\n\t\tPlayer *other = *itPlayers;\r\n        double playerScore = 0;\r\n\r\n\t\t// add piece value to score\r\n\t\tauto piecesOnBoard = other->GetPiecesOnBoard();\r\n\t\tfor (auto itPieces = piecesOnBoard.begin(); itPieces != piecesOnBoard.end(); itPieces++)\r\n\t\t{\r\n\t\t\tPiece *piece = *itPieces;\r\n\t\t\tplayerScore += piece->GetType()->GetValue();\r\n\r\n            // calculating possible moves (again?) here is gonna slow things down more\r\n\r\n            // NOTE! Neither of these would be cached! they ought to be!\r\n\r\n            // one simple option\r\n            //playerScore += 0.1 * move.subsequentState.determineMovesForPiece(piece).length;\r\n\r\n            // more complicated\r\n            //var moves = move.subsequentState.determineMovesForPiece(piece);\r\n            //for (var k = 0; k < moves.length; k++)\r\n            //    playerScore += moves[k].isCapture() ? 0.2 : 0.1;\r\n\t\t}\r\n\r\n\t\tif (current->GetRelationship(other) == Player::Enemy)\r\n\t\t\tscore -= playerScore;\r\n\t\telse\r\n\t\t\tscore += playerScore;\r\n\t}\r\n\r\n\treturn score;\r\n}","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"EndOfGame.h\"\r\n#include \"PieceType.h\"\r\n#include \"Player.h\"\r\n\r\nclass Board;\r\nclass GameState;\r\nclass Move;\r\nclass TurnOrder;\r\n\r\nclass Game\r\n{\r\npublic:\r\n\tGame();\r\n\t~Game();\r\n\r\n\ttypedef enum { MoveComplete, GameComplete, MoveError } MoveResult_t;\r\n\r\n\tvoid Start();\r\n\tMoveResult_t PerformMove(Move *move);\r\n\r\n\tBoard *GetBoard() { return board; }\r\n\tGameState *GetCurrentState() { return currentState; }\r\n\tTurnOrder *GetTurnOrder() { return turnOrder; }\r\n\tEndOfGame *GetEndOfGame() { return endOfGame; }\r\n\tstd::list<Move*> *GetPossibleMoves() { return possibleMoves; }\r\n\tbool GetHoldCapturedPieces() { return holdCapturedPieces; }\r\n\r\n\tstd::list<PieceType*> GetAllPieceTypes() { return allPieceTypes; }\r\n\tstd::list<Player*> GetPlayers() { return players; }\r\nprivate:\r\n\tbool StartNextTurn();\r\n\tbool EndTurn(GameState *newState, Move *move);\r\n\tvoid ProcessEndOfGame(EndOfGame::CheckType_t);\r\n\tvoid EndGame(Player *victor);\r\n\r\n\tvoid ClearPossibleMoves();\r\n\tvoid LogMove(Player *player, Move *move);\r\n\r\n\tBoard *board;\r\n\tGameState *currentState;\r\n\tTurnOrder *turnOrder;\r\n\tEndOfGame *endOfGame;\r\n\tstd::list<PieceType*> allPieceTypes;\r\n\tstd::list<Player*> players;\r\n\tstd::list<Move*> *possibleMoves;\r\n\r\n\tbool holdCapturedPieces;\r\n\t\r\n\tfriend class GameParser;\r\n\tfriend class GameState;\r\n\tfriend class Move;\r\n};\r\n\r\n","// -*- C++ -*-\n//===---------------------------- list ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIST\n#define _LIBCPP_LIST\n\n/*\n    list synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\npublic:\n\n    // types:\n    typedef T value_type;\n    typedef Alloc allocator_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef implementation-defined size_type;\n    typedef implementation-defined difference_type;\n    typedef reverse_iterator<iterator> reverse_iterator;\n    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n\n    list()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit list(const allocator_type& a);\n    explicit list(size_type n);\n    explicit list(size_type n, const allocator_type& a); // C++14\n    list(size_type n, const value_type& value);\n    list(size_type n, const value_type& value, const allocator_type& a);\n    template <class Iter>\n        list(Iter first, Iter last);\n    template <class Iter>\n        list(Iter first, Iter last, const allocator_type& a);\n    list(const list& x);\n    list(const list&, const allocator_type& a);\n    list(list&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    list(list&&, const allocator_type& a);\n    list(initializer_list<value_type>);\n    list(initializer_list<value_type>, const allocator_type& a);\n\n    ~list();\n\n    list& operator=(const list& x);\n    list& operator=(list&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    list& operator=(initializer_list<value_type>);\n    template <class Iter>\n        void assign(Iter first, Iter last);\n    void assign(size_type n, const value_type& t);\n    void assign(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    bool empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    template <class... Args>\n        void emplace_front(Args&&... args);\n    void pop_front();\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n    void push_front(const value_type& x);\n    void push_front(value_type&& x);\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class Iter>\n        iterator insert(const_iterator position, Iter first, Iter last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator position, const_iterator last);\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(list&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void clear() noexcept;\n\n    void splice(const_iterator position, list& x);\n    void splice(const_iterator position, list&& x);\n    void splice(const_iterator position, list& x, const_iterator i);\n    void splice(const_iterator position, list&& x, const_iterator i);\n    void splice(const_iterator position, list& x, const_iterator first,\n                                                  const_iterator last);\n    void splice(const_iterator position, list&& x, const_iterator first,\n                                                  const_iterator last);\n\n    void remove(const value_type& value);\n    template <class Pred> void remove_if(Pred pred);\n    void unique();\n    template <class BinaryPredicate>\n        void unique(BinaryPredicate binary_pred);\n    void merge(list& x);\n    void merge(list&& x);\n    template <class Compare>\n        void merge(list& x, Compare comp);\n    template <class Compare>\n        void merge(list&& x, Compare comp);\n    void sort();\n    template <class Compare>\n        void sort(Compare comp);\n    void reverse() noexcept;\n};\n\ntemplate <class T, class Alloc>\n    bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator< (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator!=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator> (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator>=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator<=(const list<T,Alloc>& x, const list<T,Alloc>& y);\n\ntemplate <class T, class Alloc>\n    void swap(list<T,Alloc>& x, list<T,Alloc>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n\n#include <memory>\n#include <limits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _VoidPtr> struct __list_node;\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node_base\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other pointer;\n#endif\n\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node_base> __base_pointer;\n#else\n        rebind<__list_node_base>::other __base_pointer;\n#endif\n\n    pointer __prev_;\n    pointer __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_node_base() : __prev_(__self()), __next_(__self()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __self()\n    {\n        return static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this));\n    }\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node\n    : public __list_node_base<_Tp, _VoidPtr>\n{\n    _Tp __value_;\n};\n\ntemplate <class _Tp, class _Alloc> class _LIBCPP_TYPE_VIS_ONLY list;\ntemplate <class _Tp, class _Alloc> class __list_imp;\ntemplate <class _Tp, class _VoidPtr> class _LIBCPP_TYPE_VIS_ONLY __list_const_iterator;\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\n    template<class, class> friend class __list_const_iterator;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef value_type&                      reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator(const __list_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator=(const __list_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_iterator& __x, const __list_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_const_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__p);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_const_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator=(const __list_const_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::const_iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _Alloc>\nclass __list_imp\n{\n    __list_imp(const __list_imp&);\n    __list_imp& operator=(const __list_imp&);\nprotected:\n    typedef _Tp                                                     value_type;\n    typedef _Alloc                                                  allocator_type;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n    typedef typename __alloc_traits::size_type                      size_type;\n    typedef typename __alloc_traits::void_pointer                   __void_pointer;\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\n    typedef __list_const_iterator<value_type, __void_pointer>       const_iterator;\n    typedef __list_node_base<value_type, __void_pointer>            __node_base;\n    typedef __list_node<value_type, __void_pointer>                 __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node>\n#else\n                rebind_alloc<__node>::other\n#endif\n                                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>                       __node_alloc_traits;\n    typedef typename __node_alloc_traits::pointer                    __node_pointer;\n    typedef typename __node_alloc_traits::pointer                    __node_const_pointer;\n    typedef typename __alloc_traits::pointer                         pointer;\n    typedef typename __alloc_traits::const_pointer                   const_pointer;\n    typedef typename __alloc_traits::difference_type                 difference_type;\n\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node_base>\n#else\n                rebind_alloc<__node_base>::other\n#endif\n                                                                     __node_base_allocator;\n    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;\n\n    __node_base __end_;\n    __compressed_pair<size_type, __node_allocator> __size_alloc_;\n\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& __sz() _NOEXCEPT {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __sz() const _NOEXCEPT\n        {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT\n          {return __size_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __size_alloc_.second();}\n\n    static void __unlink_nodes(__node_pointer __f, __node_pointer __l) _NOEXCEPT;\n\n    __list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value);\n    __list_imp(const allocator_type& __a);\n    ~__list_imp();\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __sz() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const  _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(__end_.__next_, this);\n#else\n        return const_iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__node_pointer>(\n                pointer_traits<__node_base_pointer>::pointer_to(__end_)), this);\n#else\n        return iterator(static_cast<__node_pointer>(\n                      pointer_traits<__node_base_pointer>::pointer_to(__end_)));\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))), this);\n#else\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))));\n#endif\n    }\n\n    void swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c)\n        _NOEXCEPT_(\n            !__node_alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, true_type)\n        {\n            if (__node_alloc() != __c.__node_alloc())\n                clear();\n            __node_alloc() = __c.__node_alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {\n            __node_alloc() = _VSTD::move(__c.__node_alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, false_type)\n        _NOEXCEPT\n        {}\n};\n\n// Unlink nodes [__f, __l]\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__list_imp<_Tp, _Alloc>::__unlink_nodes(__node_pointer __f, __node_pointer __l)\n    _NOEXCEPT\n{\n    __f->__prev_->__next_ = __l->__next_;\n    __l->__next_->__prev_ = __f->__prev_;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    : __size_alloc_(0)\n{\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)\n    : __size_alloc_(0, __node_allocator(__a))\n{\n}\n\ntemplate <class _Tp, class _Alloc>\n__list_imp<_Tp, _Alloc>::~__list_imp()\n{\n    clear();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::clear() _NOEXCEPT\n{\n    if (!empty())\n    {\n        __node_allocator& __na = __node_alloc();\n        __node_pointer __f = __end_.__next_;\n        __node_pointer __l = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n        __unlink_nodes(__f, __l->__prev_);\n        __sz() = 0;\n        while (__f != __l)\n        {\n            __node_pointer __n = __f;\n            __f = __f->__next_;\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != __l)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __c.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    using _VSTD::swap;\n    __swap_alloc(__node_alloc(), __c.__node_alloc());\n    swap(__sz(), __c.__sz());\n    swap(__end_, __c.__end_);\n    if (__sz() == 0)\n        __end_.__next_ = __end_.__prev_ = __end_.__self();\n    else\n        __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_.__self();\n    if (__c.__sz() == 0)\n        __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_.__self();\n    else\n        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_.__self();\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __libcpp_db* __db = __get_db();\n    __c_node* __cn1 = __db->__find_c_and_lock(this);\n    __c_node* __cn2 = __db->__find_c(&__c);\n    std::swap(__cn1->beg_, __cn2->beg_);\n    std::swap(__cn1->end_, __cn2->end_);\n    std::swap(__cn1->cap_, __cn2->cap_);\n    for (__i_node** __p = __cn1->end_; __p != __cn1->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n        {\n            __cn2->__add(*__p);\n            if (--__cn1->end_ != __p)\n                memmove(__p, __p+1, (__cn1->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn1;\n    }\n    for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_)))\n        {\n            __cn1->__add(*__p);\n            if (--__cn2->end_ != __p)\n                memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn2;\n    }\n    __db->unlock();\n#endif\n}\n\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY list\n    : private __list_imp<_Tp, _Alloc>\n{\n    typedef __list_imp<_Tp, _Alloc> base;\n    typedef typename base::__node              __node;\n    typedef typename base::__node_allocator    __node_allocator;\n    typedef typename base::__node_pointer      __node_pointer;\n    typedef typename base::__node_alloc_traits __node_alloc_traits;\n    typedef typename base::__node_base         __node_base;\n    typedef typename base::__node_base_pointer __node_base_pointer;\n\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Alloc                                   allocator_type;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename base::pointer                   pointer;\n    typedef typename base::const_pointer             const_pointer;\n    typedef typename base::size_type                 size_type;\n    typedef typename base::difference_type           difference_type;\n    typedef typename base::iterator                  iterator;\n    typedef typename base::const_iterator            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    list()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    explicit list(const allocator_type& __a) : base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit list(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit list(size_type __n, const allocator_type& __a);\n#endif\n    list(size_type __n, const value_type& __x);\n    list(size_type __n, const value_type& __x, const allocator_type& __a);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n\n    list(const list& __c);\n    list(const list& __c, const allocator_type& __a);\n    list& operator=(const list& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    list(initializer_list<value_type> __il);\n    list(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    list(list&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value);\n    list(list&& __c, const allocator_type& __a);\n    list& operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    list& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InpIter>\n        void assign(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT     {return base::__sz();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT         {return base::empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return numeric_limits<difference_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT        {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT          {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    reference back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n       void emplace_front(_Args&&... __args);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n    template <class... _Args>\n        iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    iterator insert(const_iterator __p, value_type&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void push_front(const value_type& __x);\n    void push_back(const value_type& __x);\n\n    iterator insert(const_iterator __p, const value_type& __x);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __x);\n    template <class _InpIter>\n        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(list& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {base::swap(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {base::clear();}\n\n    void pop_front();\n    void pop_back();\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __x);\n\n    void splice(const_iterator __p, list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}\n#endif\n    void splice(const_iterator __p, list& __c, const_iterator __i);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __i)\n        {splice(__p, __c, __i);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)\n        {splice(__p, __c, __f, __l);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void remove(const value_type& __x);\n    template <class _Pred> void remove_if(_Pred __pred);\n    void unique();\n    template <class _BinaryPred>\n        void unique(_BinaryPred __binary_pred);\n    void merge(list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(list&& __c) {merge(__c);}\n#endif\n    template <class _Comp>\n        void merge(list& __c, _Comp __comp);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Comp>\n    _LIBCPP_INLINE_VISIBILITY\n        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void sort();\n    template <class _Comp>\n        void sort(_Comp __comp);\n\n    void reverse() _NOEXCEPT;\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    static void __link_nodes  (__node_pointer __p, __node_pointer __f, __node_pointer __l);\n    void __link_nodes_at_front(__node_pointer __f, __node_pointer __l);\n    void __link_nodes_at_back (__node_pointer __f, __node_pointer __l);\n    iterator __iterator(size_type __n);\n    template <class _Comp>\n        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);\n\n    void __move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value);\n    void __move_assign(list& __c, false_type);\n};\n\n// Link in nodes [__f, __l] just prior to __p\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l)\n{\n    __p->__prev_->__next_ = __f;\n    __f->__prev_ = __p->__prev_;\n    __p->__prev_ = __l;\n    __l->__next_ = __p;\n}\n\n// Link in nodes [__f, __l] at the front of the list\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes_at_front(__node_pointer __f, __node_pointer __l)\n{\n    __f->__prev_ = base::__end_.__self();\n    __l->__next_ = base::__end_.__next_;\n    __l->__next_->__prev_ = __l;\n    base::__end_.__next_ = __f;\n}\n\n// Link in nodes [__f, __l] at the front of the list\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes_at_back(__node_pointer __f, __node_pointer __l)\n{\n    __l->__next_ = base::__end_.__self();\n    __f->__prev_ = base::__end_.__prev_;\n    __f->__prev_->__next_ = __f;\n    base::__end_.__prev_ = __l;\n}\n\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__iterator(size_type __n)\n{\n    return __n <= base::__sz() / 2 ? _VSTD::next(begin(), __n)\n                                   : _VSTD::prev(end(), base::__sz() - __n);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n#endif\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c)\n    : base(allocator_type(\n           __node_alloc_traits::select_on_container_copy_construction(\n                __c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(const list& __c)\n{\n    if (this != &__c)\n    {\n        base::__copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value)\n    : base(allocator_type(_VSTD::move(__c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    splice(end(), __c);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __c.get_allocator())\n        splice(end(), __c);\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __node_alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, false_type)\n{\n    if (base::__node_alloc() != __c.__node_alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n{\n    clear();\n    base::__move_assign_alloc(__c);\n    splice(end(), __c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nvoid\nlist<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,\n                          typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __f != __l && __i != __e; ++__f, ++__i)\n        *__i = *__f;\n    if (__i == __e)\n        insert(__e, __f, __l);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __n > 0 && __i != __e; --__n, ++__i)\n        *__i = __x;\n    if (__i == __e)\n        insert(__e, __n, __x);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n_Alloc\nlist<_Tp, _Alloc>::get_allocator() const _NOEXCEPT\n{\n    return allocator_type(base::__node_alloc());\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__n > 0)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, range) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__f != __l)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (++__f; __f != __l; ++__f, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_front(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_back(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::emplace(iterator, args...) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_front()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_front() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_back() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__prev_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __p)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::erase(iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    _LIBCPP_ASSERT(__p != end(),\n        \"list::erase(iterator) called with a non-dereferenceable iterator\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = __p.__ptr_;\n    __node_pointer __r = __n->__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__r, this);\n#else\n    return iterator(__r);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == this,\n        \"list::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (__f != __l)\n    {\n        __node_allocator& __na = base::__node_alloc();\n        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);\n        while (__f != __l)\n        {\n            __node_pointer __n = __f.__ptr_;\n            ++__f;\n            --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __c_node* __c = __get_db()->__find_c_and_lock(this);\n            for (__i_node** __p = __c->end_; __p != __c->beg_; )\n            {\n                --__p;\n                iterator* __i = static_cast<iterator*>((*__p)->__i_);\n                if (__i->__ptr_ == __n)\n                {\n                    (*__p)->__c_ = nullptr;\n                    if (--__c->end_ != __p)\n                        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n            __get_db()->unlock();\n#endif\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__l.__ptr_, this);\n#else\n    return iterator(__l.__ptr_);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes_at_back(__r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c)\n{\n    _LIBCPP_ASSERT(this != &__c,\n                   \"list::splice(iterator, list) called with this == &list\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (!__c.empty())\n    {\n        __node_pointer __f = __c.__end_.__next_;\n        __node_pointer __l = __c.__end_.__prev_;\n        base::__unlink_nodes(__f, __l);\n        __link_nodes(__p.__ptr_, __f, __l);\n        base::__sz() += __c.__sz();\n        __c.__sz() = 0;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__i) == &__c,\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(&__i),\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" derefereceable\");\n#endif\n    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)\n    {\n        __node_pointer __f = __i.__ptr_;\n        base::__unlink_nodes(__f, __f);\n        __link_nodes(__p.__ptr_, __f, __f);\n        --__c.__sz();\n        ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            if (__j->__ptr_ == __f)\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == &__c,\n        \"list::splice(iterator, list, iterator, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    if (this == &__c)\n    {\n        for (const_iterator __i = __f; __i != __l; ++__i)\n            _LIBCPP_ASSERT(__i != __p,\n                           \"list::splice(iterator, list, iterator, iterator)\"\n                           \" called with the first iterator within the range\"\n                           \" of the second and third iterators\");\n    }\n#endif\n    if (__f != __l)\n    {\n        if (this != &__c)\n        {\n            size_type __s = _VSTD::distance(__f, __l);\n            __c.__sz() -= __s;\n            base::__sz() += __s;\n        }\n        __node_pointer __first = __f.__ptr_;\n        --__l;\n        __node_pointer __last = __l.__ptr_;\n        base::__unlink_nodes(__first, __last);\n        __link_nodes(__p.__ptr_, __first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            for (__node_pointer __k = __f.__ptr_;\n                                          __k != __l.__ptr_; __k = __k->__next_)\n            {\n                if (__j->__ptr_ == __k)\n                {\n                    __cn1->__add(*__p);\n                    (*__p)->__c_ = __cn1;\n                    if (--__cn2->end_ != __p)\n                        memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::remove(const value_type& __x)\n{\n    list<_Tp, _Alloc> __deleted_nodes; // collect the nodes we're removing\n    for (const_iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (*__i == __x)\n        {\n            const_iterator __j = _VSTD::next(__i);\n            for (; __j != __e && *__j == __x; ++__j)\n                ;\n            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);\n            __i = __j;\n            if (__i != __e)\n                ++__i;\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Pred>\nvoid\nlist<_Tp, _Alloc>::remove_if(_Pred __pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (__pred(*__i))\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && __pred(*__j); ++__j)\n                ;\n            __i = erase(__i, __j);\n            if (__i != __e)\n                ++__i;\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::unique()\n{\n    unique(__equal_to<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _BinaryPred>\nvoid\nlist<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        iterator __j = _VSTD::next(__i);\n        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)\n            ;\n        if (++__i != __j)\n            __i = erase(__i, __j);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::merge(list& __c)\n{\n    merge(__c, __less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\nvoid\nlist<_Tp, _Alloc>::merge(list& __c, _Comp __comp)\n{\n    if (this != &__c)\n    {\n        iterator __f1 = begin();\n        iterator __e1 = end();\n        iterator __f2 = __c.begin();\n        iterator __e2 = __c.end();\n        while (__f1 != __e1 && __f2 != __e2)\n        {\n            if (__comp(*__f2, *__f1))\n            {\n                size_type __ds = 1;\n                iterator __m2 = _VSTD::next(__f2);\n                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)\n                    ;\n                base::__sz() += __ds;\n                __c.__sz() -= __ds;\n                __node_pointer __f = __f2.__ptr_;\n                __node_pointer __l = __m2.__ptr_->__prev_;\n                __f2 = __m2;\n                base::__unlink_nodes(__f, __l);\n                __m2 = _VSTD::next(__f1);\n                __link_nodes(__f1.__ptr_, __f, __l);\n                __f1 = __m2;\n            }\n            else\n                ++__f1;\n        }\n        splice(__e1, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort()\n{\n    sort(__less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort(_Comp __comp)\n{\n    __sort(begin(), end(), base::__sz(), __comp);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)\n{\n    switch (__n)\n    {\n    case 0:\n    case 1:\n        return __f1;\n    case 2:\n        if (__comp(*--__e2, *__f1))\n        {\n            __node_pointer __f = __e2.__ptr_;\n            base::__unlink_nodes(__f, __f);\n            __link_nodes(__f1.__ptr_, __f, __f);\n            return __e2;\n        }\n        return __f1;\n    }\n    size_type __n2 = __n / 2;\n    iterator __e1 = _VSTD::next(__f1, __n2);\n    iterator  __r = __f1 = __sort(__f1, __e1, __n2, __comp);\n    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);\n    if (__comp(*__f2, *__f1))\n    {\n        iterator __m2 = _VSTD::next(__f2);\n        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n            ;\n        __node_pointer __f = __f2.__ptr_;\n        __node_pointer __l = __m2.__ptr_->__prev_;\n        __r = __f2;\n        __e1 = __f2 = __m2;\n        base::__unlink_nodes(__f, __l);\n        __m2 = _VSTD::next(__f1);\n        __link_nodes(__f1.__ptr_, __f, __l);\n        __f1 = __m2;\n    }\n    else\n        ++__f1;\n    while (__f1 != __e1 && __f2 != __e2)\n    {\n        if (__comp(*__f2, *__f1))\n        {\n            iterator __m2 = _VSTD::next(__f2);\n            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n                ;\n            __node_pointer __f = __f2.__ptr_;\n            __node_pointer __l = __m2.__ptr_->__prev_;\n            if (__e1 == __f2)\n                __e1 = __m2;\n            __f2 = __m2;\n            base::__unlink_nodes(__f, __l);\n            __m2 = _VSTD::next(__f1);\n            __link_nodes(__f1.__ptr_, __f, __l);\n            __f1 = __m2;\n        }\n        else\n            ++__f1;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::reverse() _NOEXCEPT\n{\n    if (base::__sz() > 1)\n    {\n        iterator __e = end();\n        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)\n        {\n            _VSTD::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);\n            __i.__ptr_ = __i.__ptr_->__prev_;\n        }\n        _VSTD::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__invariants() const\n{\n    return size() == _VSTD::distance(begin(), end());\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(this->__end_)));\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__decrementable(const const_iterator* __i) const\n{\n    return !empty() &&  __i->__ptr_ != base::__end_.__next_;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIST\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass Cell;\r\nclass GameState;\r\nclass MoveStep;\r\nclass Player;\r\nclass Piece;\r\nclass PieceType;\r\n\r\n#define MAX_NOTATION_DETAIL 3\r\n#define NOTATION_LENGTH 10\r\n\r\nclass Move\r\n{\r\npublic:\r\n\tMove(Player *player, GameState *prevState, Piece *piece, Cell *startPos);\r\n\t~Move();\r\n\r\n\tvoid AddStep(MoveStep *step) { steps.push_back(step); }\r\n\r\n\tMove *Clone();\r\n\tGameState *Perform(bool updateDisplay);\r\n\tbool Reverse(bool updateDisplay);\r\n\r\n\tchar *DetermineNotation(int detailLevel);\r\n\tchar *GetNotation() { return notation; }\r\n\r\n\tvoid AddPieceReference(Piece *piece, const char *ref);\r\n\tPiece *GetPieceByReference(const char *ref);\r\n\r\n\tCell *GetEndPos();\r\n\tstd::list<Cell*> GetAllPositions();\r\n\tbool IsCapture();\r\n\tbool WouldCapture(Cell* target);\r\n\tPieceType *GetPromotionType();\r\n\tPlayer *GetPlayer() { return player; }\r\n\tGameState *GetPrevState() { return prevState; }\r\n\tstd::list<MoveStep*> GetSteps() { return steps; }\r\nprivate:\r\n\tPlayer *player;\r\n\tGameState *prevState;\r\n\tPiece *piece;\r\n\tCell *startPos;\r\n\tchar notation[NOTATION_LENGTH];\r\n\r\n\tstd::list<MoveStep*> steps;\r\n\tstd::map<const char*, Piece*, char_cmp> references;\r\n\r\n\tint prevPieceMoveTurn;\r\n\r\n\tfriend class GameState;\r\n};\r\n\r\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass Game;\r\nclass Move;\r\nclass Piece;\r\nclass Player;\r\n\r\nclass GameState\r\n{\r\npublic:\r\n\tGameState(Game *game, Player *currentPlayer, int turnNumber);\r\n\t~GameState();\r\n\r\n\tstd::list<Move*> *PrepareMovesForTurn();\r\n\tstd::list<Move*> *DeterminePossibleMoves();\r\n\tstd::list<Move*> *DetermineThreatMoves();\r\n\tGame *GetGame() { return game; }\r\n\tPlayer *GetCurrentPlayer() { return currentPlayer; }\r\n\tint GetTurnNumber() { return turnNumber; }\r\n\r\nprivate:\r\n\tGame *game;\r\n\tPlayer *currentPlayer;\r\n\tint turnNumber;\r\n\r\n\tvoid CalculateMovesForPlayer(Player *player, std::list<Move*> *output);\r\n\r\n\tfriend class EndOfGame;\r\n\tfriend class Game;\r\n\tfriend class Move;\r\n};\r\n\r\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass PlayerAI;\r\nclass Game;\r\nclass Piece;\r\n\r\n#define PLAYER_NAME_LENGTH 16\r\n\r\nclass Player\r\n{\r\npublic:\r\n\ttypedef enum { Local, AI, Remote } Type_t;\r\n\ttypedef enum { Any, Self, Enemy, Ally } Relationship_t;\r\n\r\n\tPlayer(Game *game, char *name, direction_t forwardDir);\r\n\t~Player();\r\n\r\n\tchar *GetName() { return name; }\r\n\tGame *GetGame() { return game; }\r\n\tType_t GetType() { return type; }\r\n\tvoid SetType(Type_t t) { type = t; }\r\n\tPlayerAI *GetAI() { return ai; }\r\n\tvoid SetAI(PlayerAI* ai);\r\n\r\n\tdirection_t ResolveDirections(direction_t dir, direction_t prevDir);\r\n\tRelationship_t GetRelationship(Player *other);\r\n\tdirection_t GetForwardDirection() { return forwardDir; }\r\n\t\r\n\tstd::set<Piece*> GetPiecesOnBoard() { return piecesOnBoard; }\r\n\r\nprivate:\r\n\tGame *game;\r\n\tPlayerAI *ai;\r\n\tchar name[PLAYER_NAME_LENGTH];\r\n\tint id;\r\n\tdirection_t forwardDir;\r\n\tType_t type;\r\n\r\n\tstd::set<Piece*> piecesOnBoard, piecesHeld, piecesCaptured;\r\n\r\n\tstatic int nextID;\r\n\r\n\tfriend class EndOfGame;\r\n\tfriend class Game;\r\n\tfriend class MoveStep;\r\n\tfriend class GameParser;\r\n\tfriend class GameState;\r\n};\r\n\r\n","// -*- C++ -*-\n//===---------------------------- set -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SET\n#define _LIBCPP_SET\n\n/*\n\n    set synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass set\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    set()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit set(const value_compare& comp);\n    set(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last,\n            const value_compare& comp = value_compare());\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const value_compare& comp,\n            const allocator_type& a);\n    set(const set& s);\n    set(set&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit set(const allocator_type& a);\n    set(const set& s, const allocator_type& a);\n    set(set&& s, const allocator_type& a);\n    set(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    set(initializer_list<value_type> il, const value_compare& comp,\n        const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    set(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~set();\n\n    set& operator=(const set& s);\n    set& operator=(set&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    set& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator,bool> insert(const value_type& v);\n    pair<iterator,bool> insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(set& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass multiset\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    multiset()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multiset(const value_compare& comp);\n    multiset(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp = value_compare());\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp, const allocator_type& a);\n    multiset(const multiset& s);\n    multiset(multiset&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multiset(const allocator_type& a);\n    multiset(const multiset& s, const allocator_type& a);\n    multiset(multiset&& s, const allocator_type& a);\n    multiset(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    multiset(initializer_list<value_type> il, const value_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    multiset(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~multiset();\n\n    multiset& operator=(const multiset& s);\n    multiset& operator=(multiset&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multiset& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multiset& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <functional>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY set\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                 key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    set()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l,\n            const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,\n            const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : set(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s)\n        : __tree_(__s.__tree_)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(const set& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const allocator_type& __a)\n        : __tree_(__a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    set(set&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    set(initializer_list<value_type> __il, const allocator_type& __a)\n        : set(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(const value_type& __v)\n        {return __tree_.__insert_unique(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(value_type&& __v)\n        {return __tree_.__insert_unique(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_unique(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_unique(__p, _VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_unique(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(set& __s) _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nset<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\n// specialized algorithms:\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(set<_Key, _Compare, _Allocator>& __x,\n     set<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY multiset\n{\npublic:\n    // types:\n    typedef _Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                                allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    multiset()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : multiset(__f, __l, key_compare(), __a) {}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s)\n        : __tree_(__s.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(const multiset& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const allocator_type& __a)\n        : __tree_(__a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    multiset(multiset&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multiset(initializer_list<value_type> __il, const allocator_type& __a)\n        : multiset(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v)\n        {return __tree_.__insert_multi(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_multi(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multiset& __s)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_multi(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nmultiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multiset<_Key, _Compare, _Allocator>& __x,\n     multiset<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SET\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multimap;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY set;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multiset;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Allocator> class __map_node_destructor;\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(false)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_end_node\n             <\n                typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__tree_node_base<_VoidPtr> >\n#else\n                     rebind<__tree_node_base<_VoidPtr> >::other\n#endif\n             >\n{\n    __tree_node_base(const __tree_node_base&);\n    __tree_node_base& operator=(const __tree_node_base&);\npublic:\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__tree_node_base>\n#else\n            rebind<__tree_node_base>::other\n#endif\n                                                pointer;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const __tree_node_base>\n#else\n            rebind<const __tree_node_base>::other\n#endif\n                                                const_pointer;\n    typedef __tree_end_node<pointer> base;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_node_base() _NOEXCEPT\n        : __right_(), __parent_(), __is_black_(false) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef __tree_node_base<_VoidPtr> base;\n    typedef _Tp value_type;\n\n    value_type __value_;\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tree_node(_Args&& ...__args)\n            : __value_(_VSTD::forward<_Args>(__args)...) {}\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node(const value_type& __v)\n            : __value_(__v) {}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n};\n\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef _NodePtr                                              __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename __node_base::pointer                         __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag iterator_category;\n    typedef _Tp                        value_type;\n    typedef _DiffType                  difference_type;\n    typedef value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef _ConstNodePtr                                         __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node_base>\n#else\n            rebind<__node_base>::other\n#endif\n                                                                  __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef _DiffType                        difference_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef typename remove_const<__node>::type  __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                 __non_const_node_pointer;\n    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>\n                                                 __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef typename __alloc_traits::void_pointer  __void_pointer;\n\n    typedef __tree_node<value_type, __void_pointer> __node;\n    typedef __tree_node_base<__void_pointer>        __node_base;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef typename __node_base::pointer            __node_base_pointer;\n    typedef typename __node_base::pointer            __node_base_const_pointer;\nprivate:\n    typedef typename __node_base::base __end_node_t;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_ptr;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_const_ptr;\n\n    __node_pointer                                          __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>\n               (\n                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_const_pointer>\n               (\n                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() _NOEXCEPT\n        {return static_cast<__node_pointer>      (__end_node()->__left_);}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_const_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value));\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        pair<iterator, bool>\n        __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n        iterator\n        __emplace_hint_unique(const_iterator __p, _Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Vp>\n        pair<iterator, bool> __insert_unique(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_unique(const_iterator __p, _Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(const_iterator __p, _Vp&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    pair<iterator, bool> __insert_unique(const value_type& __v);\n    iterator __insert_unique(const_iterator __p, const value_type& __v);\n    iterator __insert_multi(const value_type& __v);\n    iterator __insert_multi(const_iterator __p, const value_type& __v);\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const value_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        __node_holder __construct_node(const value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _VSTD::move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _VSTD::addressof(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n    _NOEXCEPT_(\n        __is_nothrow_swappable<value_compare>::value &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value))\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_alloc(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const value_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    iterator __r = __node_insert_unique(__p, __h.get());\n    if (__r.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, const_cast<value_type*>(_VSTD::addressof(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"Cell.h\"\r\n#include \"PieceType.h\"\r\n#include \"Player.h\"\r\n\r\nclass Piece\r\n{\r\npublic:\r\n\ttypedef enum { OnBoard, Captured, Held } State_t;\r\n\r\n\tPiece(Player *owner, PieceType *type, Cell *position, State_t state, Player *stateOwner);\r\n\t~Piece();\r\n\r\n\tbool CanCapture(Piece *target);\r\n\tbool TypeMatches(/*std::string type*/ PieceType *type);\r\n\r\n\tPlayer *GetOwner() { return owner; }\r\n\tPlayer *GetStateOwner() { return stateOwner; }\r\n\tPieceType *GetType() { return pieceType; }\r\n\tCell *GetPosition() { return position; }\r\n\tState_t GetState() { return pieceState; }\r\n\tint GetMoveNumber() { return moveNumber; }\r\n\tint GetLastMoveTurn() { return lastMoveTurn; }\r\n\r\n\tint GetID() { return uniqueID; }\r\nprivate:\r\n\tstatic int nextID;\r\n\tint uniqueID, moveNumber, lastMoveTurn;\r\n\tPlayer *owner;\r\n\tPlayer *stateOwner;\r\n\tPieceType *pieceType;\r\n\tCell *position;\r\n\tState_t pieceState;\r\n\r\n\tfriend class Move;\r\n\tfriend class MoveStep;\r\n\tfriend class GameParser;\r\n};\r\n\r\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass MoveDefinition;\r\n\r\n#define TYPE_NAME_LENGTH 32\r\n#define TYPE_NOTATION_LENGTH 3\r\n\r\nclass PieceType\r\n{\r\npublic:\r\n\tPieceType();\r\n\t~PieceType();\r\n\tstd::list<MoveDefinition*> &GetMoves() { return moves; }\r\n\tconst char *GetName() { return name; }\r\n\tint GetValue() { return value; }\r\n\r\nprivate:\r\n\tint value = 1;\r\n\tchar name[TYPE_NAME_LENGTH];\r\n\tchar notation[TYPE_NOTATION_LENGTH];\r\n\tstd::list<MoveDefinition*> moves;\r\n\r\n#ifndef NO_SVG\r\n\tstd::map<int, char*> appearances;\r\n#endif\r\n\t//std::list<PromotionOpportunity*> promotionOpportunities;\r\n\tPieceType *capturedAs;\r\n\r\n\tfriend class GameParser;\r\n\tfriend class Move;\r\n};\r\n\r\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"EndOfGame.h\"\r\n\r\nclass Game;\r\nclass GameState;\r\nclass Move;\r\n\r\nclass PlayerAI\r\n{\r\npublic:\r\n\tPlayerAI(Game *game) { this->game = game; }\r\n\tvirtual ~PlayerAI() {\t}\r\n\r\n\tvirtual Move *SelectMove() = 0;\r\nprotected:\r\n\tGame *game;\r\n};\r\n\r\n\r\nclass AI_Random : public PlayerAI\r\n{\r\npublic:\r\n\tAI_Random(Game *game) : PlayerAI(game) { }\r\n\tvirtual Move *SelectMove();\r\n};\r\n\r\n\r\nclass AI_RandomCapture : public AI_Random\r\n{\r\npublic:\r\n\tAI_RandomCapture(Game *game) : AI_Random(game) { }\r\n\tvirtual Move *SelectMove();\r\n};\r\n\r\n\r\nclass AI_AlphaBeta : public PlayerAI\r\n{\r\npublic:\r\n\tAI_AlphaBeta(Game *game, int ply) : PlayerAI(game) { this->ply = ply; }\r\n\tvirtual Move *SelectMove();\r\nprivate:\r\n\tdouble FindBestScore(GameState *state, double alpha, double beta, int depth);\r\n\tdouble GetMoveScore(Move *move, double alpha, double beta, int depth);\r\n\tdouble GetScoreForEndOfGame(EndOfGame::CheckType_t result);\r\n\tdouble EvaluateBoard(GameState *state);\r\n\tint ply;\r\n};","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source();\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\nnamespace __libcpp_is_member_function_pointer_imp {\n    template <typename _Tp>\n    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);\n\n    template <typename>\n    std::__two __test(...);\n};\n    \ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_final\n\n#if _LIBCPP_STD_VER > 11 && __has_feature(is_final)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY \nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote\n{\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n    static const bool __does_not_throw = _NOEXCEPT_OR_FALSE(static_cast<type>(declval<_A1>()));\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\n//\tif it's a reference, return true\n//\tif it's a function, return false\n//\tif it's   void,     return false\n//\tif it's an array of unknown bound, return false\n//\tOtherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n\ttemplate <typename _Tp1>\n\tstatic char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n\ttemplate <typename _Tp1>\n\tstatic __two __test (...);\n\t\n\tstatic const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","#include \"Board.h\"\r\n#include \"Cell.h\"\r\n#include \"Game.h\"\r\n\r\n\r\nBoard::Board(Game *game)\r\n{\r\n\tthis->game = game;\r\n\tcells = 0;\r\n\tallAbsoluteDirections = 0;\r\n}\r\n\r\n\r\nBoard::~Board()\r\n{\r\n\tif (cells != 0)\r\n\t\tdelete [] cells;\r\n}\r\n\r\n\r\ndirection_t Board::ResolveDirections(direction_t dir, direction_t prevDir)\r\n{\r\n\tif (dir == DIRECTION_SAME)\r\n\t\treturn prevDir;\r\n\t\r\n\tif (dir < firstRelativeDirection)\r\n\t\treturn dir; // a single absolute dir, or a group of them.\r\n\r\n\t// must resolve at least one relative direction\r\n\tdirection_t absoluteOnly = dir & allAbsoluteDirections;\r\n\tfor (direction_t rel = firstRelativeDirection; rel <= lastRelativeDirection; rel = rel << 1)\r\n\t\tif ((dir & rel) == rel)\r\n\t\t\tabsoluteOnly |= ResolveRelativeDirection(rel, prevDir);\r\n\t\r\n\treturn absoluteOnly;\r\n}\r\n\r\n\r\ndirection_t Board::ResolveRelativeDirection(direction_t id, direction_t relativeTo)\r\n{\r\n\tstd::map<direction_t, relativeDir_t>::iterator it = relativeDirections.find(id);\r\n\r\n\tif (it == relativeDirections.end())\r\n\t\treturn 0; // this isn't a relative direction\r\n\trelativeDir_t relDir = it->second;\r\n\r\n\trelativeDir_t::iterator it2 = relDir.find(relativeTo);\r\n\tif (it2 == relDir.end())\r\n\t\treturn 0; // this relative direction has no entry for this \"from\" value\r\n\r\n\treturn it2->second;\r\n}\r\n\r\n\r\nint Board::GetMaxDistance(Cell *cell, direction_t direction)\r\n{\r\n\tint num = 0;\r\n\t\r\n\tstd::set<Cell*> alreadyVisited;\r\n\talreadyVisited.insert(cell);\r\n\t\r\n\tcell = cell->FollowLink(direction);\r\n\twhile (cell != 0)\r\n\t{\r\n\t\tnum++;\r\n\r\n\t\t// without this bit, circular boards would infinite loop\r\n\t\tif (alreadyVisited.find(cell) != alreadyVisited.end())\r\n\t\t\tbreak;\r\n\r\n\t\talreadyVisited.insert(cell);\r\n\t\tcell = cell->FollowLink(direction);\r\n\t}\r\n\r\n\treturn num;\r\n}","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value\n#if __has_feature(is_final)\n                                                        && !__is_final(_Compare)\n#endif\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const __value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(\n            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)\n                _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        pair<iterator, bool>\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif\n    __node_holder __construct_node_with_key(const key_type& __k);\n\n    __node_base_pointer&\n        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);\n    __node_base_const_pointer\n        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;\n};\n\n// Find place to insert if __k doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k)\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_const_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_const_pointer __parent;\n    __node_base_const_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\npair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>\nmap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::iterator\nmap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                   _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());\n    if (__r.__i_.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                                    __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        iterator\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                   {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                        _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","#include \"Cell.h\"\r\n\r\nCell::Cell()\r\n{\r\n\tpiece = 0;\r\n}\r\n\r\n\r\nCell::~Cell()\r\n{\r\n}\r\n\r\n\r\nvoid Cell::AddLink(direction_t dir, Cell* destination)\r\n{\r\n\tlinks.insert(std::pair<direction_t, Cell*>(dir, destination));\r\n}\r\n\r\n\r\nCell* Cell::FollowLink(direction_t dir)\r\n{\r\n\tstd::map<direction_t, Cell*>::iterator it = links.find(dir);\r\n\treturn it == links.end() ? 0 : it->second;\r\n}","#include \"Distance.h\"\r\n#include \"MoveStep.h\"\r\n\r\n#define DISTANCE_ANY -1\r\nDistance Distance::Any = Distance(None, DISTANCE_ANY);\r\nDistance Distance::Zero = Distance(None, 0);\r\n\r\n\r\nDistance::Distance(RelativeTo_t relativeTo, int number)\r\n{\r\n\tthis->relativeTo = relativeTo;\r\n\tthis->number = number;\r\n}\r\n\r\n\r\nDistance::~Distance()\r\n{\r\n\t\r\n}\r\n\r\n\r\nint Distance::GetValue(MoveStep *previousStep, int maxDist)\r\n{\r\n\tswitch (relativeTo)\r\n\t{\r\n\tcase None:\r\n\t\treturn this == &Any ? 1 : number; // the minimum for \"any\" is 1, and the max will be maxDist (from getRange)\r\n\tcase Max:\r\n\t\treturn maxDist + number;\r\n\tcase Prev:\r\n\t\tif (previousStep != 0)\r\n\t\t\treturn previousStep->distance + number;\r\n\t\treturn number;\r\n\tdefault:\r\n\t\tReportError(\"Distance has unexpected relative-to value: %i\\n\", (int)relativeTo);\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n\r\nint Distance::GetMaxValue(Distance *dist2, MoveStep *previousStep, int maxDist)\r\n{\r\n\tif (this == &Any)\r\n\t\treturn maxDist;\r\n\r\n\tif (dist2 == 0)\r\n\t\treturn GetValue(previousStep, maxDist);\r\n\t\r\n\treturn dist2->GetValue(previousStep, maxDist);\r\n}","#include \"EndOfGame.h\"\r\n#include \"Game.h\"\r\n#include \"GameState.h\"\r\n#include \"StateConditions.h\"\r\n#include \"TurnOrder.h\"\r\n\r\nEndOfGame::EndOfGame()\r\n{\r\n\tillegalMovesSpecified = false;\r\n}\r\n\r\n\r\nEndOfGame::~EndOfGame()\r\n{\r\n\twhile (!startOfTurnChecks.empty())\r\n\t\tdelete startOfTurnChecks.front(), startOfTurnChecks.pop_front();\r\n\r\n\twhile (!endOfTurnChecks.empty())\r\n\t\tdelete endOfTurnChecks.front(), endOfTurnChecks.pop_front();\r\n}\r\n\r\n\r\nEndOfGame *EndOfGame::CreateDefault()\r\n{\r\n\tEndOfGame *endOfGame = new EndOfGame();\r\n\r\n\tStateConditionGroup *conditions = new StateConditionGroup(Condition::And);\r\n\t// conditions->elements.push_back(new StateCondition_PieceCount(\"self\", 0, Condition::Equals)); todo: add this in, once it exists\r\n\tEndOfGameCheck *outOfPieces = new EndOfGameCheck(Lose, conditions);\r\n    endOfGame->startOfTurnChecks.push_back(outOfPieces);\r\n\r\n\tconditions = new StateConditionGroup(Condition::And);\r\n    conditions->elements.push_back(new StateCondition_CannotMove());\r\n\tEndOfGameCheck *outOfMoves = new EndOfGameCheck(Draw, conditions);\r\n\tendOfGame->startOfTurnChecks.push_back(outOfMoves);\r\n\r\n    return endOfGame;\r\n}\r\n\r\n\r\nEndOfGame::CheckType_t EndOfGame::CheckStartOfTurn(GameState *state, bool canMove)\r\n{\r\n\t// return Win/Lose/Draw, or None if the game isn't over yet\r\n\tauto it = startOfTurnChecks.begin();\r\n\twhile (it != startOfTurnChecks.end())\r\n\t{\r\n\t\tEndOfGameCheck *check = *it;\r\n\t\tif (check->conditions->IsSatisfied(state, canMove))\r\n\t\t\treturn check->type;\r\n\t\tit++;\r\n\t}\r\n\r\n    if (canMove)\r\n        return None;\r\n\r\n    if (state->currentPlayer->piecesOnBoard.size() == 0)\r\n        return EndOfGame::Lose; // can't move and have no pieces. lose.\r\n\r\n\treturn EndOfGame::Draw; // can't move, but have pieces. draw.\r\n}\r\n\r\n\r\nEndOfGame::CheckType_t EndOfGame::CheckEndOfTurn(GameState *state, Move *move)\r\n{\r\n\t// return Win/Lose/Draw/IllegalMove, or None if the game isn't over yet\r\n\r\n\tbool noNextPlayer = state->game->GetTurnOrder()->GetNextPlayer() == 0;\r\n\tstate->game->GetTurnOrder()->StepBackward();\r\n\r\n\tauto it = endOfTurnChecks.begin();\r\n\twhile (it != endOfTurnChecks.end())\r\n\t{\r\n\t\tEndOfGameCheck *check = *it;\r\n\t\tif (check->conditions->IsSatisfied(state, true))\r\n\t\t\treturn check->type;\r\n\t\tit++;\r\n\t}\r\n\r\n    // if the next player is null, we've reached the end of the turn order\r\n    if (noNextPlayer)\r\n        return Draw;\r\n\r\n    return None;\r\n}\r\n\r\n\r\nEndOfGameCheck::~EndOfGameCheck()\r\n{\r\n\tdelete conditions;\r\n}","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"MoveConditions.h\"\r\n\r\nclass StateCondition : public Condition\r\n{\r\npublic:\r\n\tvirtual bool IsSatisfied(GameState *move, bool canMove) = 0;\r\n\tvirtual ~StateCondition() {}\r\n};\r\n\r\n\r\nclass StateConditionGroup : public StateCondition\r\n{\r\npublic:\r\n\tStateConditionGroup(GroupType_t type);\r\n\tvirtual ~StateConditionGroup();\r\n\r\n\tvirtual bool IsSatisfied(GameState *state, bool canMove);\r\nprivate:\r\n\tGroupType_t type;\r\n\tstd::list<StateCondition*> elements;\r\n\r\n\tfriend class EndOfGame;\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass StateCondition_CannotMove : public StateCondition\r\n{\r\npublic:\r\n\tStateCondition_CannotMove() { }\r\n\r\n\tvirtual bool IsSatisfied(GameState *move, bool canMove);\r\n};\r\n\r\n\r\nclass StateCondition_Threatened : public StateCondition\r\n{\r\npublic:\r\n\tStateCondition_Threatened(PieceType *type)\r\n\t{\r\n\t\tthis->type = type;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(GameState *move, bool canMove);\r\nprivate:\r\n\tPieceType *type;\r\n};","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass EndOfGameCheck;\r\nclass GameState;\r\nclass Move;\r\nclass StateConditionGroup;\r\n\r\n\r\nclass EndOfGame\r\n{\r\npublic:\r\n\tEndOfGame();\r\n\t~EndOfGame();\r\n\r\n\ttypedef enum { None, Win, Lose, Draw, IllegalMove } CheckType_t;\r\n\r\n\tstatic EndOfGame *CreateDefault();\r\n\r\n\tCheckType_t CheckStartOfTurn(GameState *state, bool canMove);\r\n\tCheckType_t CheckEndOfTurn(GameState *state, Move *move);\r\n\tbool AnyIllegalMovesSpecified() { return illegalMovesSpecified; }\r\n\r\nprivate:\r\n\tbool illegalMovesSpecified;\r\n\r\n\tstd::list<EndOfGameCheck*> startOfTurnChecks, endOfTurnChecks;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass EndOfGameCheck\r\n{\r\npublic:\r\n\tEndOfGameCheck(EndOfGame::CheckType_t type, StateConditionGroup *conditions) { this->type = type; this->conditions = conditions; }\r\n\t~EndOfGameCheck();\r\n\r\n\tEndOfGame::CheckType_t type;\r\n\tStateConditionGroup *conditions;\r\n};","#include \"Game.h\"\r\n#include \"Board.h\"\r\n#include \"EndOfGame.h\"\r\n#include \"GameState.h\"\r\n#include \"Move.h\"\r\n#include \"TurnOrder.h\"\r\n\r\n\r\nGame::Game()\r\n{\r\n\tboard = 0;\r\n\tcurrentState = 0;\r\n\tendOfGame = 0;\r\n\tturnOrder = 0;\r\n}\r\n\r\n\r\nGame::~Game()\r\n{\r\n\tif (board != 0)\r\n\t\tdelete board;\r\n\tif (currentState != 0)\r\n\t\tdelete currentState;\r\n\tif (endOfGame != 0)\r\n\t\tdelete endOfGame;\r\n\tif (turnOrder != 0)\r\n\t\tdelete turnOrder;\r\n\r\n\tClearPossibleMoves();\r\n\r\n\tauto it = players.begin();\r\n\twhile (it != players.end())\r\n\t{\r\n\t\tdelete (*it);\r\n\t\tit++;\r\n\t}\r\n\r\n\tauto it2 = allPieceTypes.begin();\r\n\twhile (it2 != allPieceTypes.end())\r\n\t{\r\n\t\tdelete (*it2);\r\n\t\tit2++;\r\n\t}\r\n}\r\n\r\nvoid Game::Start()\r\n{\r\n\tif (currentState != 0)\r\n\t{\r\n\t\tReportError(\"Cannot start game, it has already started\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tcurrentState = new GameState(this, turnOrder->GetNextPlayer(), 1);\r\n\tStartNextTurn();\r\n}\r\n\r\n\r\nbool Game::StartNextTurn()\r\n{\r\n#ifdef CONSOLE\r\n\tprintf(\"%s to move\\n\", currentState->GetCurrentPlayer()->GetName());\r\n#endif\r\n#ifdef EMSCRIPTEN\r\n\t//$('#nextMove').text(this.state.currentPlayer.name.substr(0, 1).toUpperCase() + this.state.currentPlayer.name.substr(1) + ' to move');\r\n\t// todo: implement this\r\n#endif\r\n\r\n\tpossibleMoves = currentState->PrepareMovesForTurn();\r\n\tEndOfGame::CheckType_t result = endOfGame->CheckStartOfTurn(currentState, !possibleMoves->empty());\r\n\tif (result != EndOfGame::None)\r\n\t{\r\n\t\tProcessEndOfGame(result);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (currentState->currentPlayer->type != Player::Local)\r\n\t{\r\n\t\tif (currentState->currentPlayer->type == Player::AI)\r\n\t\t{\r\n\t\t\t/* todo: implement this\r\n\t\t\tsetTimeout(function() {\r\n\t\t\t\tconsole.time('ai');\r\n\t\t\t\tvar move = game.state.currentPlayer.AI.selectMove();\r\n\t\t\t\tconsole.timeEnd('ai');\r\n\t\t\t\tgame.performMove(move);\r\n\t\t\t}, 1);*/\r\n\t\t}\r\n#ifdef EMSCRIPTEN\r\n\t\t//$('#wait').show();\r\n\t\t// todo: implement this\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//$('#wait').hide();\r\n\t\t// todo: implement this\r\n#endif\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nGame::MoveResult_t Game::PerformMove(Move *move)\r\n{\r\n\tGameState *subsequentState = move->Perform(true);\r\n\tif (subsequentState != 0)\r\n\t{\r\n\t\tLogMove(currentState->currentPlayer, move);\r\n\t\tif (EndTurn(subsequentState, move))\r\n\t\t\treturn MoveComplete;\r\n\t\telse\r\n\t\t\treturn GameComplete;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn MoveError;\r\n\t}\r\n}\r\n\r\nbool Game::EndTurn(GameState *newState, Move *move)\r\n{\r\n\tEndOfGame::CheckType_t result = endOfGame->CheckEndOfTurn(currentState, move);\r\n\tClearPossibleMoves();\r\n\tdelete currentState;\r\n\r\n\tif (result != EndOfGame::None) {\r\n\t\tProcessEndOfGame(result);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tcurrentState = newState;\r\n\treturn StartNextTurn();\r\n}\r\n\r\n\r\nvoid Game::ProcessEndOfGame(EndOfGame::CheckType_t result)\r\n{\r\n\tswitch (result)\r\n\t{\r\n\tcase EndOfGame::Win:\r\n\t\tEndGame(currentState->currentPlayer);\r\n\t\tbreak;\r\n\tcase EndOfGame::Draw:\r\n\t\tEndGame(0);\r\n\t\tbreak;\r\n\tcase EndOfGame::Lose:\r\n\t\tif (players.size() == 2)\r\n\t\t{\r\n\t\t\tPlayer *other = players.front();\r\n\t\t\tif (other == currentState->currentPlayer)\r\n\t\t\t\tother = players.back();\r\n\t\t\tEndGame(other);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// the current player should be removed from the game. If none remain, game is drawn. If one remains, they win. Otherwise, it continues.\r\n\t\t\t// todo: implement this, somehow\r\n\t\t\tReportError(\"Unfortunately, chessmaker can't (yet) handle a player losing in a game that doesn't have two players.\\n\");\r\n\t\t}\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\nvoid Game::EndGame(Player *victor)\r\n{\r\n\tchar text[PLAYER_NAME_LENGTH + 32];\r\n\tif (victor == 0)\r\n\t\tsprintf(text, \"Game finished, stalemate\\n\");\r\n\telse\r\n\t\tsprintf(text, \"Game finished, %s wins\\n\", victor->GetName());\r\n\r\n#ifdef CONSOLE\r\n\tprintf(text);\r\n#endif\r\n#ifdef EMSCRIPTEN\r\n\t// todo: implement this\r\n\t//$('#nextMove').text(text);\r\n\t//$('#wait').hide();\r\n#endif\r\n}\r\n\r\nvoid Game::LogMove(Player *player, Move *move)\r\n{\r\n#ifdef CONSOLE\r\n\tprintf(\"%s\\n\", move->GetNotation());\r\n#endif\r\n#ifdef EMSCRIPTEN\r\n\t/*\r\n\tvar historyDiv = $('#moveHistory');\r\n\r\n    $('<div/>', {\r\n        class: 'move ' + player.name,\r\n        number: move.moveNumber,\r\n        html: move.notation\r\n    }).appendTo(historyDiv);\r\n\r\n    historyDiv.get(0).scrollTop = historyDiv.get(0).scrollHeight;\r\n\t*/\r\n\t// todo: implement this\r\n#endif\r\n}\r\n\r\nvoid Game::ClearPossibleMoves()\r\n{\r\n\tif (possibleMoves == 0)\r\n\t\treturn;\r\n\r\n\twhile (!possibleMoves->empty())\r\n\t\tdelete possibleMoves->front(), possibleMoves->pop_front();\r\n\tdelete possibleMoves;\r\n\tpossibleMoves = 0;\r\n}","#include \"rapidxml\\rapidxml.hpp\"\r\n#include \"rapidxml\\rapidxml_print.hpp\"\r\n\r\n#include <stdio.h>\r\n#include <utility>\r\n\r\n#include \"GameParser.h\"\r\n#include \"Board.h\"\r\n#include \"Cell.h\"\r\n#include \"Distance.h\"\r\n#include \"EndOfGame.h\"\r\n#include \"Game.h\"\r\n#include \"GameState.h\"\r\n#include \"MoveConditions.h\"\r\n#include \"MoveDefinition.h\"\r\n#include \"Piece.h\"\r\n#include \"PieceType.h\"\r\n#include \"Player.h\"\r\n#include \"StateConditions.h\"\r\n#include \"TurnOrder.h\"\r\n\r\nusing namespace rapidxml;\r\n\r\n#ifdef NO_SVG\r\nGame* GameParser::Parse(char *definition)\r\n#else\r\nGame* GameParser::Parse(char *definition, std::string *svgOutput)\r\n#endif\r\n{\r\n\txml_document<> doc;\r\n\tdoc.parse<0>(definition); // 0 means default parse flags\r\n\r\n\tgame = new Game();\r\n\tgame->board = new Board(game);\r\n\tgame->holdCapturedPieces = false;\r\n\r\n\tmaxDirection = FIRST_ABSOLUTE_DIRECTION >> 1;\r\n\tallDirections = 0;\r\n\tdirectionLookups.clear();\r\n\r\n\txml_node<> *node = doc.first_node()->first_node(\"board\");\r\n\tif (node == 0)\r\n\t{\r\n\t\tReportError(\"Can't find \\\"board\\\" node in game definition\\n\");\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n#ifdef NO_SVG\r\n\tif (!ParseCells(game->board, node))\r\n#else\r\n\txml_document<char> svgDoc;\r\n\tif (!ParseCellsAndGenerateSVG(game->board, node, &svgDoc))\r\n#endif\r\n\t{\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tnode = node->next_sibling(\"dirs\");\r\n\tif (node == 0)\r\n\t{\r\n\t\tReportError(\"Can't find \\\"dirs\\\" node in game definition\\n\");\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\tif (!ParseDirections(game->board, node))\r\n\t{\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tnode = node->next_sibling(\"pieces\");\r\n\tif (node == 0)\r\n\t{\r\n\t\tReportError(\"Can't find \\\"pieces\\\" node in game definition\\n\");\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\r\n#ifdef NO_SVG\r\n\tif (!ParsePieceTypes(node))\r\n#else\r\n\txml_node<> *defsNodes = svgDoc.first_node()->first_node(\"defs\");\r\n\tif (!ParsePieceTypes(node, defsNodes))\r\n#endif\r\n\t{\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tnode = node->next_sibling(\"setup\");\r\n\tif (node == 0)\r\n\t{\r\n\t\tReportError(\"Can't find \\\"setup\\\" node in game definition\\n\");\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\r\n#ifdef NO_SVG\r\n\tif (!ParsePlayers(node))\r\n#else\r\n\tif (!ParsePlayers(node, &svgDoc))\r\n#endif\r\n\t{\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tnode = node->next_sibling(\"rules\");\r\n\tif (node == 0)\r\n\t{\r\n\t\tReportError(\"Can't find \\\"rules\\\" node in game definition\\n\");\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\tif (!ParseRules(node))\r\n\t{\r\n\t\tdelete game;\r\n\t\treturn 0;\r\n\t}\r\n\r\n#ifndef NO_SVG\r\n\t// write svgDoc into svgOutput\r\n\tprint(std::back_inserter(*svgOutput), svgDoc, print_no_indenting);\r\n#endif\r\n\r\n\treturn game;\r\n}\r\n\r\n\r\nstruct TempCellLink\r\n{\r\npublic:\r\n\tTempCellLink(Cell *c, unsigned int d, char *r)\r\n\t{\r\n\t\tfromCell = c;\r\n\t\tdirection = d;\r\n\t\tdestinationCellRef = r;\r\n\t}\r\n\r\n\tCell *fromCell;\r\n\tunsigned int direction;\r\n\tchar* destinationCellRef;\r\n};\r\n\r\n\r\n#ifdef NO_SVG\r\nbool GameParser::ParseCells(Board *board, xml_node<> *boardNode)\r\n#else\r\nbool GameParser::ParseCellsAndGenerateSVG(Board *board, xml_node<> *boardNode, xml_document<> *svgDoc)\r\n#endif\r\n{\r\n#ifndef NO_SVG\r\n\t// create SVG root node\r\n\txml_node<> *svgRoot = svgDoc->allocate_node(node_element, \"svg\");\r\n\tsvgDoc->append_node(svgRoot);\r\n\t\r\n\txml_attribute<> *svgAttr = svgDoc->allocate_attribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\r\n\tsvgRoot->append_attribute(svgAttr);\r\n\r\n\tsvgAttr = svgDoc->allocate_attribute(\"id\", \"render\");\r\n\tsvgRoot->append_attribute(svgAttr);\r\n\r\n\tsvgAttr = boardNode->first_attribute(\"viewBox\");\r\n\tchar *value = svgDoc->allocate_string(svgAttr->value());\r\n\r\n\tsvgAttr = svgDoc->allocate_attribute(\"viewBox\", value);\r\n\tsvgRoot->append_attribute(svgAttr);\r\n\r\n\txml_node<> *svgNode = svgDoc->allocate_node(node_element, \"defs\");\r\n\tsvgRoot->append_node(svgNode);\r\n#endif\r\n\t// loop through all the cell nodes\r\n\tint iCell = 0;\r\n\txml_node<> *node = boardNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tif (strcmp(node->name(), \"cell\") == 0)\r\n\t\t\tiCell++;\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\tCell *cells = new Cell[iCell];\r\n\tiCell = 0;\r\n\r\n\tcellsByRef.clear();\r\n\tstd::list<TempCellLink> links;\r\n\r\n\tnode = boardNode->first_node();\r\n\txml_attribute<> *attr;\r\n\twhile (node != 0)\r\n\t{\r\n\t\tif (strcmp(node->name(), \"cell\") == 0)\r\n\t\t{\r\n\t\t\tattr = node->first_attribute(\"id\");\r\n\t\t\tCell *cell = &cells[iCell++];\r\n\r\n\t\t\tchar *ref = attr->value();\r\n\t\t\tstrcpy(cell->reference, ref);\r\n\t\t\tcellsByRef.insert(std::pair<char*, Cell*>(ref, cell));\r\n\t\t\t\r\n\t\t\t// parse cell links, and store them until all cells have been loaded, so we can resolve the names\r\n\t\t\txml_node<> *link = node->first_node(\"link\");\r\n\t\t\twhile (link != 0)\r\n\t\t\t{\r\n\t\t\t\tattr = link->first_attribute(\"dir\");\r\n\t\t\t\tchar *dir = attr->value();\r\n\r\n\t\t\t\tattr = link->first_attribute(\"to\");\r\n\t\t\t\tref = attr->value();\r\n\r\n\t\t\t\tlinks.push_back(TempCellLink(cell, LookupDirection(dir), ref));\r\n\r\n\t\t\t\tlink = link->next_sibling(\"link\");\r\n\t\t\t}\r\n\r\n#ifndef NO_SVG\r\n\t\t\t// load cell into SVG\r\n\t\t\txml_node<> *cellSVG = svgDoc->allocate_node(node_element, \"path\");\r\n\t\t\tsvgRoot->append_node(cellSVG);\r\n\r\n\t\t\tref = svgDoc->allocate_string(cell->reference);\r\n\t\t\tattr = svgDoc->allocate_attribute(\"id\", ref);\r\n\t\t\tcellSVG->append_attribute(attr);\r\n\r\n\t\t\t// determine css class\r\n\t\t\tchar *val = svgDoc->allocate_string(\"cell \", 28);\r\n\t\t\tattr = node->first_attribute(\"fill\");\r\n\t\t\tstrcat(val, attr->value());\r\n\r\n\t\t\tattr = node->first_attribute(\"border\");\r\n\t\t\tif (attr != 0)\r\n\t\t\t{\r\n\t\t\t\tstrcat(val, \" \");\r\n\t\t\t\tstrcat(val, attr->value());\r\n\t\t\t\tstrcat(val, \"Stroke\");\r\n\t\t\t}\r\n\t\t\tattr = svgDoc->allocate_attribute(\"class\", val);\r\n\t\t\tcellSVG->append_attribute(attr); // !\r\n\r\n\t\t\t// copy svg path as-is\r\n\t\t\tattr = node->first_attribute(\"path\");\r\n\t\t\tval = svgDoc->allocate_string(attr->value());\r\n\t\t\tattr = svgDoc->allocate_attribute(\"d\", val);\r\n\t\t\tcellSVG->append_attribute(attr); // !\r\n\r\n\t\t\t// save off each cell's position. Get the first two numbers from the path.\r\n\t\t\t// \"M100 60 m-20 -20\" should become \"100\" and \"60\"\r\n\t\t\tchar *firstSpace = strchr(val, ' ');\r\n\t\t\tcell->coordX = atoi(val + 1);\r\n\t\t\tcell->coordY = atoi(firstSpace + 1);\r\n#endif\r\n\t\t}\r\n#ifndef NO_SVG\r\n\t\telse if (strcmp(node->name(), \"line\") == 0)\r\n\t\t{\r\n\t\t\txml_node<> *lineSVG = svgDoc->allocate_node(node_element, \"line\");\r\n\t\t\tsvgRoot->append_node(lineSVG);\r\n\r\n\t\t\tattr = node->first_attribute(\"x1\");\r\n\t\t\tchar *val = svgDoc->allocate_string(attr->value());\r\n\t\t\tattr = svgDoc->allocate_attribute(\"x1\", val);\r\n\t\t\tlineSVG->append_attribute(attr);\r\n\r\n\t\t\tattr = node->first_attribute(\"x2\");\r\n\t\t\tval = svgDoc->allocate_string(attr->value());\r\n\t\t\tattr = svgDoc->allocate_attribute(\"x2\", val);\r\n\t\t\tlineSVG->append_attribute(attr);\r\n\r\n\t\t\tattr = node->first_attribute(\"y1\");\r\n\t\t\tval = svgDoc->allocate_string(attr->value());\r\n\t\t\tattr = svgDoc->allocate_attribute(\"y1\", val);\r\n\t\t\tlineSVG->append_attribute(attr);\r\n\r\n\t\t\tattr = node->first_attribute(\"y2\");\r\n\t\t\tval = svgDoc->allocate_string(attr->value());\r\n\t\t\tattr = svgDoc->allocate_attribute(\"y2\", val);\r\n\t\t\tlineSVG->append_attribute(attr);\r\n\r\n\t\t\tval = svgDoc->allocate_string(\"detail \", 20);\r\n\t\t\tattr = node->first_attribute(\"color\");\r\n\t\t\tstrcat(val, attr->value());\r\n\t\t\tstrcat(val, \"Stroke\");\r\n\t\t\tattr = svgDoc->allocate_attribute(\"class\", val);\r\n\t\t\tlineSVG->append_attribute(attr);\r\n        }\r\n#endif\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\tboard->cells = cells;\r\n\r\n\t// look through links, resolve the named cell for each, and then call cell.AddLink() for each.\r\n\twhile (!links.empty())\r\n\t{\r\n\t\tTempCellLink link = links.front();\r\n\t\tlinks.pop_front();\r\n\t\t\r\n\t\tauto it = cellsByRef.find(link.destinationCellRef);\r\n\t\tif (it == cellsByRef.end())\r\n\t\t{\r\n\t\t\tReportError(\"Cell %s has a link to an invalid destination cell: %s\\n\", link.fromCell->GetName(), link.destinationCellRef);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tCell *dest = it->second;\r\n\t\tlink.fromCell->AddLink(link.direction, dest);\r\n\t}\r\n\t\r\n\tboard->allAbsoluteDirections = allDirections;\r\n\treturn true;\r\n}\r\n\r\n\r\nbool GameParser::ParseDirections(Board *board, xml_node<> *dirsNode)\r\n{\r\n\tboard->firstRelativeDirection = maxDirection << 1;\r\n\r\n\txml_node<> *node = dirsNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tif (strcmp(node->name(), \"relative\") == 0)\r\n\t\t{\r\n\t\t\tchar *name = node->first_attribute(\"name\")->value();\r\n\t\t\tunsigned int id = LookupDirection(name); // this should always be new\r\n\t\t\trelativeDir_t values;\r\n\r\n\t\t\txml_node<> *child = node->first_node();\r\n\t\t\twhile (child != 0)\r\n\t\t\t{\r\n\t\t\t\tchar *from = child->first_attribute(\"from\")->value();\r\n\t\t\t\tchar *to = child->first_attribute(\"to\")->value();\r\n\t\t\t\t\r\n\t\t\t\tunsigned int fromID = LookupDirection(from); // this should never be new, and also < firstRelativeDirection\r\n\t\t\t\tunsigned int toID = LookupDirection(to); // this should never be new, and also < firstRelativeDirection\r\n\r\n\t\t\t\tvalues.insert(relativeDirValue_t(fromID, toID));\r\n\r\n\t\t\t\tchild = child->next_sibling();\r\n\t\t\t}\r\n\r\n\t\t\tboard->relativeDirections.insert(std::pair<unsigned int, relativeDir_t>(id, values));\r\n\t\t}\r\n\t\telse if (strcmp(node->name(), \"group\") == 0)\r\n\t\t{\r\n\t\t\tchar *name = node->first_attribute(\"name\")->value();\r\n\t\t\tint dirMask = 0;\r\n\r\n\t\t\txml_node<> *child = node->first_node();\r\n\t\t\twhile (child != 0)\r\n\t\t\t{\r\n\t\t\t\tchar *dir = child->first_attribute(\"dir\")->value();\r\n\t\t\t\tdirMask |= LookupDirection(dir); // this should never be new\r\n\r\n\t\t\t\tchild = child->next_sibling();\r\n\t\t\t}\r\n\r\n\t\t\tdirectionLookups.insert(dirLookupEntry_t(name, dirMask));\r\n\t\t}\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\tboard->lastRelativeDirection = maxDirection;\r\n\r\n\tif (board->firstRelativeDirection == board->lastRelativeDirection)\r\n\t\tboard->lastRelativeDirection = board->lastRelativeDirection >> 1; // there are none, so ensure they don't get looped over\r\n\r\n\treturn true;\r\n}\r\n\r\n#ifdef NO_SVG\r\nbool GameParser::ParsePieceTypes(xml_node<> *piecesNode)\r\n#else\r\nbool GameParser::ParsePieceTypes(xml_node<> *piecesNode, xml_node<> *svgDefsNode)\r\n#endif\r\n{\r\n\tpieceTypesByName.clear();\r\n\r\n\t// parse each piece type\r\n\txml_node<> *node = piecesNode->first_node(\"piece\");\r\n\twhile (node != 0)\r\n\t{\r\n\t\tPieceType *type = new PieceType();\r\n#ifdef NO_SVG\r\n\t\tchar *capturedAs = ParsePieceType(node, type);\r\n#else\r\n\t\tchar *capturedAs = ParsePieceType(node, svgDefsNode, type);\r\n#endif\r\n\r\n\t\tauto info = std::make_tuple(type, capturedAs);\r\n\t\tpieceTypesByName.insert(std::make_pair(type->name, info));\r\n\t\t\r\n\t\tnode = node->next_sibling(\"piece\");\r\n\t}\r\n\r\n\t// resolve references to other types, also populate piece type list\r\n\tfor (auto it = pieceTypesByName.begin(); it != pieceTypesByName.end(); it++)\r\n\t{\r\n\t\tPieceType *type = std::get<0>(it->second);\r\n\t\tgame->allPieceTypes.push_back(type);\r\n\r\n\t\tchar *capturedAs = std::get<1>(it->second);\r\n\t\tif (capturedAs != 0)\r\n\t\t{\r\n\t\t\tauto it2 = pieceTypesByName.find(capturedAs);\r\n\t\t\tif (it2 == pieceTypesByName.end())\r\n\t\t\t\tReportError(\"Piece type \\\"%s\\\" is set to be captured as a type that has not been defined: \\\"%s\\\"\\n\", type->GetName(), capturedAs);\r\n\t\t\telse\r\n\t\t\t\ttype->capturedAs = std::get<0>(it2->second); \r\n\t\t}\r\n\r\n\t\t/*\r\n\t\ttodo: resolve promotion opportunity options\r\n\t\tfor (var i = 0; i < type.promotionOpportunities.length; i++)\r\n\t\t\ttype.promotionOpportunities[i].resolveOptions(definitions);\r\n\t\t*/\r\n\r\n\t\t// resolve piece type pointers from the ReferencePiece move definition\r\n\t\twhile (!referencePieceTypeQueue.empty())\r\n\t\t{\r\n\t\t\tauto item = referencePieceTypeQueue.begin();\r\n\t\t\tReferencePiece *moveDef = item->first;\r\n\t\t\tchar *typeName = item->second;\r\n\r\n\t\t\tauto it = pieceTypesByName.find(typeName);\r\n\t\t\tPieceType *type = it == pieceTypesByName.end() ? 0 : std::get<0>(it->second);\r\n\t\t\tif (type != 0)\r\n\t\t\t\tmoveDef->otherPieceType = type;\r\n\r\n\t\t\tdelete[] typeName;\r\n\t\t\treferencePieceTypeQueue.erase(item);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n\r\n#ifdef NO_SVG\r\nchar *GameParser::ParsePieceType(xml_node<> *pieceNode, PieceType *type)\r\n#else\r\nchar *GameParser::ParsePieceType(xml_node<> *pieceNode, xml_node<> *svgDefsNode, PieceType *type)\r\n#endif\r\n{\r\n\txml_attribute<> *attr = pieceNode->first_attribute(\"name\");\r\n\tstrcpy(type->name, attr->value());\r\n\r\n\tattr = pieceNode->first_attribute(\"notation\");\r\n\tif (attr != 0)\r\n\t\tstrcpy(type->notation, attr->value());\r\n\r\n\tattr = pieceNode->first_attribute(\"value\");\r\n\tif (attr != 0)\r\n\t\ttype->value = atoi(attr->value());\r\n\r\n#ifndef NO_SVG\r\n\txml_document<> *svgDoc = svgDefsNode->document();\r\n#endif\r\n\tchar *capturedAs = 0;\r\n\r\n\txml_node<> *node = pieceNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tif (strcmp(node->name(), \"capturedAs\") == 0)\r\n\t\t{\r\n\t\t\tcapturedAs = node->value();\r\n\t\t}\r\n\t\telse if (strcmp(node->name(), \"moves\") == 0)\r\n\t\t{\r\n\t\t\txml_node<> *moveNode = node->first_node();\r\n\t\t\twhile (moveNode != 0)\r\n\t\t\t{\r\n\t\t\t\tMoveDefinition *move = ParseMove(moveNode, true);\r\n\t\t\t\tif (move != 0)\r\n\t\t\t\t\ttype->moves.push_back(move);\r\n\r\n\t\t\t\tmoveNode = moveNode->next_sibling();\r\n\t\t\t}\r\n\t\t}/*\r\n\t\telse if (strcmp(node->name(), \"special\") == 0)\r\n\t\t{\r\n\t\t\tvar specials = childNode.childNodes;\r\n\t\t\tfor (var j = 0; j<specials.length; j++)\r\n\t\t\t\tvar special = specials[j];\r\n\r\n\t\t\tif (special.tagName == \"royal\") // consider: while these properties should remain on pieces IN CODE (for game logic's sake) - shouldn't royalty in the DEFINITION be handled via victory conditions? lose when any/all pieces of given type are checkmated/captured/are in check/aren't in check? loading code could then apply royal / antiroyal values\r\n\t\t\t\ttype.royalty = PieceType.RoyalState.Royal;\r\n\t\t\telse if (special.tagName == \"anti_royal\")\r\n\t\t\t\ttype.royalty = PieceType.RoyalState.AntiRoyal;\r\n\t\t\telse if (special.tagName == \"immobilize\")\r\n\t\t\t\ttype.immobilizations.push(Immobilization.parse(this));\r\n\t\t\telse // consider: other special types: blocks (as per immobilize, but instead prevents pieces entering a square), kills (kills pieces in target squares without expending a move)\r\n\t\t\t\tthrow \"Unexpected node name in piece's \\\"special\\\" tag: \" + this.tagName;;\r\n\t\t}\r\n\t\telse if (strcmp(node->name(), \"promotion\") == 0)\r\n\t\t{\r\n\t\t\tvar promos = childNode.childNodes;\r\n\t\t\tfor (var j = 0; j<promos.length; j++)\r\n\t\t\t\ttype.promotionOpportunities.push(PromotionOpportunity.parse(promos[j]);\r\n\t\t}*/\r\n#ifndef NO_SVG\r\n\t\telse if (strcmp(node->name(), \"appearance\") == 0)\r\n\t\t{\r\n\t\t\tchar *playerName = node->first_attribute(\"player\")->value();\r\n\r\n\t\t\tchar *defID = svgDoc->allocate_string(type->name, TYPE_NAME_LENGTH + PLAYER_NAME_LENGTH + 1);\r\n\t\t\tstrcat(defID, \"_\");\r\n\t\t\tstrcat(defID, playerName);\r\n\r\n\t\t\txml_node<> *def = svgDoc->allocate_node(node_element, \"g\");\r\n\t\t\tsvgDefsNode->append_node(def);\r\n\r\n\t\t\tattr = svgDoc->allocate_attribute(\"class\", \"piece\");\r\n\t\t\tdef->append_attribute(attr);\r\n\t\t\t\r\n\t\t\tattr = svgDoc->allocate_attribute(\"id\", defID);\r\n\t\t\tdef->append_attribute(attr);\r\n\r\n\t\t\tattr = node->first_attribute(\"transform\");\r\n\t\t\tif (attr != 0)\r\n\t\t\t{\r\n\t\t\t\tchar *trans = attr->value();\r\n\t\t\t\tattr = svgDoc->allocate_attribute(\"transform\", trans);\r\n\t\t\t\tdef->append_attribute(attr);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// move the piece appearance SVG into the def node\r\n\t\t\txml_node<> *appNode = node->first_node();\r\n\t\t\twhile (appNode != 0)\r\n\t\t\t{\r\n\t\t\t\txml_node<> *moveNode = appNode;\r\n\t\t\t\tappNode = appNode->next_sibling();\r\n\t\t\t\tnode->remove_node(moveNode);\r\n\r\n\t\t\t\tdef->append_node(moveNode);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save off this appearance, to store later once players are imported\r\n\t\t\tpieceAppearances.push_back(std::make_tuple(type, playerName, defID));\r\n\t\t}\r\n#endif\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\treturn capturedAs;\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove(xml_node<char> *moveNode, bool isTopLevel)\r\n{\r\n\tif (strcmp(moveNode->name(), \"slide\") == 0)\r\n\t\treturn ParseMove_Slide(moveNode);\r\n\tif (strcmp(moveNode->name(), \"leap\") == 0)\r\n\t\treturn ParseMove_Leap(moveNode);\r\n\tif (strcmp(moveNode->name(), \"hop\") == 0)\r\n\t\treturn ParseMove_Hop(moveNode);\r\n\tif (strcmp(moveNode->name(), \"shoot\") == 0)\r\n\t\treturn ParseMove_Shoot(moveNode);\r\n\tif (strcmp(moveNode->name(), \"moveLike\") == 0)\r\n\t\treturn ParseMove_MoveLike(moveNode);\r\n\tif (isTopLevel)\r\n\t{\r\n\t\tif (strcmp(moveNode->name(), \"sequence\") == 0)\r\n\t\t\treturn ParseMove_Sequence(moveNode);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (strcmp(moveNode->name(), \"repeat\") == 0)\r\n\t\t\treturn ParseMove_Repeat(moveNode);\r\n\t\tif (strcmp(moveNode->name(), \"whenPossible\") == 0)\r\n\t\t\treturn ParseMove_WhenPossible(moveNode);\r\n\t\tif (strcmp(moveNode->name(), \"referencePiece\") == 0)\r\n\t\t\treturn ParseMove_ReferencePiece(moveNode);\r\n\t}\r\n\r\n\tReportError(\"Got a move with an unexpected type: %s\\n\", moveNode->name());\r\n\treturn 0;\r\n}\r\n\r\nMoveDefinition *GameParser::ParseMove_Slide(xml_node<char> *moveNode)\r\n{\r\n\tMoveConditionGroup *conditions = ParseMoveConditions(moveNode->first_node(\"conditions\"), Condition::And);\r\n\r\n\txml_attribute<> *attr = moveNode->first_attribute(\"piece\");\r\n\tconst char *pieceRef = attr == 0 ? \"self\" : attr->value();\r\n\r\n\tunsigned int dir = LookupDirection(moveNode->first_attribute(\"dir\")->value());\r\n\r\n\tDistance *dist = ParseDistance(moveNode->first_attribute(\"dist\")->value());\r\n\r\n\tattr = moveNode->first_attribute(\"distMax\");\r\n\tDistance *distMax = attr == 0 ? 0 : ParseDistance(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"when\");\r\n\tMoveDefinition::When_t when = attr == 0 ? MoveDefinition::Any : ParseWhen(attr->value());\r\n\r\n\treturn new Slide(pieceRef, conditions, when, dir, dist, distMax);\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_Leap(xml_node<char> *moveNode)\r\n{\r\n\tMoveConditionGroup *conditions = ParseMoveConditions(moveNode->first_node(\"conditions\"), Condition::And);\r\n\r\n\txml_attribute<> *attr = moveNode->first_attribute(\"piece\");\r\n\tconst char *pieceRef = attr == 0 ? \"self\" : attr->value();\r\n\r\n\tunsigned int dir = LookupDirection(moveNode->first_attribute(\"dir\")->value());\r\n\r\n\tDistance *dist = ParseDistance(moveNode->first_attribute(\"dist\")->value());\r\n\r\n\tattr = moveNode->first_attribute(\"distMax\");\r\n\tDistance *distMax = attr == 0 ? 0 : ParseDistance(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"secondDist\");\r\n\tDistance *secondDist = attr == 0 ? &Distance::Zero : ParseDistance(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"secondDir\");\r\n\tunsigned int secondDir = attr == 0 ? 0 : LookupDirection(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"when\");\r\n\tMoveDefinition::When_t when = attr == 0 ? MoveDefinition::Any : ParseWhen(attr->value());\r\n\r\n\treturn new Leap(pieceRef, conditions, when, dir, dist, distMax, secondDir, secondDist);\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_Hop(xml_node<char> *moveNode)\r\n{\r\n\tMoveConditionGroup *conditions = ParseMoveConditions(moveNode->first_node(\"conditions\"), Condition::And);\r\n\r\n\txml_attribute<> *attr = moveNode->first_attribute(\"piece\");\r\n\tconst char *pieceRef = attr == 0 ? \"self\" : attr->value();\r\n\r\n\tunsigned int dir = LookupDirection(moveNode->first_attribute(\"dir\")->value());\r\n\r\n\tDistance *distToHurdle = ParseDistance(moveNode->first_attribute(\"distToHurdle\")->value());\r\n\r\n\tattr = moveNode->first_attribute(\"distToHurdleMax\");\r\n\tDistance *distToHurdleMax = attr == 0 ? 0 : ParseDistance(attr->value());\r\n\r\n\tDistance *distAfterHurdle = ParseDistance(moveNode->first_attribute(\"distAfterHurdle\")->value());\r\n\r\n\tattr = moveNode->first_attribute(\"distAfterHurdleMax\");\r\n\tDistance *distAfterHurdleMax = attr == 0 ? 0 : ParseDistance(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"when\");\r\n\tMoveDefinition::When_t when = attr == 0 ? MoveDefinition::Any : ParseWhen(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"captureHurdle\");\r\n\tbool captureHurdle = attr == 0 || (strcmp(attr->value(), \"true\") == 0);\r\n\r\n\treturn new Hop(pieceRef, conditions, when, dir, distToHurdle, distToHurdleMax, distAfterHurdle, distAfterHurdleMax, captureHurdle);\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_Shoot(xml_node<char> *moveNode)\r\n{\r\n\tMoveConditionGroup *conditions = ParseMoveConditions(moveNode->first_node(\"conditions\"), Condition::And);\r\n\r\n\txml_attribute<> *attr = moveNode->first_attribute(\"piece\");\r\n\tconst char *pieceRef = attr == 0 ? \"self\" : attr->value();\r\n\r\n\tunsigned int dir = LookupDirection(moveNode->first_attribute(\"dir\")->value());\r\n\r\n\tDistance *dist = ParseDistance(moveNode->first_attribute(\"dist\")->value());\r\n\r\n\tattr = moveNode->first_attribute(\"distMax\");\r\n\tDistance *distMax = attr == 0 ? 0 : ParseDistance(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"secondDist\");\r\n\tDistance *secondDist = attr == 0 ? &Distance::Zero : ParseDistance(attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"secondDir\");\r\n\tunsigned int secondDir = attr == 0 ? 0 : LookupDirection(attr->value());\r\n\r\n\treturn new Shoot(pieceRef, conditions, MoveDefinition::Capturing, dir, dist, distMax, secondDir, secondDist);\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_MoveLike(xml_node<char> *moveNode)\r\n{\r\n\tMoveConditionGroup *conditions = ParseMoveConditions(moveNode->first_node(\"conditions\"), Condition::And);\r\n\r\n\tconst char *pieceRef = moveNode->first_attribute(\"other\")->value();\r\n\t\r\n\txml_attribute<> *attr = moveNode->first_attribute(\"when\");\r\n\tMoveDefinition::When_t when = attr == 0 ? MoveDefinition::Any : ParseWhen(attr->value());\r\n\t\r\n\treturn new MoveLike(pieceRef, conditions, when);\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_Sequence(xml_node<char> *moveNode)\r\n{\r\n\tSequence *move = new Sequence();\r\n\r\n\txml_node<> *node = moveNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tMoveDefinition *child = ParseMove(node, false);\r\n\t\tmove->contents.push_back(child);\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\treturn move;\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_Repeat(xml_node<char> *moveNode)\r\n{\r\n\tint min = atoi(moveNode->first_attribute(\"min\")->value());\r\n\tint max = atoi(moveNode->first_attribute(\"max\")->value());\r\n\r\n\tRepeat *move = new Repeat(min, max);\r\n\r\n\txml_node<> *node = moveNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tMoveDefinition *child = ParseMove(node, false);\r\n\t\tmove->contents.push_back(child);\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\treturn move;\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_WhenPossible(xml_node<char> *moveNode)\r\n{\r\n\tWhenPossible *move = new WhenPossible();\r\n\r\n\txml_node<> *node = moveNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tMoveDefinition *child = ParseMove(node, false);\r\n\t\tmove->contents.push_back(child);\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\treturn move;\r\n}\r\n\r\n\r\nMoveDefinition *GameParser::ParseMove_ReferencePiece(xml_node<char> *moveNode)\r\n{\r\n\txml_attribute<> *attr = moveNode->first_attribute(\"name\");\r\n\tchar *name = attr == 0 ? 0 : attr->value();\r\n\r\n\tattr = moveNode->first_attribute(\"type\");\r\n\tchar *typeName = attr == 0 ? 0 : attr->value();\r\n\r\n\tattr = moveNode->first_attribute(\"owner\");\r\n\tPlayer::Relationship_t relat = ParseRelationship(attr == 0 ? 0 : attr->value());\r\n\r\n\tattr = moveNode->first_attribute(\"dir\");\r\n\tunsigned int dir = attr == 0 ? 0 : LookupDirection(attr->value());\r\n\r\n\tmoveNode->first_attribute(\"dist\");\r\n\tDistance *dist = attr == 0 ? 0 : ParseDistance(attr->value());\r\n\r\n\tReferencePiece *moveDef = new ReferencePiece(name, 0, relat, dir, dist);\r\n\r\n\tif (typeName != 0)\r\n\t{\r\n\t\t// queue up setting the OtherPieceType of this moveDef once all the piece types have been loaded. Set it by typeName.\r\n\t\tchar *typeNameCopy = new char[TYPE_NAME_LENGTH];\r\n\t\tstrcpy(typeNameCopy, typeName);\r\n\t\treferencePieceTypeQueue.insert(std::make_pair(moveDef, typeNameCopy));\r\n\t}\r\n\r\n\treturn moveDef;\r\n}\r\n\r\n\r\nMoveConditionGroup *GameParser::ParseMoveConditions(xml_node<char> *node, Condition::GroupType_t type)\r\n{\r\n\tif (node == 0)\r\n\t\treturn 0;\r\n\r\n\tMoveConditionGroup *conditions = new MoveConditionGroup(type);\r\n\t\r\n\txml_node<> *child = node->first_node();\r\n\r\n\twhile (child != 0)\r\n\t{\r\n\t\tif (strcmp(child->name(), \"and\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseMoveConditions(child, Condition::And));\r\n\t\telse if (strcmp(child->name(), \"or\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseMoveConditions(child, Condition::Or));\r\n\t\telse if (strcmp(child->name(), \"nand\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseMoveConditions(child, Condition::Nand));\r\n\t\telse if (strcmp(child->name(), \"nor\") == 0 || strcmp(child->name(), \"not\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseMoveConditions(child, Condition::Nor));\r\n\t\telse if (strcmp(child->name(), \"xor\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseMoveConditions(child, Condition::Xor));\r\n\t\telse if (strcmp(child->name(), \"type\") == 0)\r\n\t\t{\r\n\t\t\tconst char *of = child->first_attribute(\"of\")->value();\r\n\t\t\tauto it = pieceTypesByName.find(child->value());\r\n\t\t\tPieceType *type = it == pieceTypesByName.end() ? 0 : std::get<0>(it->second);\r\n\t\t\tconditions->elements.push_back(new MoveCondition_Type(of, type));\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"owner\") == 0)\r\n\t\t{\r\n\t\t\tconst char *of = child->first_attribute(\"of\")->value();\r\n\t\t\tPlayer::Relationship_t relationship = ParseRelationship(child->value());\r\n\t\t\tconditions->elements.push_back(new MoveCondition_Owner(of, relationship));\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"moveNumber\") == 0)\r\n\t\t{\r\n\t\t\txml_attribute<> *attr = child->first_attribute(\"of\");\r\n\t\t\tconst char *of = attr == 0 ? \"self\" : attr->value();\r\n\t\t\tint number = atoi(child->value());\r\n\t\t\tCondition::NumericComparison_t comparison = ParseNumericComparison(child->first_attribute(\"comparison\")->value());\r\n\t\t\tconditions->elements.push_back(new MoveCondition_MoveNumber(of, number, comparison));\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"maxDist\") == 0)\r\n\t\t{\r\n\t\t\txml_attribute<> *attr = child->first_attribute(\"from\"); // not present in the schema\r\n\t\t\tconst char *from = attr == 0 ? \"self\" : attr->value();\r\n\t\t\tunsigned int dir = LookupDirection(child->first_attribute(\"dir\")->value());\r\n\t\t\tint number = atoi(child->value());\r\n\t\t\tCondition::NumericComparison_t comparison = ParseNumericComparison(child->first_attribute(\"comparison\")->value());\r\n\t\t\tconditions->elements.push_back(new MoveCondition_MaxDist(from, dir, number, comparison));\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"turnsSinceLastMove\") == 0)\r\n\t\t{\r\n\t\t\txml_attribute<> *attr = child->first_attribute(\"of\");\r\n\t\t\tconst char *of = attr == 0 ? \"self\" : attr->value();\r\n\t\t\tint number = atoi(child->value());\r\n\t\t\tCondition::NumericComparison_t comparison = ParseNumericComparison(child->first_attribute(\"comparison\")->value());\r\n\t\t\tconditions->elements.push_back(new MoveCondition_TurnsSinceLastMove(of, number, comparison));\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"threatened\") == 0)\r\n\t\t{\r\n\t\t\tbool value = strcmp(child->value(), \"true\") == 0;\r\n\t\t\tconst char *partOfMove = child->first_attribute(\"where\")->value();\r\n\t\t\tbool start = strcmp(partOfMove, \"end\") != 0;\r\n\t\t\tbool end = strcmp(partOfMove, \"start\") != 0;\r\n\t\t\tconditions->elements.push_back(new MoveCondition_Threatened(start, end, value));\r\n\t\t}\r\n\t\t/*else if (strcmp(child->name(), \"num_pieces_in_range\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"move_causes_check\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"move_causes_checkmate\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"checkmate\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"pieces_threatened\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"repeated_check\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"no_moves_possible\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"repetition_of_position\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"turns_since_last_capture\") == 0)\r\n\t\t{\r\n\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"turns_since_last_move\") == 0)\r\n\t\t{\r\n\r\n\t\t}*/\r\n\t\telse\r\n\t\t\tReportError(\"Unexpected move condition type: %s\\n\", child->name());\r\n\r\n\t\tchild = child->next_sibling();\r\n\t}\r\n\r\n\treturn conditions;\r\n}\r\n\r\n\r\nStateConditionGroup *GameParser::ParseStateConditions(xml_node<char> *node, Condition::GroupType_t type)\r\n{\r\n\tif (node == 0)\r\n\t\treturn 0;\r\n\r\n\r\n\tStateConditionGroup *conditions = new StateConditionGroup(type);\r\n\r\n\txml_node<> *child = node->first_node();\r\n\r\n\twhile (child != 0)\r\n\t{\r\n\t\tif (strcmp(child->name(), \"and\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseStateConditions(child, Condition::And));\r\n\t\telse if (strcmp(child->name(), \"or\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseStateConditions(child, Condition::Or));\r\n\t\telse if (strcmp(child->name(), \"nand\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseStateConditions(child, Condition::Nand));\r\n\t\telse if (strcmp(child->name(), \"nor\") == 0 || strcmp(child->name(), \"not\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseStateConditions(child, Condition::Nor));\r\n\t\telse if (strcmp(child->name(), \"xor\") == 0)\r\n\t\t\tconditions->elements.push_back(ParseStateConditions(child, Condition::Xor));\r\n\t\telse if (strcmp(child->name(), \"cannotMove\") == 0)\r\n\t\t{\r\n\t\t\tconditions->elements.push_back(new StateCondition_CannotMove());\r\n\t\t}\r\n\t\telse if (strcmp(child->name(), \"threatened\") == 0)\r\n\t\t{\r\n\t\t\tauto it = pieceTypesByName.find(child->value());\r\n\t\t\tPieceType *type = it == pieceTypesByName.end() ? 0 : std::get<0>(it->second);\r\n\t\t\tconditions->elements.push_back(new StateCondition_Threatened(type));\r\n\t\t}\r\n\t\telse\r\n\t\t\tReportError(\"Unexpected state condition type: %s\\n\", child->name());\r\n\r\n\t\tchild = child->next_sibling();\r\n\t}\r\n\r\n\treturn conditions;\r\n}\r\n\r\n\r\nCondition::NumericComparison_t GameParser::ParseNumericComparison(char *value)\r\n{\r\n\tif (strcmp(value, \"equals\") == 0)\r\n\t\treturn Condition::Equals;\r\n\tif (strcmp(value, \"less than\") == 0)\r\n\t\treturn Condition::LessThan;\r\n\tif (strcmp(value, \"less than or equals\") == 0)\r\n\t\treturn Condition::LessThanOrEquals;\r\n\tif (strcmp(value, \"greater than\") == 0)\r\n\t\treturn Condition::GreaterThan;\r\n\tif (strcmp(value, \"greater than or equals\") == 0)\r\n\t\treturn Condition::GreaterThanOrEquals;\r\n\t\r\n\tReportError(\"Unexpected numeric comparison type: %s\\n\", value);\r\n\treturn Condition::Equals;\r\n}\r\n\r\n\r\nDistance *GameParser::ParseDistance(char *val)\r\n{\r\n\tif (val == 0)\r\n\t\treturn 0;\r\n\r\n\tif (strcmp(val, \"any\") == 0)\r\n\t\treturn &Distance::Any;\r\n\r\n\tint len = strlen(val);\r\n\tif (len >= 3 && val[0] == 'm' && val[1] == 'a' && val[2] == 'x')\r\n\t\treturn new Distance(Distance::Max, atoi(val+3));\r\n\telse if (len >= 4 && val[0] == 'p' && val[1] == 'r' && val[2] == 'e' && val[3] == 'v')\r\n\t\treturn new Distance(Distance::Prev, atoi(val + 4));\r\n\telse\r\n\t\treturn new Distance(Distance::None, atoi(val));\r\n}\r\n\r\n\r\nMoveDefinition::When_t GameParser::ParseWhen(char *val)\r\n{\r\n\tif (val == 0)\r\n\t\treturn MoveDefinition::Any;\r\n\r\n\tif (strcmp(val, \"any\") == 0)\r\n\t\treturn MoveDefinition::Any;\r\n\tif (strcmp(val, \"move\") == 0)\r\n\t\treturn MoveDefinition::Moving;\r\n\tif (strcmp(val, \"capture\") == 0)\r\n\t\treturn MoveDefinition::Capturing;\r\n\r\n\tReportError(\"Unexpected 'when' value: %s\\n\", val);\r\n\treturn MoveDefinition::Any;\r\n}\r\n\r\n\r\nPlayer::Relationship_t GameParser::ParseRelationship(char *val)\r\n{\r\n\tif (val == 0)\r\n\t\treturn Player::Any;\r\n\r\n\tif (strcmp(val, \"self\") == 0)\r\n\t\treturn Player::Self;\r\n\tif (strcmp(val, \"enemy\") == 0)\r\n\t\treturn Player::Enemy;\r\n\tif (strcmp(val, \"ally\") == 0)\r\n\t\treturn Player::Ally;\r\n\r\n\tReportError(\"Unexpected relationship type: %s\\n\", val);\r\n\treturn Player::Any;\r\n}\r\n\r\n#ifdef NO_SVG\r\nbool GameParser::ParsePlayers(xml_node<> *setupNode)\r\n#else\r\nbool GameParser::ParsePlayers(xml_node<> *setupNode, xml_document<> *svgDoc)\r\n#endif\r\n{\r\n#ifndef NO_SVG\r\n\txml_node<> *svgRoot = svgDoc->first_node();\r\n#endif\r\n\r\n\txml_node<> *playerNode = setupNode->first_node();\r\n\twhile (playerNode != 0)\r\n\t{\r\n\t\tchar *playerName = playerNode->first_attribute(\"name\")->value();\r\n\t\tchar *forwardDir = playerNode->first_attribute(\"forwardDirection\")->value();\r\n\r\n\t\tPlayer *player = new Player(game, playerName, LookupDirection(forwardDir));\r\n\t\tgame->players.push_back(player);\r\n\r\n#ifndef NO_SVG\r\n\t\t// link piece appearances up to actual player now that this exists\r\n\t\tfor (auto it = pieceAppearances.begin(); it != pieceAppearances.end(); it++)\r\n\t\t{\r\n\t\t\tauto tuple = *it;\r\n\r\n\t\t\tif (strcmp(std::get<1>(tuple), playerName) != 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tPieceType *type = std::get<0>(tuple);\r\n\t\t\tchar *defID = std::get<2>(tuple);\r\n\r\n\t\t\tchar *defRef = new char[TYPE_NAME_LENGTH + PLAYER_NAME_LENGTH + 2];\r\n\t\t\tstrcpy(defRef, \"#\");\r\n\t\t\tstrcat(defRef, defID);\r\n\r\n\t\t\ttype->appearances.insert(std::make_pair(player->id, defRef));\r\n\r\n\t\t\t//pieceAppearances.erase(it++);\r\n\t\t}\r\n#endif\r\n\r\n\t\txml_node<> *pieceNode = playerNode->first_node();\r\n\t\twhile (pieceNode != 0)\r\n\t\t{\r\n\t\t\tchar *position = pieceNode->first_attribute(\"location\")->value();\r\n\r\n\t\t\tchar *typeName = pieceNode->first_attribute(\"type\")->value();\r\n\t\t\tauto it = pieceTypesByName.find(typeName);\r\n\t\t\tif (it == pieceTypesByName.end())\r\n\t\t\t{\r\n\t\t\t\tReportError(\"Unrecognized piece type: %s\\n\", typeName);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tPieceType *type = std::get<0>(it->second);\r\n\r\n\t\t\tif (strcmp(position, \"held\") == 0)\r\n\t\t\t{\r\n\t\t\t\tPiece *piece = new Piece(player, type, 0, Piece::Held, player);\r\n\t\t\t\tplayer->piecesHeld.insert(piece);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tauto it = cellsByRef.find(position);\r\n\t\t\t\tif (it == cellsByRef.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tReportError(\"Piece has unrecognised position: %s\\n\", position);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tCell *cell = it->second;\r\n\r\n\t\t\t\tPiece *piece = new Piece(player, type, cell, Piece::OnBoard, 0);\r\n\t\t\t\tplayer->piecesOnBoard.insert(piece);\r\n\r\n\t\t\t\tif (cell->piece == 0)\r\n\t\t\t\t\tcell->piece = piece;\r\n\t\t\t\telse\r\n\t\t\t\t\tReportError(\"Definition specified multiple pieces in cell %s - this is not allowed\\n\", cell->GetName());\r\n\r\n#ifndef NO_SVG\r\n\t\t\t\t// generate piece image\r\n\t\t\t\txml_node<> *image = svgDoc->allocate_node(node_element, \"use\");\r\n\r\n\t\t\t\tchar *val = svgDoc->allocate_string(0, 8);\r\n\t\t\t\tsprintf(val, \"p%d\", piece->uniqueID);\r\n\t\t\t\timage->append_attribute(svgDoc->allocate_attribute(\"id\", val));\r\n\r\n\t\t\t\tval = svgDoc->allocate_string(\"piece \", PLAYER_NAME_LENGTH + 6);\r\n\t\t\t\tstrcat(val, player->name);\r\n\t\t\t\timage->append_attribute(svgDoc->allocate_attribute(\"class\", val));\r\n\r\n\t\t\t\tval = svgDoc->allocate_string(0, 8);\r\n\t\t\t\tsprintf(val, \"%d\", cell->coordX);\r\n\t\t\t\timage->append_attribute(svgDoc->allocate_attribute(\"x\", val));\r\n\r\n\t\t\t\tval = svgDoc->allocate_string(0, 8);\r\n\t\t\t\tsprintf(val, \"%d\", cell->coordY);\r\n\t\t\t\timage->append_attribute(svgDoc->allocate_attribute(\"y\", val));\r\n\r\n\t\t\t\t// assign correct piece appearance to this element\r\n\t\t\t\tauto it2 = piece->pieceType->appearances.find(player->id);\r\n\t\t\t\tif (it2 == piece->pieceType->appearances.end())\r\n\t\t\t\t{\r\n\t\t\t\t\tReportError(\"Piece type \\\"%s\\\" has no appearance specified for player \\\"%s\\\"\\n\", piece->pieceType->GetName(), player->GetName());\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tval = svgDoc->allocate_string(it2->second, TYPE_NAME_LENGTH + PLAYER_NAME_LENGTH + 2);\r\n\t\t\t\timage->append_attribute(svgDoc->allocate_attribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\"));\r\n\t\t\t\timage->append_attribute(svgDoc->allocate_attribute(\"xlink:href\", val));\r\n\r\n\t\t\t\tsvgRoot->append_node(image);\r\n#endif\r\n\t\t\t}\r\n\r\n\t\t\tpieceNode = pieceNode->next_sibling();\r\n\t\t}\r\n\r\n\t\tplayerNode = playerNode->next_sibling();\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n\r\nbool GameParser::ParseRules(xml_node<> *rulesNode)\r\n{\r\n\txml_node<> *node = rulesNode->first_node(\"turnOrder\");\r\n\tTurnOrder *order = node == 0 ? TurnOrder::CreateDefault(game->players) : ParseTurnOrder(node);\r\n\r\n\tif (order == 0)\r\n\t\treturn false;\r\n\telse\r\n\t\tgame->turnOrder = order;\r\n\r\n\tnode = rulesNode->first_node(\"endOfGame\");\r\n\tEndOfGame *end = node == 0 ? EndOfGame::CreateDefault() : ParseEndOfGame(node);\r\n\r\n\tif (end == 0)\r\n\t{\r\n\t\tReportError(\"An error occurred parsing the EndOfGame\\n\");\r\n\t\treturn false;\r\n\t}\r\n\telse\r\n\t\tgame->endOfGame = end;\r\n\r\n\treturn true;\r\n}\r\n\r\nTurnOrder *GameParser::ParseTurnOrder(xml_node<> *node)\r\n{\r\n\tTurnOrder *turnOrder = new TurnOrder();\r\n\r\n\tif (!ParseTurnRepeat(turnOrder, node))\r\n\t{\r\n\t\tdelete turnOrder;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\treturn turnOrder;\r\n}\r\n\r\nbool GameParser::ParseTurnRepeat(TurnRepeat *repeat, xml_node<> *repeatNode)\r\n{\r\n\txml_node<> *node = repeatNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tif (strcmp(node->name(), \"turn\") == 0)\r\n\t\t{\r\n\t\t\tchar *playerName = node->first_attribute(\"player\")->value();\r\n\t\t\tPlayer *player = GetPlayerByName(playerName);\r\n\t\t\tif (player != 0)\r\n\t\t\t{\r\n\t\t\t\tTurnStep *step = new TurnStep(player);\r\n\t\t\t\trepeat->steps.push_back(step);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (strcmp(node->name(), \"repeat\") == 0)\r\n\t\t{\r\n\t\t\txml_attribute<> *attr = node->first_attribute(\"count\");\r\n\t\t\tint count = attr == 0 ? 0 : atoi(attr->value());\r\n\t\t\tTurnRepeat *child = new TurnRepeat(count);\r\n\t\t\trepeat->steps.push_back(child);\r\n\t\t\tif (!ParseTurnRepeat(child, node))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\telse\r\n\t\t\tReportError(\"Unexpected move node: %s\\n\", node->name());\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nPlayer *GameParser::GetPlayerByName(char *name)\r\n{\r\n\tfor (auto it = game->players.begin(); it != game->players.end(); it++)\r\n\t{\r\n\t\tPlayer *player = *it;\r\n\t\tif (strcmp(player->GetName(), name) == 0)\r\n\t\t\treturn player;\r\n\t}\r\n\r\n\tReportError(\"Attempted to look up invalid player name: %s\\n\", name);\r\n\treturn 0;\r\n}\r\n\r\nEndOfGame *GameParser::ParseEndOfGame(xml_node<> *rootNode)\r\n{\r\n\tEndOfGame *endOfGame = new EndOfGame();\r\n\r\n\txml_node<> *node = rootNode->first_node();\r\n\twhile (node != 0)\r\n\t{\r\n\t\tEndOfGame::CheckType_t checkType;\r\n\t\tif (strcmp(node->name(), \"win\") == 0)\r\n\t\t\tcheckType = EndOfGame::Win;\r\n\t\telse if (strcmp(node->name(), \"lose\") == 0)\r\n\t\t\tcheckType = EndOfGame::Lose;\r\n\t\telse if (strcmp(node->name(), \"draw\") == 0)\r\n\t\t\tcheckType = EndOfGame::Draw;\r\n\t\telse if (strcmp(node->name(), \"illegal\") == 0)\r\n\t\t{\r\n\t\t\tcheckType = EndOfGame::IllegalMove;\r\n\t\t\tendOfGame->illegalMovesSpecified = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tReportError(\"Unexpected end-of-game check type: %s\\n\", node->name());\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\txml_attribute<> *attr = node->first_attribute(\"when\");\r\n\t\tauto checkList = strcmp(attr->value(), \"startOfTurn\") == 0 ? &endOfGame->startOfTurnChecks : &endOfGame->endOfTurnChecks;\r\n\r\n\t\tStateConditionGroup *conditions = ParseStateConditions(node, Condition::And);\r\n\t\tcheckList->push_back(new EndOfGameCheck(checkType, conditions));\r\n\r\n\t\tnode = node->next_sibling();\r\n\t}\r\n\t\r\n\treturn endOfGame;\r\n}\r\n\r\nunsigned int GameParser::LookupDirection(char *dirName)\r\n{\r\n\tif (strcmp(dirName, \"forward\") == 0)\r\n\t\treturn DIRECTION_FORWARD;\r\n\telse if (strcmp(dirName, \"same\") == 0)\r\n\t\treturn DIRECTION_SAME;\r\n\r\n\tdirLookup_t::iterator it = directionLookups.find(dirName);\r\n\r\n\tif (it == directionLookups.end())\r\n\t{// a new direction, add it\r\n\t\tmaxDirection = maxDirection << 1;\r\n\t\tallDirections |= maxDirection;\r\n\t\tdirectionLookups.insert(dirLookupEntry_t(dirName, maxDirection));\r\n\r\n\t\treturn maxDirection;\r\n\t}\r\n\r\n\treturn it->second;\r\n}","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass Player;\r\n\r\n\r\nclass BaseTurnStep\r\n{\r\npublic:\r\n\tvirtual bool IsStep() = 0;\r\n\tvirtual ~BaseTurnStep() { };\r\nprotected:\r\n\tBaseTurnStep() { };\r\n};\r\n\r\n\r\nclass TurnStep : public BaseTurnStep\r\n{\r\npublic:\r\n\tTurnStep(Player *player) { this->player = player; }\r\n\tPlayer *GetPlayer() { return player; }\r\n\tvirtual bool IsStep() { return true; }\r\nprivate:\r\n\tPlayer *player;\r\n};\r\n\r\n\r\nclass TurnRepeat : public BaseTurnStep\r\n{\r\npublic:\r\n\tTurnRepeat(int count);\r\n\tvirtual ~TurnRepeat();\r\n\r\n\tvirtual bool IsStep() { return false; }\r\n\r\nprotected:\r\n\tTurnStep* GetNext(bool forwards);\r\n\tstd::list<BaseTurnStep*> steps;\r\n\r\nprivate:\r\n\ttypedef enum { AtStart, InMiddle, AtEnd } State_t;\r\n\r\n\tint currentIteration, maxRepeats;\r\n\tState_t state;\r\n\tstd::list<BaseTurnStep*>::iterator it;\r\n\r\n\tfriend class GameParser;\r\n\tfriend class TurnOrder;\r\n};\r\n\r\n\r\nclass TurnOrder : public TurnRepeat\r\n{\r\npublic:\r\n\tTurnOrder();\r\n\tvirtual ~TurnOrder();\r\n\r\n\tPlayer *GetNextPlayer();\r\n\tvoid StepBackward();\r\n\r\n\tstatic TurnOrder *CreateDefault(std::list<Player*> players);\r\n\r\nprivate:\r\n\tTurnStep *currentStep;\r\n\r\n\tfriend class GameParser;\r\n};","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"MoveDefinition.h\"\r\n#include \"Player.h\"\r\n\r\nclass Cell;\r\nclass GameState;\r\nclass Move;\r\nclass PieceType;\r\n\r\nclass Condition\r\n{\r\npublic:\r\n\ttypedef enum { Equals, LessThan, GreaterThan, LessThanOrEquals, GreaterThanOrEquals } NumericComparison_t;\r\n\ttypedef enum { And, Or, Nand, Nor, Xor } GroupType_t;\r\n\r\nprotected:\r\n\tbool ResolveComparison(NumericComparison_t type, int val1, int val2);\r\n};\r\n\r\n\r\nclass MoveCondition : public Condition\r\n{\r\npublic:\r\n\tvirtual ~MoveCondition() {}\r\n\tvirtual bool IsSatisfied(Move *move) = 0;\r\n};\r\n\r\n\r\nclass MoveConditionGroup : public MoveCondition\r\n{\r\npublic:\r\n\tMoveConditionGroup(GroupType_t type);\r\n\tvirtual ~MoveConditionGroup();\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tGroupType_t type;\r\n\tstd::list<MoveCondition*> elements;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass MoveCondition_Type : public MoveCondition\r\n{\r\npublic:\r\n\tMoveCondition_Type(const char *of, PieceType *type)\r\n\t{\r\n\t\tstrcpy(pieceRef, of);\r\n\t\tthis->type = type;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tchar pieceRef[PIECE_REF_LENGTH];\r\n\tPieceType *type;\r\n};\r\n\r\n\r\nclass MoveCondition_Owner : public MoveCondition\r\n{\r\npublic:\r\n\tMoveCondition_Owner(const char *of, Player::Relationship_t relationship)\r\n\t{\r\n\t\tstrcpy(pieceRef, of);\r\n\t\tthis->relationship = relationship;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tchar pieceRef[PIECE_REF_LENGTH];\r\n\tPlayer::Relationship_t relationship;\r\n};\r\n\r\n\r\nclass MoveCondition_MoveNumber : public MoveCondition\r\n{\r\npublic:\r\n\tMoveCondition_MoveNumber(const char *of, int number, NumericComparison_t comparison)\r\n\t{\r\n\t\tstrcpy(pieceRef, of);\r\n\t\tthis->number = number;\r\n\t\tthis->comparison = comparison;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tchar pieceRef[PIECE_REF_LENGTH];\r\n\tint number;\r\n\tMoveCondition::NumericComparison_t comparison;\r\n};\r\n\r\n\r\nclass MoveCondition_MaxDist : public MoveCondition\r\n{\r\npublic:\r\n\tMoveCondition_MaxDist(const char *from, unsigned int dir, int number, NumericComparison_t comparison)\r\n\t{\r\n\t\tstrcpy(pieceRef, from);\r\n\t\tthis->dir = dir;\r\n\t\tthis->number = number;\r\n\t\tthis->comparison = comparison;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tchar pieceRef[PIECE_REF_LENGTH];\r\n\tunsigned int dir;\r\n\tint number;\r\n\tMoveCondition::NumericComparison_t comparison;\r\n};\r\n\r\n\r\nclass MoveCondition_TurnsSinceLastMove : public MoveCondition\r\n{\r\npublic:\r\n\tMoveCondition_TurnsSinceLastMove(const char *of, int number, NumericComparison_t comparison)\r\n\t{\r\n\t\tstrcpy(pieceRef, of);\r\n\t\tthis->number = number;\r\n\t\tthis->comparison = comparison;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tchar pieceRef[PIECE_REF_LENGTH];\r\n\tint number;\r\n\tMoveCondition::NumericComparison_t comparison;\r\n};\r\n\r\n\r\nclass MoveCondition_Threatened : public MoveCondition\r\n{\r\npublic:\r\n\tMoveCondition_Threatened(bool start, bool end, bool value)\r\n\t{\r\n\t\tthis->start = start;\r\n\t\tthis->end = end;\r\n\t\tthis->value = value;\r\n\t}\r\n\r\n\tvirtual bool IsSatisfied(Move *move);\r\nprivate:\r\n\tbool CheckSatisfied(Move *move);\r\n\tstatic bool IsThreatened(GameState *state, Cell *position);\r\n\r\n\tbool start, end, value;\r\n\tstatic bool alreadyChecking;\r\n\r\n\tfriend class StateCondition_Threatened;\r\n};","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"Distance.h\"\r\n#include \"Move.h\"\r\n#include \"PieceType.h\"\r\n#include \"Player.h\"\r\n\r\nclass MoveConditionGroup;\r\nclass MoveStep;\r\nclass Piece;\r\n\r\n#define PIECE_REF_LENGTH 32\r\n\r\nclass MoveDefinition\r\n{\r\npublic:\r\n\ttypedef enum { Any, Moving, Capturing } When_t;\r\n\r\n\tMoveDefinition(const char *pieceRef, MoveConditionGroup *conditions, When_t when, unsigned int direction);\r\n\tvirtual ~MoveDefinition();\r\n\r\n\tvirtual std::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep) = 0;\r\nprotected:\r\n\tchar pieceRef[PIECE_REF_LENGTH];\r\n\tMoveConditionGroup *conditions;\r\n\tWhen_t when;\r\n\tunsigned int direction;\r\n\tbool moveSelf;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass Slide : public MoveDefinition\r\n{\r\npublic:\r\n\tSlide(const char *pieceRef, MoveConditionGroup *conditions, When_t when, unsigned int direction, Distance *distance, Distance *distanceMax)\r\n\t\t: MoveDefinition(pieceRef, conditions, when, direction)\r\n\t{\r\n\t\tthis->distance = distance; this->distanceMax = distanceMax;\r\n\t}\r\n\tvirtual ~Slide() { if (distance != &Distance::Any) delete distance; if (distanceMax != 0) delete distanceMax; }\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tDistance *distance;\r\n\tDistance *distanceMax;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass Leap : public MoveDefinition\r\n{\r\npublic:\r\n\tLeap(const char *pieceRef, MoveConditionGroup *conditions, When_t when, unsigned int direction, Distance *distance, Distance *distanceMax, unsigned int secondDir, Distance *secondDist)\r\n\t\t: MoveDefinition(pieceRef, conditions, when, direction)\r\n\t{\r\n\t\tthis->distance = distance; this->distanceMax = distanceMax;\r\n\t\tthis->secondDir = secondDir; this->secondDist = secondDist;\r\n\t}\r\n\tvirtual ~Leap() { if (distance != &Distance::Any) delete distance; if (distanceMax != 0) delete distanceMax; if (secondDist != &Distance::Any) delete secondDist; }\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tDistance *distance, *distanceMax;\r\n\tunsigned int secondDir;\r\n\tDistance *secondDist;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass Hop : public MoveDefinition\r\n{\r\npublic:\r\n\tHop(const char *pieceRef, MoveConditionGroup *conditions, When_t when, unsigned int direction, Distance *distToHurdle, Distance *distToHurdleMax, Distance *distAfterHurdle, Distance *distAfterHurdleMax, bool captureHurdle)\r\n\t\t: MoveDefinition(pieceRef, conditions, when, direction)\r\n\t{\r\n\t\tthis->distToHurdle = distToHurdle; this->distToHurdleMax = distToHurdleMax;\r\n\t\tthis->distAfterHurdle = distAfterHurdle; this->distAfterHurdleMax = distAfterHurdleMax;\r\n\t\tthis->captureHurdle = captureHurdle;\r\n\t}\r\n\tvirtual ~Hop() { if (distToHurdle != &Distance::Any) delete distToHurdle; if (distToHurdleMax != 0) delete distToHurdleMax; delete distAfterHurdle; if (distAfterHurdleMax != 0 && distAfterHurdleMax != &Distance::Any) delete distAfterHurdleMax; }\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tDistance *distToHurdle, *distToHurdleMax;\r\n\tDistance *distAfterHurdle, *distAfterHurdleMax;\r\n\tbool captureHurdle;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass Shoot : public MoveDefinition\r\n{\r\npublic:\r\n\tShoot(const char *pieceRef, MoveConditionGroup *conditions, When_t when, unsigned int direction, Distance *distance, Distance *distanceMax, unsigned int secondDir, Distance *secondDist)\r\n\t\t: MoveDefinition(pieceRef, conditions, when, direction)\r\n\t{\r\n\t\tthis->distance = distance; this->distanceMax = distanceMax;\r\n\t\tthis->secondDir = secondDir; this->secondDist = secondDist;\r\n\t}\r\n\tvirtual ~Shoot() { if (distance != &Distance::Any) delete distance; if (distanceMax != 0) delete distanceMax; if (secondDist != 0 && secondDist != &Distance::Any) delete secondDist; }\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tDistance *distance, *distanceMax;\r\n\tunsigned int secondDir;\r\n\tDistance *secondDist;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass MoveLike : public MoveDefinition\r\n{\r\npublic:\r\n\tMoveLike(const char *pieceRef, MoveConditionGroup *conditions, When_t when)\r\n\t\t: MoveDefinition(\"\", conditions, when, 0)\r\n\t{\r\n\t\tstrcpy(this->otherPieceRef, pieceRef);\r\n\t\tlikeTarget = strcmp(pieceRef, \"target\") == 0;\r\n\t}\r\n\tvirtual ~MoveLike() { }\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tstd::list<Move*> *AppendMoveLikeTarget(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\n\tstatic bool AllowMoveLikeTarget;\r\n\tbool likeTarget;\r\n\tchar otherPieceRef[PIECE_REF_LENGTH];\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass ReferencePiece : public MoveDefinition\r\n{\r\npublic:\r\n\tReferencePiece(const char *pieceRef, PieceType *type, Player::Relationship_t relationship, unsigned int dir, Distance *distance)\r\n\t\t: MoveDefinition(\"\", 0, Any, 0)\r\n\t{\r\n\t\tstrcpy(this->otherPieceRef, pieceRef);\r\n\t\tthis->relationship = relationship;\r\n\t\tthis->distance = distance;\r\n\t\tthis->otherPieceDirection = dir;\r\n\t}\r\n\tvirtual ~ReferencePiece() { if (distance != 0 && distance != &Distance::Any) delete distance; }\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tchar otherPieceRef[PIECE_REF_LENGTH];\r\n\tPieceType *otherPieceType;\r\n\tPlayer::Relationship_t relationship;\r\n\tDistance *distance;\r\n\tunsigned int otherPieceDirection;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass MoveGroup : public MoveDefinition\r\n{\r\npublic:\r\n\tMoveGroup(int minOccurs, int maxOccurs, bool stepOutIfFail)\r\n\t\t: MoveDefinition(\"\", 0, Any, 0)\r\n\t{\r\n\t\tthis->minOccurs = minOccurs;\r\n\t\tthis->maxOccurs = maxOccurs;\r\n\t\tthis->stepOutIfFail = stepOutIfFail;\r\n\t}\r\n\tvirtual ~MoveGroup()\r\n\t{\r\n\t\twhile (!contents.empty())\r\n\t\t\tdelete contents.front(), contents.pop_front();\r\n\t}\r\n\r\n\tstd::list<Move*> *DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep);\r\n\r\nprivate:\r\n\tint minOccurs, maxOccurs;\r\n\tbool stepOutIfFail;\r\n\r\n\tstd::list<MoveDefinition*> contents;\r\n\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass Sequence : public MoveGroup\r\n{\r\npublic:\r\n\tSequence()\r\n\t\t: MoveGroup(1, 1, false)\r\n\t{ }\r\n\tvirtual ~Sequence() { }\r\n\r\nprivate:\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass Repeat : public MoveGroup\r\n{\r\npublic:\r\n\tRepeat(int minOccurs, int maxOccurs)\r\n\t\t: MoveGroup(minOccurs, maxOccurs, false)\r\n\t{ }\r\n\tvirtual ~Repeat() { }\r\n\r\nprivate:\r\n\tfriend class GameParser;\r\n};\r\n\r\n\r\nclass WhenPossible : public MoveGroup\r\n{\r\npublic:\r\n\tWhenPossible()\r\n\t\t: MoveGroup(1, 1, true)\r\n\t{ }\r\n\tvirtual ~WhenPossible() { }\r\n\r\nprivate:\r\n\tfriend class GameParser;\r\n};","#ifndef RAPIDXML_HPP_INCLUDED\r\n#define RAPIDXML_HPP_INCLUDED\r\n\r\n#ifdef EMSCRIPTEN\r\n#define RAPIDXML_NO_EXCEPTIONS\r\n#endif\r\n\r\n// Copyright (C) 2006, 2009 Marcin Kalicinski\r\n// Version 1.13\r\n// Revision $DateTime: 2009/05/13 01:46:17 $\r\n//! \\file rapidxml.hpp This file contains rapidxml parser and DOM implementation\r\n\r\n// If standard library is disabled, user must provide implementations of required functions and typedefs\r\n#if !defined(RAPIDXML_NO_STDLIB)\r\n    #include <cstdlib>      // For std::size_t\r\n    #include <cassert>      // For assert\r\n    #include <new>          // For placement new\r\n#endif\r\n\r\n// On MSVC, disable \"conditional expression is constant\" warning (level 4). \r\n// This warning is almost impossible to avoid with certain types of templated code\r\n#ifdef _MSC_VER\r\n    #pragma warning(push)\r\n    #pragma warning(disable:4127)   // Conditional expression is constant\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// RAPIDXML_PARSE_ERROR\r\n    \r\n#if defined(RAPIDXML_NO_EXCEPTIONS)\r\n\r\n#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); }\r\n\r\nnamespace rapidxml\r\n{\r\n    //! When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, \r\n    //! this function is called to notify user about the error.\r\n    //! It must be defined by the user.\r\n    //! <br><br>\r\n    //! This function cannot return. If it does, the results are undefined.\r\n    //! <br><br>\r\n    //! A very simple definition might look like that:\r\n    //! <pre>\r\n    //! void %rapidxml::%parse_error_handler(const char *what, void *where)\r\n    //! {\r\n    //!     std::cout << \"Parse error: \" << what << \"\\n\";\r\n    //!     std::abort();\r\n    //! }\r\n    //! </pre>\r\n    //! \\param what Human readable description of the error.\r\n    //! \\param where Pointer to character data where error was detected.\r\n    void parse_error_handler(const char *what, void *where);\r\n}\r\n\r\n#else\r\n    \r\n#include <exception>    // For std::exception\r\n\r\n#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)\r\n\r\nnamespace rapidxml\r\n{\r\n\r\n    //! Parse error exception. \r\n    //! This exception is thrown by the parser when an error occurs. \r\n    //! Use what() function to get human-readable error message. \r\n    //! Use where() function to get a pointer to position within source text where error was detected.\r\n    //! <br><br>\r\n    //! If throwing exceptions by the parser is undesirable, \r\n    //! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml.hpp is included.\r\n    //! This will cause the parser to call rapidxml::parse_error_handler() function instead of throwing an exception.\r\n    //! This function must be defined by the user.\r\n    //! <br><br>\r\n    //! This class derives from <code>std::exception</code> class.\r\n    class parse_error: public std::exception\r\n    {\r\n    \r\n    public:\r\n    \r\n        //! Constructs parse error\r\n        parse_error(const char *what, void *where)\r\n            : m_what(what)\r\n            , m_where(where)\r\n        {\r\n        }\r\n\r\n        //! Gets human readable description of error.\r\n        //! \\return Pointer to null terminated description of the error.\r\n        virtual const char *what() const throw()\r\n        {\r\n            return m_what;\r\n        }\r\n\r\n        //! Gets pointer to character data where error happened.\r\n        //! Ch should be the same as char type of xml_document that produced the error.\r\n        //! \\return Pointer to location within the parsed string where error occured.\r\n        template<class Ch>\r\n        Ch *where() const\r\n        {\r\n            return reinterpret_cast<Ch *>(m_where);\r\n        }\r\n\r\n    private:  \r\n\r\n        const char *m_what;\r\n        void *m_where;\r\n\r\n    };\r\n}\r\n\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// Pool sizes\r\n\r\n#ifndef RAPIDXML_STATIC_POOL_SIZE\r\n    // Size of static memory block of memory_pool.\r\n    // Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.\r\n    // No dynamic memory allocations are performed by memory_pool until static memory is exhausted.\r\n    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)\r\n#endif\r\n\r\n#ifndef RAPIDXML_DYNAMIC_POOL_SIZE\r\n    // Size of dynamic memory block of memory_pool.\r\n    // Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.\r\n    // After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.\r\n    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)\r\n#endif\r\n\r\n#ifndef RAPIDXML_ALIGNMENT\r\n    // Memory allocation alignment.\r\n    // Define RAPIDXML_ALIGNMENT before including rapidxml.hpp if you want to override the default value, which is the size of pointer.\r\n    // All memory allocations for nodes, attributes and strings will be aligned to this value.\r\n    // This must be a power of 2 and at least 1, otherwise memory_pool will not work.\r\n    #define RAPIDXML_ALIGNMENT sizeof(void *)\r\n#endif\r\n\r\nnamespace rapidxml\r\n{\r\n    // Forward declarations\r\n    template<class Ch> class xml_node;\r\n    template<class Ch> class xml_attribute;\r\n    template<class Ch> class xml_document;\r\n    \r\n    //! Enumeration listing all node types produced by the parser.\r\n    //! Use xml_node::type() function to query node type.\r\n    enum node_type\r\n    {\r\n        node_document,      //!< A document node. Name and value are empty.\r\n        node_element,       //!< An element node. Name contains element name. Value contains text of first data node.\r\n        node_data,          //!< A data node. Name is empty. Value contains data text.\r\n        node_cdata,         //!< A CDATA node. Name is empty. Value contains data text.\r\n        node_comment,       //!< A comment node. Name is empty. Value contains comment text.\r\n        node_declaration,   //!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.\r\n        node_doctype,       //!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.\r\n        node_pi             //!< A PI node. Name contains target. Value contains instructions.\r\n    };\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    // Parsing flags\r\n\r\n    //! Parse flag instructing the parser to not create data nodes. \r\n    //! Text of first data node will still be placed in value of parent element, unless rapidxml::parse_no_element_values flag is also specified.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_no_data_nodes = 0x1;            \r\n\r\n    //! Parse flag instructing the parser to not use text of first data node as a value of parent element.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! Note that child data nodes of element node take precendence over its value when printing. \r\n    //! That is, if element has one or more child data nodes <em>and</em> a value, the value will be ignored.\r\n    //! Use rapidxml::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_no_element_values = 0x2;\r\n    \r\n    //! Parse flag instructing the parser to not place zero terminators after strings in the source text.\r\n    //! By default zero terminators are placed, modifying source text.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_no_string_terminators = 0x4;\r\n    \r\n    //! Parse flag instructing the parser to not translate entities in the source text.\r\n    //! By default entities are translated, modifying source text.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_no_entity_translation = 0x8;\r\n    \r\n    //! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.\r\n    //! By default, UTF-8 handling is enabled.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_no_utf8 = 0x10;\r\n    \r\n    //! Parse flag instructing the parser to create XML declaration node.\r\n    //! By default, declaration node is not created.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_declaration_node = 0x20;\r\n    \r\n    //! Parse flag instructing the parser to create comments nodes.\r\n    //! By default, comment nodes are not created.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_comment_nodes = 0x40;\r\n    \r\n    //! Parse flag instructing the parser to create DOCTYPE node.\r\n    //! By default, doctype node is not created.\r\n    //! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_doctype_node = 0x80;\r\n    \r\n    //! Parse flag instructing the parser to create PI nodes.\r\n    //! By default, PI nodes are not created.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_pi_nodes = 0x100;\r\n    \r\n    //! Parse flag instructing the parser to validate closing tag names. \r\n    //! If not set, name inside closing tag is irrelevant to the parser.\r\n    //! By default, closing tags are not validated.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_validate_closing_tags = 0x200;\r\n    \r\n    //! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.\r\n    //! By default, whitespace is not trimmed. \r\n    //! This flag does not cause the parser to modify source text.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_trim_whitespace = 0x400;\r\n\r\n    //! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.\r\n    //! Trimming of leading and trailing whitespace of data is controlled by rapidxml::parse_trim_whitespace flag.\r\n    //! By default, whitespace is not normalized. \r\n    //! If this flag is specified, source text will be modified.\r\n    //! Can be combined with other flags by use of | operator.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_normalize_whitespace = 0x800;\r\n\r\n    // Compound flags\r\n    \r\n    //! Parse flags which represent default behaviour of the parser. \r\n    //! This is always equal to 0, so that all other flags can be simply ored together.\r\n    //! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.\r\n    //! This also means that meaning of each flag is a <i>negation</i> of the default setting. \r\n    //! For example, if flag name is rapidxml::parse_no_utf8, it means that utf-8 is <i>enabled</i> by default,\r\n    //! and using the flag will disable it.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_default = 0;\r\n    \r\n    //! A combination of parse flags that forbids any modifications of the source text. \r\n    //! This also results in faster parsing. However, note that the following will occur:\r\n    //! <ul>\r\n    //! <li>names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends</li>\r\n    //! <li>entities will not be translated</li>\r\n    //! <li>whitespace will not be normalized</li>\r\n    //! </ul>\r\n    //! See xml_document::parse() function.\r\n    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;\r\n    \r\n    //! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;\r\n    \r\n    //! A combination of parse flags resulting in largest amount of data being extracted. \r\n    //! This usually results in slowest parsing.\r\n    //! <br><br>\r\n    //! See xml_document::parse() function.\r\n    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    // Internals\r\n\r\n    //! \\cond internal\r\n    namespace internal\r\n    {\r\n\r\n        // Struct that contains lookup tables for the parser\r\n        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).\r\n        template<int Dummy>\r\n        struct lookup_tables\r\n        {\r\n            static const unsigned char lookup_whitespace[256];              // Whitespace table\r\n            static const unsigned char lookup_node_name[256];               // Node name table\r\n            static const unsigned char lookup_text[256];                    // Text table\r\n            static const unsigned char lookup_text_pure_no_ws[256];         // Text table\r\n            static const unsigned char lookup_text_pure_with_ws[256];       // Text table\r\n            static const unsigned char lookup_attribute_name[256];          // Attribute name table\r\n            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote\r\n            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote\r\n            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes\r\n            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes\r\n            static const unsigned char lookup_digits[256];                  // Digits\r\n            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters\r\n        };\r\n\r\n        // Find length of the string\r\n        template<class Ch>\r\n        inline std::size_t measure(const Ch *p)\r\n        {\r\n            const Ch *tmp = p;\r\n            while (*tmp) \r\n                ++tmp;\r\n            return tmp - p;\r\n        }\r\n\r\n        // Compare strings for equality\r\n        template<class Ch>\r\n        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)\r\n        {\r\n            if (size1 != size2)\r\n                return false;\r\n            if (case_sensitive)\r\n            {\r\n                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)\r\n                    if (*p1 != *p2)\r\n                        return false;\r\n            }\r\n            else\r\n            {\r\n                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)\r\n                    if (lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p1)] != lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p2)])\r\n                        return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    //! \\endcond\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    // Memory pool\r\n    \r\n    //! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.\r\n    //! In most cases, you will not need to use this class directly. \r\n    //! However, if you need to create nodes manually or modify names/values of nodes, \r\n    //! you are encouraged to use memory_pool of relevant xml_document to allocate the memory. \r\n    //! Not only is this faster than allocating them by using <code>new</code> operator, \r\n    //! but also their lifetime will be tied to the lifetime of document, \r\n    //! possibly simplyfing memory management. \r\n    //! <br><br>\r\n    //! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool. \r\n    //! You can also call allocate_string() function to allocate strings.\r\n    //! Such strings can then be used as names or values of nodes without worrying about their lifetime.\r\n    //! Note that there is no <code>free()</code> function -- all allocations are freed at once when clear() function is called, \r\n    //! or when the pool is destroyed.\r\n    //! <br><br>\r\n    //! It is also possible to create a standalone memory_pool, and use it \r\n    //! to allocate nodes, whose lifetime will not be tied to any document.\r\n    //! <br><br>\r\n    //! Pool maintains <code>RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory. \r\n    //! Until static memory is exhausted, no dynamic memory allocations are done.\r\n    //! When static memory is exhausted, pool allocates additional blocks of memory of size <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> each,\r\n    //! by using global <code>new[]</code> and <code>delete[]</code> operators. \r\n    //! This behaviour can be changed by setting custom allocation routines. \r\n    //! Use set_allocator() function to set them.\r\n    //! <br><br>\r\n    //! Allocations for nodes, attributes and strings are aligned at <code>RAPIDXML_ALIGNMENT</code> bytes.\r\n    //! This value defaults to the size of pointer on target architecture.\r\n    //! <br><br>\r\n    //! To obtain absolutely top performance from the parser,\r\n    //! it is important that all nodes are allocated from a single, contiguous block of memory.\r\n    //! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.\r\n    //! If required, you can tweak <code>RAPIDXML_STATIC_POOL_SIZE</code>, <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>RAPIDXML_ALIGNMENT</code> \r\n    //! to obtain best wasted memory to performance compromise.\r\n    //! To do it, define their values before rapidxml.hpp file is included.\r\n    //! \\param Ch Character type of created nodes. \r\n    template<class Ch = char>\r\n    class memory_pool\r\n    {\r\n        \r\n    public:\r\n\r\n        //! \\cond internal\r\n        typedef void *(alloc_func)(std::size_t);       // Type of user-defined function used to allocate memory\r\n        typedef void (free_func)(void *);              // Type of user-defined function used to free memory\r\n        //! \\endcond\r\n        \r\n        //! Constructs empty pool with default allocator functions.\r\n        memory_pool()\r\n            : m_alloc_func(0)\r\n            , m_free_func(0)\r\n        {\r\n            init();\r\n        }\r\n\r\n        //! Destroys pool and frees all the memory. \r\n        //! This causes memory occupied by nodes allocated by the pool to be freed.\r\n        //! Nodes allocated from the pool are no longer valid.\r\n        ~memory_pool()\r\n        {\r\n            clear();\r\n        }\r\n\r\n        //! Allocates a new node from the pool, and optionally assigns name and value to it. \r\n        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.\r\n        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function\r\n        //! will call rapidxml::parse_error_handler() function.\r\n        //! \\param type Type of node to create.\r\n        //! \\param name Name to assign to the node, or 0 to assign no name.\r\n        //! \\param value Value to assign to the node, or 0 to assign no value.\r\n        //! \\param name_size Size of name to assign, or 0 to automatically calculate size from name string.\r\n        //! \\param value_size Size of value to assign, or 0 to automatically calculate size from value string.\r\n        //! \\return Pointer to allocated node. This pointer will never be NULL.\r\n        xml_node<Ch> *allocate_node(node_type type, \r\n                                    const Ch *name = 0, const Ch *value = 0, \r\n                                    std::size_t name_size = 0, std::size_t value_size = 0)\r\n        {\r\n            void *memory = allocate_aligned(sizeof(xml_node<Ch>));\r\n            xml_node<Ch> *node = new(memory) xml_node<Ch>(type);\r\n            if (name)\r\n            {\r\n                if (name_size > 0)\r\n                    node->name(name, name_size);\r\n                else\r\n                    node->name(name);\r\n            }\r\n            if (value)\r\n            {\r\n                if (value_size > 0)\r\n                    node->value(value, value_size);\r\n                else\r\n                    node->value(value);\r\n            }\r\n            return node;\r\n        }\r\n\r\n        //! Allocates a new attribute from the pool, and optionally assigns name and value to it.\r\n        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.\r\n        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function\r\n        //! will call rapidxml::parse_error_handler() function.\r\n        //! \\param name Name to assign to the attribute, or 0 to assign no name.\r\n        //! \\param value Value to assign to the attribute, or 0 to assign no value.\r\n        //! \\param name_size Size of name to assign, or 0 to automatically calculate size from name string.\r\n        //! \\param value_size Size of value to assign, or 0 to automatically calculate size from value string.\r\n        //! \\return Pointer to allocated attribute. This pointer will never be NULL.\r\n        xml_attribute<Ch> *allocate_attribute(const Ch *name = 0, const Ch *value = 0, \r\n                                              std::size_t name_size = 0, std::size_t value_size = 0)\r\n        {\r\n            void *memory = allocate_aligned(sizeof(xml_attribute<Ch>));\r\n            xml_attribute<Ch> *attribute = new(memory) xml_attribute<Ch>;\r\n            if (name)\r\n            {\r\n                if (name_size > 0)\r\n                    attribute->name(name, name_size);\r\n                else\r\n                    attribute->name(name);\r\n            }\r\n            if (value)\r\n            {\r\n                if (value_size > 0)\r\n                    attribute->value(value, value_size);\r\n                else\r\n                    attribute->value(value);\r\n            }\r\n            return attribute;\r\n        }\r\n\r\n        //! Allocates a char array of given size from the pool, and optionally copies a given string to it.\r\n        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.\r\n        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function\r\n        //! will call rapidxml::parse_error_handler() function.\r\n        //! \\param source String to initialize the allocated memory with, or 0 to not initialize it.\r\n        //! \\param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.\r\n        //! \\return Pointer to allocated char array. This pointer will never be NULL.\r\n        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)\r\n        {\r\n            assert(source || size);     // Either source or size (or both) must be specified\r\n            if (size == 0)\r\n                size = internal::measure(source) + 1;\r\n            Ch *result = static_cast<Ch *>(allocate_aligned(size * sizeof(Ch)));\r\n            if (source)\r\n                for (std::size_t i = 0; i < size; ++i)\r\n                    result[i] = source[i];\r\n            return result;\r\n        }\r\n\r\n        //! Clones an xml_node and its hierarchy of child nodes and attributes.\r\n        //! Nodes and attributes are allocated from this memory pool.\r\n        //! Names and values are not cloned, they are shared between the clone and the source.\r\n        //! Result node can be optionally specified as a second parameter, \r\n        //! in which case its contents will be replaced with cloned source node.\r\n        //! This is useful when you want to clone entire document.\r\n        //! \\param source Node to clone.\r\n        //! \\param result Node to put results in, or 0 to automatically allocate result node\r\n        //! \\return Pointer to cloned node. This pointer will never be NULL.\r\n        xml_node<Ch> *clone_node(const xml_node<Ch> *source, xml_node<Ch> *result = 0)\r\n        {\r\n            // Prepare result node\r\n            if (result)\r\n            {\r\n                result->remove_all_attributes();\r\n                result->remove_all_nodes();\r\n                result->type(source->type());\r\n            }\r\n            else\r\n                result = allocate_node(source->type());\r\n\r\n            // Clone name and value\r\n            result->name(source->name(), source->name_size());\r\n            result->value(source->value(), source->value_size());\r\n\r\n            // Clone child nodes and attributes\r\n            for (xml_node<Ch> *child = source->first_node(); child; child = child->next_sibling())\r\n                result->append_node(clone_node(child));\r\n            for (xml_attribute<Ch> *attr = source->first_attribute(); attr; attr = attr->next_attribute())\r\n                result->append_attribute(allocate_attribute(attr->name(), attr->value(), attr->name_size(), attr->value_size()));\r\n\r\n            return result;\r\n        }\r\n\r\n        //! Clears the pool. \r\n        //! This causes memory occupied by nodes allocated by the pool to be freed.\r\n        //! Any nodes or strings allocated from the pool will no longer be valid.\r\n        void clear()\r\n        {\r\n            while (m_begin != m_static_memory)\r\n            {\r\n                char *previous_begin = reinterpret_cast<header *>(align(m_begin))->previous_begin;\r\n                if (m_free_func)\r\n                    m_free_func(m_begin);\r\n                else\r\n                    delete[] m_begin;\r\n                m_begin = previous_begin;\r\n            }\r\n            init();\r\n        }\r\n\r\n        //! Sets or resets the user-defined memory allocation functions for the pool.\r\n        //! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.\r\n        //! Allocation function must not return invalid pointer on failure. It should either throw,\r\n        //! stop the program, or use <code>longjmp()</code> function to pass control to other place of program. \r\n        //! If it returns invalid pointer, results are undefined.\r\n        //! <br><br>\r\n        //! User defined allocation functions must have the following forms:\r\n        //! <br><code>\r\n        //! <br>void *allocate(std::size_t size);\r\n        //! <br>void free(void *pointer);\r\n        //! </code><br>\r\n        //! \\param af Allocation function, or 0 to restore default function\r\n        //! \\param ff Free function, or 0 to restore default function\r\n        void set_allocator(alloc_func *af, free_func *ff)\r\n        {\r\n            assert(m_begin == m_static_memory && m_ptr == align(m_begin));    // Verify that no memory is allocated yet\r\n            m_alloc_func = af;\r\n            m_free_func = ff;\r\n        }\r\n\r\n    private:\r\n\r\n        struct header\r\n        {\r\n            char *previous_begin;\r\n        };\r\n\r\n        void init()\r\n        {\r\n            m_begin = m_static_memory;\r\n            m_ptr = align(m_begin);\r\n            m_end = m_static_memory + sizeof(m_static_memory);\r\n        }\r\n        \r\n        char *align(char *ptr)\r\n        {\r\n            std::size_t alignment = ((RAPIDXML_ALIGNMENT - (std::size_t(ptr) & (RAPIDXML_ALIGNMENT - 1))) & (RAPIDXML_ALIGNMENT - 1));\r\n            return ptr + alignment;\r\n        }\r\n        \r\n        char *allocate_raw(std::size_t size)\r\n        {\r\n            // Allocate\r\n            void *memory;   \r\n            if (m_alloc_func)   // Allocate memory using either user-specified allocation function or global operator new[]\r\n            {\r\n                memory = m_alloc_func(size);\r\n                assert(memory); // Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp\r\n            }\r\n            else\r\n            {\r\n                memory = new char[size];\r\n#ifdef RAPIDXML_NO_EXCEPTIONS\r\n                if (!memory)            // If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc\r\n                    RAPIDXML_PARSE_ERROR(\"out of memory\", 0);\r\n#endif\r\n            }\r\n            return static_cast<char *>(memory);\r\n        }\r\n        \r\n        void *allocate_aligned(std::size_t size)\r\n        {\r\n            // Calculate aligned pointer\r\n            char *result = align(m_ptr);\r\n\r\n            // If not enough memory left in current pool, allocate a new pool\r\n            if (result + size > m_end)\r\n            {\r\n                // Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)\r\n                std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;\r\n                if (pool_size < size)\r\n                    pool_size = size;\r\n                \r\n                // Allocate\r\n                std::size_t alloc_size = sizeof(header) + (2 * RAPIDXML_ALIGNMENT - 2) + pool_size;     // 2 alignments required in worst case: one for header, one for actual allocation\r\n                char *raw_memory = allocate_raw(alloc_size);\r\n                    \r\n                // Setup new pool in allocated memory\r\n                char *pool = align(raw_memory);\r\n                header *new_header = reinterpret_cast<header *>(pool);\r\n                new_header->previous_begin = m_begin;\r\n                m_begin = raw_memory;\r\n                m_ptr = pool + sizeof(header);\r\n                m_end = raw_memory + alloc_size;\r\n\r\n                // Calculate aligned pointer again using new pool\r\n                result = align(m_ptr);\r\n            }\r\n\r\n            // Update pool and return aligned pointer\r\n            m_ptr = result + size;\r\n            return result;\r\n        }\r\n\r\n        char *m_begin;                                      // Start of raw memory making up current pool\r\n        char *m_ptr;                                        // First free byte in current pool\r\n        char *m_end;                                        // One past last available byte in current pool\r\n        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    // Static raw memory\r\n        alloc_func *m_alloc_func;                           // Allocator function, or 0 if default is to be used\r\n        free_func *m_free_func;                             // Free function, or 0 if default is to be used\r\n    };\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // XML base\r\n\r\n    //! Base class for xml_node and xml_attribute implementing common functions: \r\n    //! name(), name_size(), value(), value_size() and parent().\r\n    //! \\param Ch Character type to use\r\n    template<class Ch = char>\r\n    class xml_base\r\n    {\r\n\r\n    public:\r\n        \r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Construction & destruction\r\n    \r\n        // Construct a base with empty name, value and parent\r\n        xml_base()\r\n            : m_name(0)\r\n            , m_value(0)\r\n            , m_parent(0)\r\n        {\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Node data access\r\n    \r\n        //! Gets name of the node. \r\n        //! Interpretation of name depends on type of node.\r\n        //! Note that name will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.\r\n        //! <br><br>\r\n        //! Use name_size() function to determine length of the name.\r\n        //! \\return Name of node, or empty string if node has no name.\r\n        Ch *name() const\r\n        {\r\n            return m_name ? m_name : nullstr();\r\n        }\r\n\r\n        //! Gets size of node name, not including terminator character.\r\n        //! This function works correctly irrespective of whether name is or is not zero terminated.\r\n        //! \\return Size of node name, in characters.\r\n        std::size_t name_size() const\r\n        {\r\n            return m_name ? m_name_size : 0;\r\n        }\r\n\r\n        //! Gets value of node. \r\n        //! Interpretation of value depends on type of node.\r\n        //! Note that value will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.\r\n        //! <br><br>\r\n        //! Use value_size() function to determine length of the value.\r\n        //! \\return Value of node, or empty string if node has no value.\r\n        Ch *value() const\r\n        {\r\n            return m_value ? m_value : nullstr();\r\n        }\r\n\r\n        //! Gets size of node value, not including terminator character.\r\n        //! This function works correctly irrespective of whether value is or is not zero terminated.\r\n        //! \\return Size of node value, in characters.\r\n        std::size_t value_size() const\r\n        {\r\n            return m_value ? m_value_size : 0;\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Node modification\r\n    \r\n        //! Sets name of node to a non zero-terminated string.\r\n        //! See \\ref ownership_of_strings.\r\n        //! <br><br>\r\n        //! Note that node does not own its name or value, it only stores a pointer to it. \r\n        //! It will not delete or otherwise free the pointer on destruction.\r\n        //! It is reponsibility of the user to properly manage lifetime of the string.\r\n        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -\r\n        //! on destruction of the document the string will be automatically freed.\r\n        //! <br><br>\r\n        //! Size of name must be specified separately, because name does not have to be zero terminated.\r\n        //! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).\r\n        //! \\param name Name of node to set. Does not have to be zero terminated.\r\n        //! \\param size Size of name, in characters. This does not include zero terminator, if one is present.\r\n        void name(const Ch *name, std::size_t size)\r\n        {\r\n            m_name = const_cast<Ch *>(name);\r\n            m_name_size = size;\r\n        }\r\n\r\n        //! Sets name of node to a zero-terminated string.\r\n        //! See also \\ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).\r\n        //! \\param name Name of node to set. Must be zero terminated.\r\n        void name(const Ch *name)\r\n        {\r\n            this->name(name, internal::measure(name));\r\n        }\r\n\r\n        //! Sets value of node to a non zero-terminated string.\r\n        //! See \\ref ownership_of_strings.\r\n        //! <br><br>\r\n        //! Note that node does not own its name or value, it only stores a pointer to it. \r\n        //! It will not delete or otherwise free the pointer on destruction.\r\n        //! It is reponsibility of the user to properly manage lifetime of the string.\r\n        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -\r\n        //! on destruction of the document the string will be automatically freed.\r\n        //! <br><br>\r\n        //! Size of value must be specified separately, because it does not have to be zero terminated.\r\n        //! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).\r\n        //! <br><br>\r\n        //! If an element has a child node of type node_data, it will take precedence over element value when printing.\r\n        //! If you want to manipulate data of elements using values, use parser flag rapidxml::parse_no_data_nodes to prevent creation of data nodes by the parser.\r\n        //! \\param value value of node to set. Does not have to be zero terminated.\r\n        //! \\param size Size of value, in characters. This does not include zero terminator, if one is present.\r\n        void value(const Ch *value, std::size_t size)\r\n        {\r\n            m_value = const_cast<Ch *>(value);\r\n            m_value_size = size;\r\n        }\r\n\r\n        //! Sets value of node to a zero-terminated string.\r\n        //! See also \\ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).\r\n        //! \\param value Vame of node to set. Must be zero terminated.\r\n        void value(const Ch *value)\r\n        {\r\n            this->value(value, internal::measure(value));\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Related nodes access\r\n    \r\n        //! Gets node parent.\r\n        //! \\return Pointer to parent node, or 0 if there is no parent.\r\n        xml_node<Ch> *parent() const\r\n        {\r\n            return m_parent;\r\n        }\r\n\r\n    protected:\r\n\r\n        // Return empty string\r\n        static Ch *nullstr()\r\n        {\r\n            static Ch zero = Ch('\\0');\r\n            return &zero;\r\n        }\r\n\r\n        Ch *m_name;                         // Name of node, or 0 if no name\r\n        Ch *m_value;                        // Value of node, or 0 if no value\r\n        std::size_t m_name_size;            // Length of node name, or undefined of no name\r\n        std::size_t m_value_size;           // Length of node value, or undefined if no value\r\n        xml_node<Ch> *m_parent;             // Pointer to parent node, or 0 if none\r\n\r\n    };\r\n\r\n    //! Class representing attribute node of XML document. \r\n    //! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).\r\n    //! Note that after parse, both name and value of attribute will point to interior of source text used for parsing. \r\n    //! Thus, this text must persist in memory for the lifetime of attribute.\r\n    //! \\param Ch Character type to use.\r\n    template<class Ch = char>\r\n    class xml_attribute: public xml_base<Ch>\r\n    {\r\n\r\n        friend class xml_node<Ch>;\r\n    \r\n    public:\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Construction & destruction\r\n    \r\n        //! Constructs an empty attribute with the specified type. \r\n        //! Consider using memory_pool of appropriate xml_document if allocating attributes manually.\r\n        xml_attribute()\r\n        {\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Related nodes access\r\n    \r\n        //! Gets document of which attribute is a child.\r\n        //! \\return Pointer to document that contains this attribute, or 0 if there is no parent document.\r\n        xml_document<Ch> *document() const\r\n        {\r\n            if (xml_node<Ch> *node = this->parent())\r\n            {\r\n                while (node->parent())\r\n                    node = node->parent();\r\n                return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;\r\n            }\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        //! Gets previous attribute, optionally matching attribute name. \r\n        //! \\param name Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found attribute, or 0 if not found.\r\n        xml_attribute<Ch> *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_attribute<Ch> *attribute = m_prev_attribute; attribute; attribute = attribute->m_prev_attribute)\r\n                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))\r\n                        return attribute;\r\n                return 0;\r\n            }\r\n            else\r\n                return this->m_parent ? m_prev_attribute : 0;\r\n        }\r\n\r\n        //! Gets next attribute, optionally matching attribute name. \r\n        //! \\param name Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found attribute, or 0 if not found.\r\n        xml_attribute<Ch> *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)\r\n                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))\r\n                        return attribute;\r\n                return 0;\r\n            }\r\n            else\r\n                return this->m_parent ? m_next_attribute : 0;\r\n        }\r\n\r\n    private:\r\n\r\n        xml_attribute<Ch> *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero\r\n        xml_attribute<Ch> *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero\r\n    \r\n    };\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // XML node\r\n\r\n    //! Class representing a node of XML document. \r\n    //! Each node may have associated name and value strings, which are available through name() and value() functions. \r\n    //! Interpretation of name and value depends on type of the node.\r\n    //! Type of node can be determined by using type() function.\r\n    //! <br><br>\r\n    //! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. \r\n    //! Thus, this text must persist in the memory for the lifetime of node.\r\n    //! \\param Ch Character type to use.\r\n    template<class Ch = char>\r\n    class xml_node: public xml_base<Ch>\r\n    {\r\n\r\n    public:\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Construction & destruction\r\n    \r\n        //! Constructs an empty node with the specified type. \r\n        //! Consider using memory_pool of appropriate document to allocate nodes manually.\r\n        //! \\param type Type of node to construct.\r\n        xml_node(node_type type)\r\n            : m_type(type)\r\n            , m_first_node(0)\r\n            , m_first_attribute(0)\r\n        {\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Node data access\r\n    \r\n        //! Gets type of node.\r\n        //! \\return Type of node.\r\n        node_type type() const\r\n        {\r\n            return m_type;\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Related nodes access\r\n    \r\n        //! Gets document of which node is a child.\r\n        //! \\return Pointer to document that contains this node, or 0 if there is no parent document.\r\n        xml_document<Ch> *document() const\r\n        {\r\n            xml_node<Ch> *node = const_cast<xml_node<Ch> *>(this);\r\n            while (node->parent())\r\n                node = node->parent();\r\n            return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;\r\n        }\r\n\r\n        //! Gets first child node, optionally matching node name.\r\n        //! \\param name Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found child, or 0 if not found.\r\n        xml_node<Ch> *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())\r\n                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))\r\n                        return child;\r\n                return 0;\r\n            }\r\n            else\r\n                return m_first_node;\r\n        }\r\n\r\n        //! Gets last child node, optionally matching node name. \r\n        //! Behaviour is undefined if node has no children.\r\n        //! Use first_node() to test if node has children.\r\n        //! \\param name Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found child, or 0 if not found.\r\n        xml_node<Ch> *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            assert(m_first_node);  // Cannot query for last child if node has no children\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_node<Ch> *child = m_last_node; child; child = child->previous_sibling())\r\n                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))\r\n                        return child;\r\n                return 0;\r\n            }\r\n            else\r\n                return m_last_node;\r\n        }\r\n\r\n        //! Gets previous sibling node, optionally matching node name. \r\n        //! Behaviour is undefined if node has no parent.\r\n        //! Use parent() to test if node has a parent.\r\n        //! \\param name Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found sibling, or 0 if not found.\r\n        xml_node<Ch> *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            assert(this->m_parent);     // Cannot query for siblings if node has no parent\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_node<Ch> *sibling = m_prev_sibling; sibling; sibling = sibling->m_prev_sibling)\r\n                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))\r\n                        return sibling;\r\n                return 0;\r\n            }\r\n            else\r\n                return m_prev_sibling;\r\n        }\r\n\r\n        //! Gets next sibling node, optionally matching node name. \r\n        //! Behaviour is undefined if node has no parent.\r\n        //! Use parent() to test if node has a parent.\r\n        //! \\param name Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found sibling, or 0 if not found.\r\n        xml_node<Ch> *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            assert(this->m_parent);     // Cannot query for siblings if node has no parent\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)\r\n                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))\r\n                        return sibling;\r\n                return 0;\r\n            }\r\n            else\r\n                return m_next_sibling;\r\n        }\r\n\r\n        //! Gets first attribute of node, optionally matching attribute name.\r\n        //! \\param name Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found attribute, or 0 if not found.\r\n        xml_attribute<Ch> *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)\r\n                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))\r\n                        return attribute;\r\n                return 0;\r\n            }\r\n            else\r\n                return m_first_attribute;\r\n        }\r\n\r\n        //! Gets last attribute of node, optionally matching attribute name.\r\n        //! \\param name Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero\r\n        //! \\param name_size Size of name, in characters, or 0 to have size calculated automatically from string\r\n        //! \\param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters\r\n        //! \\return Pointer to found attribute, or 0 if not found.\r\n        xml_attribute<Ch> *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const\r\n        {\r\n            if (name)\r\n            {\r\n                if (name_size == 0)\r\n                    name_size = internal::measure(name);\r\n                for (xml_attribute<Ch> *attribute = m_last_attribute; attribute; attribute = attribute->m_prev_attribute)\r\n                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))\r\n                        return attribute;\r\n                return 0;\r\n            }\r\n            else\r\n                return m_first_attribute ? m_last_attribute : 0;\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Node modification\r\n    \r\n        //! Sets type of node.\r\n        //! \\param type Type of node to set.\r\n        void type(node_type type)\r\n        {\r\n            m_type = type;\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Node manipulation\r\n\r\n        //! Prepends a new child node.\r\n        //! The prepended child becomes the first child, and all existing children are moved one position back.\r\n        //! \\param child Node to prepend.\r\n        void prepend_node(xml_node<Ch> *child)\r\n        {\r\n            assert(child && !child->parent() && child->type() != node_document);\r\n            if (first_node())\r\n            {\r\n                child->m_next_sibling = m_first_node;\r\n                m_first_node->m_prev_sibling = child;\r\n            }\r\n            else\r\n            {\r\n                child->m_next_sibling = 0;\r\n                m_last_node = child;\r\n            }\r\n            m_first_node = child;\r\n            child->m_parent = this;\r\n            child->m_prev_sibling = 0;\r\n        }\r\n\r\n        //! Appends a new child node. \r\n        //! The appended child becomes the last child.\r\n        //! \\param child Node to append.\r\n        void append_node(xml_node<Ch> *child)\r\n        {\r\n            assert(child && !child->parent() && child->type() != node_document);\r\n            if (first_node())\r\n            {\r\n                child->m_prev_sibling = m_last_node;\r\n                m_last_node->m_next_sibling = child;\r\n            }\r\n            else\r\n            {\r\n                child->m_prev_sibling = 0;\r\n                m_first_node = child;\r\n            }\r\n            m_last_node = child;\r\n            child->m_parent = this;\r\n            child->m_next_sibling = 0;\r\n        }\r\n\r\n        //! Inserts a new child node at specified place inside the node. \r\n        //! All children after and including the specified node are moved one position back.\r\n        //! \\param where Place where to insert the child, or 0 to insert at the back.\r\n        //! \\param child Node to insert.\r\n        void insert_node(xml_node<Ch> *where, xml_node<Ch> *child)\r\n        {\r\n            assert(!where || where->parent() == this);\r\n            assert(child && !child->parent() && child->type() != node_document);\r\n            if (where == m_first_node)\r\n                prepend_node(child);\r\n            else if (where == 0)\r\n                append_node(child);\r\n            else\r\n            {\r\n                child->m_prev_sibling = where->m_prev_sibling;\r\n                child->m_next_sibling = where;\r\n                where->m_prev_sibling->m_next_sibling = child;\r\n                where->m_prev_sibling = child;\r\n                child->m_parent = this;\r\n            }\r\n        }\r\n\r\n        //! Removes first child node. \r\n        //! If node has no children, behaviour is undefined.\r\n        //! Use first_node() to test if node has children.\r\n        void remove_first_node()\r\n        {\r\n            assert(first_node());\r\n            xml_node<Ch> *child = m_first_node;\r\n            m_first_node = child->m_next_sibling;\r\n            if (child->m_next_sibling)\r\n                child->m_next_sibling->m_prev_sibling = 0;\r\n            else\r\n                m_last_node = 0;\r\n            child->m_parent = 0;\r\n        }\r\n\r\n        //! Removes last child of the node. \r\n        //! If node has no children, behaviour is undefined.\r\n        //! Use first_node() to test if node has children.\r\n        void remove_last_node()\r\n        {\r\n            assert(first_node());\r\n            xml_node<Ch> *child = m_last_node;\r\n            if (child->m_prev_sibling)\r\n            {\r\n                m_last_node = child->m_prev_sibling;\r\n                child->m_prev_sibling->m_next_sibling = 0;\r\n            }\r\n            else\r\n                m_first_node = 0;\r\n            child->m_parent = 0;\r\n        }\r\n\r\n        //! Removes specified child from the node\r\n        // \\param where Pointer to child to be removed.\r\n        void remove_node(xml_node<Ch> *where)\r\n        {\r\n            assert(where && where->parent() == this);\r\n            assert(first_node());\r\n            if (where == m_first_node)\r\n                remove_first_node();\r\n            else if (where == m_last_node)\r\n                remove_last_node();\r\n            else\r\n            {\r\n                where->m_prev_sibling->m_next_sibling = where->m_next_sibling;\r\n                where->m_next_sibling->m_prev_sibling = where->m_prev_sibling;\r\n                where->m_parent = 0;\r\n            }\r\n        }\r\n\r\n        //! Removes all child nodes (but not attributes).\r\n        void remove_all_nodes()\r\n        {\r\n            for (xml_node<Ch> *node = first_node(); node; node = node->m_next_sibling)\r\n                node->m_parent = 0;\r\n            m_first_node = 0;\r\n        }\r\n\r\n        //! Prepends a new attribute to the node.\r\n        //! \\param attribute Attribute to prepend.\r\n        void prepend_attribute(xml_attribute<Ch> *attribute)\r\n        {\r\n            assert(attribute && !attribute->parent());\r\n            if (first_attribute())\r\n            {\r\n                attribute->m_next_attribute = m_first_attribute;\r\n                m_first_attribute->m_prev_attribute = attribute;\r\n            }\r\n            else\r\n            {\r\n                attribute->m_next_attribute = 0;\r\n                m_last_attribute = attribute;\r\n            }\r\n            m_first_attribute = attribute;\r\n            attribute->m_parent = this;\r\n            attribute->m_prev_attribute = 0;\r\n        }\r\n\r\n        //! Appends a new attribute to the node.\r\n        //! \\param attribute Attribute to append.\r\n        void append_attribute(xml_attribute<Ch> *attribute)\r\n        {\r\n            assert(attribute && !attribute->parent());\r\n            if (first_attribute())\r\n            {\r\n                attribute->m_prev_attribute = m_last_attribute;\r\n                m_last_attribute->m_next_attribute = attribute;\r\n            }\r\n            else\r\n            {\r\n                attribute->m_prev_attribute = 0;\r\n                m_first_attribute = attribute;\r\n            }\r\n            m_last_attribute = attribute;\r\n            attribute->m_parent = this;\r\n            attribute->m_next_attribute = 0;\r\n        }\r\n\r\n        //! Inserts a new attribute at specified place inside the node. \r\n        //! All attributes after and including the specified attribute are moved one position back.\r\n        //! \\param where Place where to insert the attribute, or 0 to insert at the back.\r\n        //! \\param attribute Attribute to insert.\r\n        void insert_attribute(xml_attribute<Ch> *where, xml_attribute<Ch> *attribute)\r\n        {\r\n            assert(!where || where->parent() == this);\r\n            assert(attribute && !attribute->parent());\r\n            if (where == m_first_attribute)\r\n                prepend_attribute(attribute);\r\n            else if (where == 0)\r\n                append_attribute(attribute);\r\n            else\r\n            {\r\n                attribute->m_prev_attribute = where->m_prev_attribute;\r\n                attribute->m_next_attribute = where;\r\n                where->m_prev_attribute->m_next_attribute = attribute;\r\n                where->m_prev_attribute = attribute;\r\n                attribute->m_parent = this;\r\n            }\r\n        }\r\n\r\n        //! Removes first attribute of the node. \r\n        //! If node has no attributes, behaviour is undefined.\r\n        //! Use first_attribute() to test if node has attributes.\r\n        void remove_first_attribute()\r\n        {\r\n            assert(first_attribute());\r\n            xml_attribute<Ch> *attribute = m_first_attribute;\r\n            if (attribute->m_next_attribute)\r\n            {\r\n                attribute->m_next_attribute->m_prev_attribute = 0;\r\n            }\r\n            else\r\n                m_last_attribute = 0;\r\n            attribute->m_parent = 0;\r\n            m_first_attribute = attribute->m_next_attribute;\r\n        }\r\n\r\n        //! Removes last attribute of the node. \r\n        //! If node has no attributes, behaviour is undefined.\r\n        //! Use first_attribute() to test if node has attributes.\r\n        void remove_last_attribute()\r\n        {\r\n            assert(first_attribute());\r\n            xml_attribute<Ch> *attribute = m_last_attribute;\r\n            if (attribute->m_prev_attribute)\r\n            {\r\n                attribute->m_prev_attribute->m_next_attribute = 0;\r\n                m_last_attribute = attribute->m_prev_attribute;\r\n            }\r\n            else\r\n                m_first_attribute = 0;\r\n            attribute->m_parent = 0;\r\n        }\r\n\r\n        //! Removes specified attribute from node.\r\n        //! \\param where Pointer to attribute to be removed.\r\n        void remove_attribute(xml_attribute<Ch> *where)\r\n        {\r\n            assert(first_attribute() && where->parent() == this);\r\n            if (where == m_first_attribute)\r\n                remove_first_attribute();\r\n            else if (where == m_last_attribute)\r\n                remove_last_attribute();\r\n            else\r\n            {\r\n                where->m_prev_attribute->m_next_attribute = where->m_next_attribute;\r\n                where->m_next_attribute->m_prev_attribute = where->m_prev_attribute;\r\n                where->m_parent = 0;\r\n            }\r\n        }\r\n\r\n        //! Removes all attributes of node.\r\n        void remove_all_attributes()\r\n        {\r\n            for (xml_attribute<Ch> *attribute = first_attribute(); attribute; attribute = attribute->m_next_attribute)\r\n                attribute->m_parent = 0;\r\n            m_first_attribute = 0;\r\n        }\r\n        \r\n    private:\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Restrictions\r\n\r\n        // No copying\r\n        xml_node(const xml_node &);\r\n        void operator =(const xml_node &);\r\n    \r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Data members\r\n    \r\n        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.\r\n        // This is required for maximum performance, as it allows the parser to omit initialization of \r\n        // unneded/redundant values.\r\n        //\r\n        // The rules are as follows:\r\n        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively\r\n        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage\r\n        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage\r\n\r\n        node_type m_type;                       // Type of node; always valid\r\n        xml_node<Ch> *m_first_node;             // Pointer to first child node, or 0 if none; always valid\r\n        xml_node<Ch> *m_last_node;              // Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero\r\n        xml_attribute<Ch> *m_first_attribute;   // Pointer to first attribute of node, or 0 if none; always valid\r\n        xml_attribute<Ch> *m_last_attribute;    // Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero\r\n        xml_node<Ch> *m_prev_sibling;           // Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero\r\n        xml_node<Ch> *m_next_sibling;           // Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero\r\n\r\n    };\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // XML document\r\n    \r\n    //! This class represents root of the DOM hierarchy. \r\n    //! It is also an xml_node and a memory_pool through public inheritance.\r\n    //! Use parse() function to build a DOM tree from a zero-terminated XML text string.\r\n    //! parse() function allocates memory for nodes and attributes by using functions of xml_document, \r\n    //! which are inherited from memory_pool.\r\n    //! To access root node of the document, use the document itself, as if it was an xml_node.\r\n    //! \\param Ch Character type to use.\r\n    template<class Ch = char>\r\n    class xml_document: public xml_node<Ch>, public memory_pool<Ch>\r\n    {\r\n    \r\n    public:\r\n\r\n        //! Constructs empty XML document\r\n        xml_document()\r\n            : xml_node<Ch>(node_document)\r\n        {\r\n        }\r\n\r\n        //! Parses zero-terminated XML string according to given flags.\r\n        //! Passed string will be modified by the parser, unless rapidxml::parse_non_destructive flag is used.\r\n        //! The string must persist for the lifetime of the document.\r\n        //! In case of error, rapidxml::parse_error exception will be thrown.\r\n        //! <br><br>\r\n        //! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.\r\n        //! Make sure that data is zero-terminated.\r\n        //! <br><br>\r\n        //! Document can be parsed into multiple times. \r\n        //! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.\r\n        //! \\param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.\r\n        template<int Flags>\r\n        void parse(Ch *text)\r\n        {\r\n            assert(text);\r\n            \r\n            // Remove current contents\r\n            this->remove_all_nodes();\r\n            this->remove_all_attributes();\r\n            \r\n            // Parse BOM, if any\r\n            parse_bom<Flags>(text);\r\n            \r\n            // Parse children\r\n            while (1)\r\n            {\r\n                // Skip whitespace before node\r\n                skip<whitespace_pred, Flags>(text);\r\n                if (*text == 0)\r\n                    break;\r\n\r\n                // Parse and append new child\r\n                if (*text == Ch('<'))\r\n                {\r\n                    ++text;     // Skip '<'\r\n                    if (xml_node<Ch> *node = parse_node<Flags>(text))\r\n                        this->append_node(node);\r\n                }\r\n                else\r\n                    RAPIDXML_PARSE_ERROR(\"expected <\", text);\r\n            }\r\n\r\n        }\r\n\r\n        //! Clears the document by deleting all nodes and clearing the memory pool.\r\n        //! All nodes owned by document pool are destroyed.\r\n        void clear()\r\n        {\r\n            this->remove_all_nodes();\r\n            this->remove_all_attributes();\r\n            memory_pool<Ch>::clear();\r\n        }\r\n        \r\n    private:\r\n\r\n        ///////////////////////////////////////////////////////////////////////\r\n        // Internal character utility functions\r\n        \r\n        // Detect whitespace character\r\n        struct whitespace_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                return internal::lookup_tables<0>::lookup_whitespace[static_cast<unsigned char>(ch)];\r\n            }\r\n        };\r\n\r\n        // Detect node name character\r\n        struct node_name_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                return internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];\r\n            }\r\n        };\r\n\r\n        // Detect attribute name character\r\n        struct attribute_name_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                return internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];\r\n            }\r\n        };\r\n\r\n        // Detect text character (PCDATA)\r\n        struct text_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                return internal::lookup_tables<0>::lookup_text[static_cast<unsigned char>(ch)];\r\n            }\r\n        };\r\n\r\n        // Detect text character (PCDATA) that does not require processing\r\n        struct text_pure_no_ws_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                return internal::lookup_tables<0>::lookup_text_pure_no_ws[static_cast<unsigned char>(ch)];\r\n            }\r\n        };\r\n\r\n        // Detect text character (PCDATA) that does not require processing\r\n        struct text_pure_with_ws_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                return internal::lookup_tables<0>::lookup_text_pure_with_ws[static_cast<unsigned char>(ch)];\r\n            }\r\n        };\r\n\r\n        // Detect attribute value character\r\n        template<Ch Quote>\r\n        struct attribute_value_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                if (Quote == Ch('\\''))\r\n                    return internal::lookup_tables<0>::lookup_attribute_data_1[static_cast<unsigned char>(ch)];\r\n                if (Quote == Ch('\\\"'))\r\n                    return internal::lookup_tables<0>::lookup_attribute_data_2[static_cast<unsigned char>(ch)];\r\n                return 0;       // Should never be executed, to avoid warnings on Comeau\r\n            }\r\n        };\r\n\r\n        // Detect attribute value character\r\n        template<Ch Quote>\r\n        struct attribute_value_pure_pred\r\n        {\r\n            static unsigned char test(Ch ch)\r\n            {\r\n                if (Quote == Ch('\\''))\r\n                    return internal::lookup_tables<0>::lookup_attribute_data_1_pure[static_cast<unsigned char>(ch)];\r\n                if (Quote == Ch('\\\"'))\r\n                    return internal::lookup_tables<0>::lookup_attribute_data_2_pure[static_cast<unsigned char>(ch)];\r\n                return 0;       // Should never be executed, to avoid warnings on Comeau\r\n            }\r\n        };\r\n\r\n        // Insert coded character, using UTF8 or 8-bit ASCII\r\n        template<int Flags>\r\n        static void insert_coded_character(Ch *&text, unsigned long code)\r\n        {\r\n            if (Flags & parse_no_utf8)\r\n            {\r\n                // Insert 8-bit ASCII character\r\n                // Todo: possibly verify that code is less than 256 and use replacement char otherwise?\r\n                text[0] = static_cast<unsigned char>(code);\r\n                text += 1;\r\n            }\r\n            else\r\n            {\r\n                // Insert UTF8 sequence\r\n                if (code < 0x80)    // 1 byte sequence\r\n                {\r\n\t                text[0] = static_cast<unsigned char>(code);\r\n                    text += 1;\r\n                }\r\n                else if (code < 0x800)  // 2 byte sequence\r\n                {\r\n\t                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;\r\n\t                text[0] = static_cast<unsigned char>(code | 0xC0);\r\n                    text += 2;\r\n                }\r\n\t            else if (code < 0x10000)    // 3 byte sequence\r\n                {\r\n\t                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;\r\n\t                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;\r\n\t                text[0] = static_cast<unsigned char>(code | 0xE0);\r\n                    text += 3;\r\n                }\r\n\t            else if (code < 0x110000)   // 4 byte sequence\r\n                {\r\n\t                text[3] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;\r\n\t                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;\r\n\t                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;\r\n\t                text[0] = static_cast<unsigned char>(code | 0xF0);\r\n                    text += 4;\r\n                }\r\n                else    // Invalid, only codes up to 0x10FFFF are allowed in Unicode\r\n                {\r\n                    RAPIDXML_PARSE_ERROR(\"invalid numeric character entity\", text);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Skip characters until predicate evaluates to true\r\n        template<class StopPred, int Flags>\r\n        static void skip(Ch *&text)\r\n        {\r\n            Ch *tmp = text;\r\n            while (StopPred::test(*tmp))\r\n                ++tmp;\r\n            text = tmp;\r\n        }\r\n\r\n        // Skip characters until predicate evaluates to true while doing the following:\r\n        // - replacing XML character entity references with proper characters (&apos; &amp; &quot; &lt; &gt; &#...;)\r\n        // - condensing whitespace sequences to single space character\r\n        template<class StopPred, class StopPredPure, int Flags>\r\n        static Ch *skip_and_expand_character_refs(Ch *&text)\r\n        {\r\n            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip\r\n            if (Flags & parse_no_entity_translation && \r\n                !(Flags & parse_normalize_whitespace) &&\r\n                !(Flags & parse_trim_whitespace))\r\n            {\r\n                skip<StopPred, Flags>(text);\r\n                return text;\r\n            }\r\n            \r\n            // Use simple skip until first modification is detected\r\n            skip<StopPredPure, Flags>(text);\r\n\r\n            // Use translation skip\r\n            Ch *src = text;\r\n            Ch *dest = src;\r\n            while (StopPred::test(*src))\r\n            {\r\n                // If entity translation is enabled    \r\n                if (!(Flags & parse_no_entity_translation))\r\n                {\r\n                    // Test if replacement is needed\r\n                    if (src[0] == Ch('&'))\r\n                    {\r\n                        switch (src[1])\r\n                        {\r\n\r\n                        // &amp; &apos;\r\n                        case Ch('a'): \r\n                            if (src[2] == Ch('m') && src[3] == Ch('p') && src[4] == Ch(';'))\r\n                            {\r\n                                *dest = Ch('&');\r\n                                ++dest;\r\n                                src += 5;\r\n                                continue;\r\n                            }\r\n                            if (src[2] == Ch('p') && src[3] == Ch('o') && src[4] == Ch('s') && src[5] == Ch(';'))\r\n                            {\r\n                                *dest = Ch('\\'');\r\n                                ++dest;\r\n                                src += 6;\r\n                                continue;\r\n                            }\r\n                            break;\r\n\r\n                        // &quot;\r\n                        case Ch('q'): \r\n                            if (src[2] == Ch('u') && src[3] == Ch('o') && src[4] == Ch('t') && src[5] == Ch(';'))\r\n                            {\r\n                                *dest = Ch('\"');\r\n                                ++dest;\r\n                                src += 6;\r\n                                continue;\r\n                            }\r\n                            break;\r\n\r\n                        // &gt;\r\n                        case Ch('g'): \r\n                            if (src[2] == Ch('t') && src[3] == Ch(';'))\r\n                            {\r\n                                *dest = Ch('>');\r\n                                ++dest;\r\n                                src += 4;\r\n                                continue;\r\n                            }\r\n                            break;\r\n\r\n                        // &lt;\r\n                        case Ch('l'): \r\n                            if (src[2] == Ch('t') && src[3] == Ch(';'))\r\n                            {\r\n                                *dest = Ch('<');\r\n                                ++dest;\r\n                                src += 4;\r\n                                continue;\r\n                            }\r\n                            break;\r\n\r\n                        // &#...; - assumes ASCII\r\n                        case Ch('#'): \r\n                            if (src[2] == Ch('x'))\r\n                            {\r\n                                unsigned long code = 0;\r\n                                src += 3;   // Skip &#x\r\n                                while (1)\r\n                                {\r\n                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];\r\n                                    if (digit == 0xFF)\r\n                                        break;\r\n                                    code = code * 16 + digit;\r\n                                    ++src;\r\n                                }\r\n                                insert_coded_character<Flags>(dest, code);    // Put character in output\r\n                            }\r\n                            else\r\n                            {\r\n                                unsigned long code = 0;\r\n                                src += 2;   // Skip &#\r\n                                while (1)\r\n                                {\r\n                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];\r\n                                    if (digit == 0xFF)\r\n                                        break;\r\n                                    code = code * 10 + digit;\r\n                                    ++src;\r\n                                }\r\n                                insert_coded_character<Flags>(dest, code);    // Put character in output\r\n                            }\r\n                            if (*src == Ch(';'))\r\n                                ++src;\r\n                            else\r\n                                RAPIDXML_PARSE_ERROR(\"expected ;\", src);\r\n                            continue;\r\n\r\n                        // Something else\r\n                        default:\r\n                            // Ignore, just copy '&' verbatim\r\n                            break;\r\n\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // If whitespace condensing is enabled\r\n                if (Flags & parse_normalize_whitespace)\r\n                {\r\n                    // Test if condensing is needed                 \r\n                    if (whitespace_pred::test(*src))\r\n                    {\r\n                        *dest = Ch(' '); ++dest;    // Put single space in dest\r\n                        ++src;                      // Skip first whitespace char\r\n                        // Skip remaining whitespace chars\r\n                        while (whitespace_pred::test(*src))\r\n                            ++src;\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                // No replacement, only copy character\r\n                *dest++ = *src++;\r\n\r\n            }\r\n\r\n            // Return new end\r\n            text = src;\r\n            return dest;\r\n\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////\r\n        // Internal parsing functions\r\n        \r\n        // Parse BOM, if any\r\n        template<int Flags>\r\n        void parse_bom(Ch *&text)\r\n        {\r\n            // UTF-8?\r\n            if (static_cast<unsigned char>(text[0]) == 0xEF && \r\n                static_cast<unsigned char>(text[1]) == 0xBB && \r\n                static_cast<unsigned char>(text[2]) == 0xBF)\r\n            {\r\n                text += 3;      // Skup utf-8 bom\r\n            }\r\n        }\r\n\r\n        // Parse XML declaration (<?xml...)\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_xml_declaration(Ch *&text)\r\n        {\r\n            // If parsing of declaration is disabled\r\n            if (!(Flags & parse_declaration_node))\r\n            {\r\n                // Skip until end of declaration\r\n                while (text[0] != Ch('?') || text[1] != Ch('>'))\r\n                {\r\n                    if (!text[0])\r\n                        RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                    ++text;\r\n                }\r\n                text += 2;    // Skip '?>'\r\n                return 0;\r\n            }\r\n\r\n            // Create declaration\r\n            xml_node<Ch> *declaration = this->allocate_node(node_declaration);\r\n\r\n            // Skip whitespace before attributes or ?>\r\n            skip<whitespace_pred, Flags>(text);\r\n\r\n            // Parse declaration attributes\r\n            parse_node_attributes<Flags>(text, declaration);\r\n            \r\n            // Skip ?>\r\n            if (text[0] != Ch('?') || text[1] != Ch('>'))\r\n                RAPIDXML_PARSE_ERROR(\"expected ?>\", text);\r\n            text += 2;\r\n            \r\n            return declaration;\r\n        }\r\n\r\n        // Parse XML comment (<!--...)\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_comment(Ch *&text)\r\n        {\r\n            // If parsing of comments is disabled\r\n            if (!(Flags & parse_comment_nodes))\r\n            {\r\n                // Skip until end of comment\r\n                while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))\r\n                {\r\n                    if (!text[0])\r\n                        RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                    ++text;\r\n                }\r\n                text += 3;     // Skip '-->'\r\n                return 0;      // Do not produce comment node\r\n            }\r\n\r\n            // Remember value start\r\n            Ch *value = text;\r\n\r\n            // Skip until end of comment\r\n            while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))\r\n            {\r\n                if (!text[0])\r\n                    RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                ++text;\r\n            }\r\n\r\n            // Create comment node\r\n            xml_node<Ch> *comment = this->allocate_node(node_comment);\r\n            comment->value(value, text - value);\r\n            \r\n            // Place zero terminator after comment value\r\n            if (!(Flags & parse_no_string_terminators))\r\n                *text = Ch('\\0');\r\n            \r\n            text += 3;     // Skip '-->'\r\n            return comment;\r\n        }\r\n\r\n        // Parse DOCTYPE\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_doctype(Ch *&text)\r\n        {\r\n            // Remember value start\r\n            Ch *value = text;\r\n\r\n            // Skip to >\r\n            while (*text != Ch('>'))\r\n            {\r\n                // Determine character type\r\n                switch (*text)\r\n                {\r\n                \r\n                // If '[' encountered, scan for matching ending ']' using naive algorithm with depth\r\n                // This works for all W3C test files except for 2 most wicked\r\n                case Ch('['):\r\n                {\r\n                    ++text;     // Skip '['\r\n                    int depth = 1;\r\n                    while (depth > 0)\r\n                    {\r\n                        switch (*text)\r\n                        {\r\n                            case Ch('['): ++depth; break;\r\n                            case Ch(']'): --depth; break;\r\n                            case 0: RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                        }\r\n                        ++text;\r\n                    }\r\n                    break;\r\n                }\r\n                \r\n                // Error on end of text\r\n                case Ch('\\0'):\r\n                    RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                \r\n                // Other character, skip it\r\n                default:\r\n                    ++text;\r\n\r\n                }\r\n            }\r\n            \r\n            // If DOCTYPE nodes enabled\r\n            if (Flags & parse_doctype_node)\r\n            {\r\n                // Create a new doctype node\r\n                xml_node<Ch> *doctype = this->allocate_node(node_doctype);\r\n                doctype->value(value, text - value);\r\n                \r\n                // Place zero terminator after value\r\n                if (!(Flags & parse_no_string_terminators))\r\n                    *text = Ch('\\0');\r\n\r\n                text += 1;      // skip '>'\r\n                return doctype;\r\n            }\r\n            else\r\n            {\r\n                text += 1;      // skip '>'\r\n                return 0;\r\n            }\r\n\r\n        }\r\n\r\n        // Parse PI\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_pi(Ch *&text)\r\n        {\r\n            // If creation of PI nodes is enabled\r\n            if (Flags & parse_pi_nodes)\r\n            {\r\n                // Create pi node\r\n                xml_node<Ch> *pi = this->allocate_node(node_pi);\r\n\r\n                // Extract PI target name\r\n                Ch *name = text;\r\n                skip<node_name_pred, Flags>(text);\r\n                if (text == name)\r\n                    RAPIDXML_PARSE_ERROR(\"expected PI target\", text);\r\n                pi->name(name, text - name);\r\n                \r\n                // Skip whitespace between pi target and pi\r\n                skip<whitespace_pred, Flags>(text);\r\n\r\n                // Remember start of pi\r\n                Ch *value = text;\r\n                \r\n                // Skip to '?>'\r\n                while (text[0] != Ch('?') || text[1] != Ch('>'))\r\n                {\r\n                    if (*text == Ch('\\0'))\r\n                        RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                    ++text;\r\n                }\r\n\r\n                // Set pi value (verbatim, no entity expansion or whitespace normalization)\r\n                pi->value(value, text - value);     \r\n                \r\n                // Place zero terminator after name and value\r\n                if (!(Flags & parse_no_string_terminators))\r\n                {\r\n                    pi->name()[pi->name_size()] = Ch('\\0');\r\n                    pi->value()[pi->value_size()] = Ch('\\0');\r\n                }\r\n                \r\n                text += 2;                          // Skip '?>'\r\n                return pi;\r\n            }\r\n            else\r\n            {\r\n                // Skip to '?>'\r\n                while (text[0] != Ch('?') || text[1] != Ch('>'))\r\n                {\r\n                    if (*text == Ch('\\0'))\r\n                        RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                    ++text;\r\n                }\r\n                text += 2;    // Skip '?>'\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        // Parse and append data\r\n        // Return character that ends data.\r\n        // This is necessary because this character might have been overwritten by a terminating 0\r\n        template<int Flags>\r\n        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)\r\n        {\r\n            // Backup to contents start if whitespace trimming is disabled\r\n            if (!(Flags & parse_trim_whitespace))\r\n                text = contents_start;     \r\n            \r\n            // Skip until end of data\r\n            Ch *value = text, *end;\r\n            if (Flags & parse_normalize_whitespace)\r\n                end = skip_and_expand_character_refs<text_pred, text_pure_with_ws_pred, Flags>(text);   \r\n            else\r\n                end = skip_and_expand_character_refs<text_pred, text_pure_no_ws_pred, Flags>(text);\r\n\r\n            // Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after >\r\n            if (Flags & parse_trim_whitespace)\r\n            {\r\n                if (Flags & parse_normalize_whitespace)\r\n                {\r\n                    // Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end\r\n                    if (*(end - 1) == Ch(' '))\r\n                        --end;\r\n                }\r\n                else\r\n                {\r\n                    // Backup until non-whitespace character is found\r\n                    while (whitespace_pred::test(*(end - 1)))\r\n                        --end;\r\n                }\r\n            }\r\n            \r\n            // If characters are still left between end and value (this test is only necessary if normalization is enabled)\r\n            // Create new data node\r\n            if (!(Flags & parse_no_data_nodes))\r\n            {\r\n                xml_node<Ch> *data = this->allocate_node(node_data);\r\n                data->value(value, end - value);\r\n                node->append_node(data);\r\n            }\r\n\r\n            // Add data to parent node if no data exists yet\r\n            if (!(Flags & parse_no_element_values)) \r\n                if (*node->value() == Ch('\\0'))\r\n                    node->value(value, end - value);\r\n\r\n            // Place zero terminator after value\r\n            if (!(Flags & parse_no_string_terminators))\r\n            {\r\n                Ch ch = *text;\r\n                *end = Ch('\\0');\r\n                return ch;      // Return character that ends data; this is required because zero terminator overwritten it\r\n            }\r\n\r\n            // Return character that ends data\r\n            return *text;\r\n        }\r\n\r\n        // Parse CDATA\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_cdata(Ch *&text)\r\n        {\r\n            // If CDATA is disabled\r\n            if (Flags & parse_no_data_nodes)\r\n            {\r\n                // Skip until end of cdata\r\n                while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))\r\n                {\r\n                    if (!text[0])\r\n                        RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                    ++text;\r\n                }\r\n                text += 3;      // Skip ]]>\r\n                return 0;       // Do not produce CDATA node\r\n            }\r\n\r\n            // Skip until end of cdata\r\n            Ch *value = text;\r\n            while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))\r\n            {\r\n                if (!text[0])\r\n                    RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                ++text;\r\n            }\r\n\r\n            // Create new cdata node\r\n            xml_node<Ch> *cdata = this->allocate_node(node_cdata);\r\n            cdata->value(value, text - value);\r\n\r\n            // Place zero terminator after value\r\n            if (!(Flags & parse_no_string_terminators))\r\n                *text = Ch('\\0');\r\n\r\n            text += 3;      // Skip ]]>\r\n            return cdata;\r\n        }\r\n        \r\n        // Parse element node\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_element(Ch *&text)\r\n        {\r\n            // Create element node\r\n            xml_node<Ch> *element = this->allocate_node(node_element);\r\n\r\n            // Extract element name\r\n            Ch *name = text;\r\n            skip<node_name_pred, Flags>(text);\r\n            if (text == name)\r\n                RAPIDXML_PARSE_ERROR(\"expected element name\", text);\r\n            element->name(name, text - name);\r\n            \r\n            // Skip whitespace between element name and attributes or >\r\n            skip<whitespace_pred, Flags>(text);\r\n\r\n            // Parse attributes, if any\r\n            parse_node_attributes<Flags>(text, element);\r\n\r\n            // Determine ending type\r\n            if (*text == Ch('>'))\r\n            {\r\n                ++text;\r\n                parse_node_contents<Flags>(text, element);\r\n            }\r\n            else if (*text == Ch('/'))\r\n            {\r\n                ++text;\r\n                if (*text != Ch('>'))\r\n                    RAPIDXML_PARSE_ERROR(\"expected >\", text);\r\n                ++text;\r\n            }\r\n            else\r\n                RAPIDXML_PARSE_ERROR(\"expected >\", text);\r\n\r\n            // Place zero terminator after name\r\n            if (!(Flags & parse_no_string_terminators))\r\n                element->name()[element->name_size()] = Ch('\\0');\r\n\r\n            // Return parsed element\r\n            return element;\r\n        }\r\n\r\n        // Determine node type, and parse it\r\n        template<int Flags>\r\n        xml_node<Ch> *parse_node(Ch *&text)\r\n        {\r\n            // Parse proper node type\r\n            switch (text[0])\r\n            {\r\n\r\n            // <...\r\n            default: \r\n                // Parse and append element node\r\n                return parse_element<Flags>(text);\r\n\r\n            // <?...\r\n            case Ch('?'): \r\n                ++text;     // Skip ?\r\n                if ((text[0] == Ch('x') || text[0] == Ch('X')) &&\r\n                    (text[1] == Ch('m') || text[1] == Ch('M')) && \r\n                    (text[2] == Ch('l') || text[2] == Ch('L')) &&\r\n                    whitespace_pred::test(text[3]))\r\n                {\r\n                    // '<?xml ' - xml declaration\r\n                    text += 4;      // Skip 'xml '\r\n                    return parse_xml_declaration<Flags>(text);\r\n                }\r\n                else\r\n                {\r\n                    // Parse PI\r\n                    return parse_pi<Flags>(text);\r\n                }\r\n            \r\n            // <!...\r\n            case Ch('!'): \r\n\r\n                // Parse proper subset of <! node\r\n                switch (text[1])    \r\n                {\r\n                \r\n                // <!-\r\n                case Ch('-'):\r\n                    if (text[2] == Ch('-'))\r\n                    {\r\n                        // '<!--' - xml comment\r\n                        text += 3;     // Skip '!--'\r\n                        return parse_comment<Flags>(text);\r\n                    }\r\n                    break;\r\n\r\n                // <![\r\n                case Ch('['):\r\n                    if (text[2] == Ch('C') && text[3] == Ch('D') && text[4] == Ch('A') && \r\n                        text[5] == Ch('T') && text[6] == Ch('A') && text[7] == Ch('['))\r\n                    {\r\n                        // '<![CDATA[' - cdata\r\n                        text += 8;     // Skip '![CDATA['\r\n                        return parse_cdata<Flags>(text);\r\n                    }\r\n                    break;\r\n\r\n                // <!D\r\n                case Ch('D'):\r\n                    if (text[2] == Ch('O') && text[3] == Ch('C') && text[4] == Ch('T') && \r\n                        text[5] == Ch('Y') && text[6] == Ch('P') && text[7] == Ch('E') && \r\n                        whitespace_pred::test(text[8]))\r\n                    {\r\n                        // '<!DOCTYPE ' - doctype\r\n                        text += 9;      // skip '!DOCTYPE '\r\n                        return parse_doctype<Flags>(text);\r\n                    }\r\n\r\n                }   // switch\r\n\r\n                // Attempt to skip other, unrecognized node types starting with <!\r\n                ++text;     // Skip !\r\n                while (*text != Ch('>'))\r\n                {\r\n                    if (*text == 0)\r\n                        RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n                    ++text;\r\n                }\r\n                ++text;     // Skip '>'\r\n                return 0;   // No node recognized\r\n\r\n            }\r\n        }\r\n\r\n        // Parse contents of the node - children, data etc.\r\n        template<int Flags>\r\n        void parse_node_contents(Ch *&text, xml_node<Ch> *node)\r\n        {\r\n            // For all children and text\r\n            while (1)\r\n            {\r\n                // Skip whitespace between > and node contents\r\n                Ch *contents_start = text;      // Store start of node contents before whitespace is skipped\r\n                skip<whitespace_pred, Flags>(text);\r\n                Ch next_char = *text;\r\n\r\n            // After data nodes, instead of continuing the loop, control jumps here.\r\n            // This is because zero termination inside parse_and_append_data() function\r\n            // would wreak havoc with the above code.\r\n            // Also, skipping whitespace after data nodes is unnecessary.\r\n            after_data_node:    \r\n                \r\n                // Determine what comes next: node closing, child node, data node, or 0?\r\n                switch (next_char)\r\n                {\r\n                \r\n                // Node closing or child node\r\n                case Ch('<'):\r\n                    if (text[1] == Ch('/'))\r\n                    {\r\n                        // Node closing\r\n                        text += 2;      // Skip '</'\r\n                        if (Flags & parse_validate_closing_tags)\r\n                        {\r\n                            // Skip and validate closing tag name\r\n                            Ch *closing_name = text;\r\n                            skip<node_name_pred, Flags>(text);\r\n                            if (!internal::compare(node->name(), node->name_size(), closing_name, text - closing_name, true))\r\n                                RAPIDXML_PARSE_ERROR(\"invalid closing tag name\", text);\r\n                        }\r\n                        else\r\n                        {\r\n                            // No validation, just skip name\r\n                            skip<node_name_pred, Flags>(text);\r\n                        }\r\n                        // Skip remaining whitespace after node name\r\n                        skip<whitespace_pred, Flags>(text);\r\n                        if (*text != Ch('>'))\r\n                            RAPIDXML_PARSE_ERROR(\"expected >\", text);\r\n                        ++text;     // Skip '>'\r\n                        return;     // Node closed, finished parsing contents\r\n                    }\r\n                    else\r\n                    {\r\n                        // Child node\r\n                        ++text;     // Skip '<'\r\n                        if (xml_node<Ch> *child = parse_node<Flags>(text))\r\n                            node->append_node(child);\r\n                    }\r\n                    break;\r\n\r\n                // End of data - error\r\n                case Ch('\\0'):\r\n                    RAPIDXML_PARSE_ERROR(\"unexpected end of data\", text);\r\n\r\n                // Data node\r\n                default:\r\n                    next_char = parse_and_append_data<Flags>(node, text, contents_start);\r\n                    goto after_data_node;   // Bypass regular processing after data nodes\r\n\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Parse XML attributes of the node\r\n        template<int Flags>\r\n        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)\r\n        {\r\n            // For all attributes \r\n            while (attribute_name_pred::test(*text))\r\n            {\r\n                // Extract attribute name\r\n                Ch *name = text;\r\n                ++text;     // Skip first character of attribute name\r\n                skip<attribute_name_pred, Flags>(text);\r\n                if (text == name)\r\n                    RAPIDXML_PARSE_ERROR(\"expected attribute name\", name);\r\n\r\n                // Create new attribute\r\n                xml_attribute<Ch> *attribute = this->allocate_attribute();\r\n                attribute->name(name, text - name);\r\n                node->append_attribute(attribute);\r\n\r\n                // Skip whitespace after attribute name\r\n                skip<whitespace_pred, Flags>(text);\r\n\r\n                // Skip =\r\n                if (*text != Ch('='))\r\n                    RAPIDXML_PARSE_ERROR(\"expected =\", text);\r\n                ++text;\r\n\r\n                // Add terminating zero after name\r\n                if (!(Flags & parse_no_string_terminators))\r\n                    attribute->name()[attribute->name_size()] = 0;\r\n\r\n                // Skip whitespace after =\r\n                skip<whitespace_pred, Flags>(text);\r\n\r\n                // Skip quote and remember if it was ' or \"\r\n                Ch quote = *text;\r\n                if (quote != Ch('\\'') && quote != Ch('\"'))\r\n                    RAPIDXML_PARSE_ERROR(\"expected ' or \\\"\", text);\r\n                ++text;\r\n\r\n                // Extract attribute value and expand char refs in it\r\n                Ch *value = text, *end;\r\n                const int AttFlags = Flags & ~parse_normalize_whitespace;   // No whitespace normalization in attributes\r\n                if (quote == Ch('\\''))\r\n                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('\\'')>, attribute_value_pure_pred<Ch('\\'')>, AttFlags>(text);\r\n                else\r\n                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('\"')>, attribute_value_pure_pred<Ch('\"')>, AttFlags>(text);\r\n                \r\n                // Set attribute value\r\n                attribute->value(value, end - value);\r\n                \r\n                // Make sure that end quote is present\r\n                if (*text != quote)\r\n                    RAPIDXML_PARSE_ERROR(\"expected ' or \\\"\", text);\r\n                ++text;     // Skip quote\r\n\r\n                // Add terminating zero after value\r\n                if (!(Flags & parse_no_string_terminators))\r\n                    attribute->value()[attribute->value_size()] = 0;\r\n\r\n                // Skip whitespace after attribute value\r\n                skip<whitespace_pred, Flags>(text);\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    //! \\cond internal\r\n    namespace internal\r\n    {\r\n\r\n        // Whitespace (space \\n \\r \\t)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  // 0\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1\r\n             1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 3\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 9\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E\r\n             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F\r\n        };\r\n\r\n        // Node name (anything but space \\n \\r \\t / > ? \\0)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Text (i.e. PCDATA) (anything but < \\0)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_text[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Text (i.e. PCDATA) that does not require processing when ws normalization is disabled \r\n        // (anything but < \\0 &)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled\r\n        // (anything but < \\0 & space \\n \\r \\t)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Attribute name (anything but space \\n \\r \\t / < > = ? ! \\0)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Attribute data with single quote (anything but ' \\0)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Attribute data with single quote that does not require processing (anything but ' \\0 &)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Attribute data with double quote (anything but \" \\0)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Attribute data with double quote that does not require processing (anything but \" \\0 &)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1\r\n             1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E\r\n             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F\r\n        };\r\n\r\n        // Digits (dec and hex, 255 denotes end of numeric character reference)\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_digits[256] = \r\n        {\r\n          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 0\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 1\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 2\r\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  // 3\r\n           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 4\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 5\r\n           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 6\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 7\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 8\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 9\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // A\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // B\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // C\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // D\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // E\r\n           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   // F\r\n        };\r\n    \r\n        // Upper case conversion\r\n        template<int Dummy>\r\n        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] = \r\n        {\r\n          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F\r\n           0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   // 0\r\n           16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   // 1\r\n           32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   // 2\r\n           48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   // 3\r\n           64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 4\r\n           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   // 5\r\n           96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 6\r\n           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  // 7\r\n           128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  // 8\r\n           144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  // 9\r\n           160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  // A\r\n           176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  // B\r\n           192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  // C\r\n           208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  // D\r\n           224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  // E\r\n           240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   // F\r\n        };\r\n    }\r\n    //! \\endcond\r\n\r\n}\r\n\r\n// Undefine internal macros\r\n#undef RAPIDXML_PARSE_ERROR\r\n\r\n// On MSVC, restore warnings state\r\n#ifdef _MSC_VER\r\n    #pragma warning(pop)\r\n#endif\r\n\r\n#endif\r\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"MoveConditions.h\"\r\n#include \"MoveDefinition.h\"\r\n\r\nclass Board;\r\nclass Distance;\r\nclass EndOfGame;\r\nclass Game;\r\nclass PieceType;\r\nclass Player;\r\nclass StateConditionGroup;\r\nclass TurnOrder;\r\nclass TurnRepeat;\r\n\r\n\r\nnamespace rapidxml {\r\n\ttemplate<class Ch> class xml_node;\r\n\ttemplate<class Ch> class xml_document;\r\n}\r\n\r\ntypedef std::map<char*, direction_t, char_cmp> dirLookup_t;\r\ntypedef std::pair<char*, direction_t> dirLookupEntry_t;\r\n\r\nclass GameParser\r\n{\r\npublic:\r\n#ifdef NO_SVG\r\n\tGame* Parse(char *definition);\r\n#else\r\n\tGame* Parse(char *definition, std::string *svgOutput);\r\n#endif\r\n\tGameParser() {}\r\n\t~GameParser() {}\r\n\t\r\nprivate:\r\n#ifdef NO_SVG\r\n\tbool ParseCells(Board *board, rapidxml::xml_node<char> *boardNode);\r\n\tbool ParsePieceTypes(rapidxml::xml_node<char> *piecesNode);\r\n\tchar *ParsePieceType(rapidxml::xml_node<char> *piecesNode, PieceType *type);\r\n\tbool ParsePlayers(rapidxml::xml_node<char> *playersNode);\r\n#else\r\n\tbool ParseCellsAndGenerateSVG(Board *board, rapidxml::xml_node<char> *boardNode, rapidxml::xml_document<char> *svgDoc);\r\n\tbool ParsePieceTypes(rapidxml::xml_node<char> *piecesNode, rapidxml::xml_node<char> *svgDefsNode);\r\n\tchar *ParsePieceType(rapidxml::xml_node<char> *piecesNode, rapidxml::xml_node<char> *svgDefsNode, PieceType *type);\r\n\tbool ParsePlayers(rapidxml::xml_node<char> *playersNode, rapidxml::xml_document<char> *svgDoc);\r\n#endif\r\n\tbool ParseDirections(Board *board, rapidxml::xml_node<char> *dirsNode);\r\n\tMoveDefinition *ParseMove(rapidxml::xml_node<char> *moveNode, bool isTopLevel);\r\n\r\n\tMoveDefinition *ParseMove_Slide(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_Leap(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_Hop(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_Shoot(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_MoveLike(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_Sequence(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_Repeat(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_WhenPossible(rapidxml::xml_node<char> *moveNode);\r\n\tMoveDefinition *ParseMove_ReferencePiece(rapidxml::xml_node<char> *moveNode);\r\n\tMoveConditionGroup *ParseMoveConditions(rapidxml::xml_node<char> *node, Condition::GroupType_t type);\r\n\tStateConditionGroup *ParseStateConditions(rapidxml::xml_node<char> *node, Condition::GroupType_t type);\r\n\tCondition::NumericComparison_t ParseNumericComparison(char *value);\r\n\r\n\tDistance *ParseDistance(char *val);\r\n\tMoveDefinition::When_t ParseWhen(char *val);\r\n\tPlayer::Relationship_t ParseRelationship(char *val);\r\n\t\r\n\tbool ParseRules(rapidxml::xml_node<char> *rulesNode);\r\n\tTurnOrder *ParseTurnOrder(rapidxml::xml_node<char> *node);\r\n\tbool ParseTurnRepeat(TurnRepeat *repeat, rapidxml::xml_node<char> *repeatNode);\r\n\tEndOfGame *ParseEndOfGame(rapidxml::xml_node<char> *rootNode);\r\n\tPlayer *GetPlayerByName(char *name);\r\n\r\n\tunsigned int LookupDirection(char *dirName);\r\n\r\n\tunsigned int maxDirection, allDirections;\r\n\tdirLookup_t directionLookups;\r\n\tstd::map<char*, std::tuple<PieceType*, char*>, char_cmp> pieceTypesByName;\r\n\tstd::map<char*, Cell*, char_cmp> cellsByRef;\r\n\tstd::map<ReferencePiece*, char*> referencePieceTypeQueue;\r\n#ifndef NO_SVG\r\n\tstd::list<std::tuple<PieceType*, char*, char*>> pieceAppearances;\r\n#endif\r\n\r\n\tGame *game;\r\n};\r\n\r\n","#ifndef RAPIDXML_PRINT_HPP_INCLUDED\r\n#define RAPIDXML_PRINT_HPP_INCLUDED\r\n\r\n// Copyright (C) 2006, 2009 Marcin Kalicinski\r\n// Version 1.13\r\n// Revision $DateTime: 2009/05/13 01:46:17 $\r\n//! \\file rapidxml_print.hpp This file contains rapidxml printer implementation\r\n\r\n#include \"rapidxml.hpp\"\r\n\r\n// Only include streams if not disabled\r\n#ifndef RAPIDXML_NO_STREAMS\r\n    #include <ostream>\r\n    #include <iterator>\r\n#endif\r\n\r\nnamespace rapidxml\r\n{\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    // Printing flags\r\n\r\n    const int print_no_indenting = 0x1;   //!< Printer flag instructing the printer to suppress indenting of XML. See print() function.\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    // Internal\r\n\r\n    //! \\cond internal\r\n    namespace internal\r\n    {\r\n        \r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Internal character operations\r\n    \r\n        // Copy characters from given range to given output iterator\r\n        template<class OutIt, class Ch>\r\n        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)\r\n        {\r\n            while (begin != end)\r\n                *out++ = *begin++;\r\n            return out;\r\n        }\r\n        \r\n        // Copy characters from given range to given output iterator and expand\r\n        // characters into references (&lt; &gt; &apos; &quot; &amp;)\r\n        template<class OutIt, class Ch>\r\n        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)\r\n        {\r\n            while (begin != end)\r\n            {\r\n                if (*begin == noexpand)\r\n                {\r\n                    *out++ = *begin;    // No expansion, copy character\r\n                }\r\n                else\r\n                {\r\n                    switch (*begin)\r\n                    {\r\n                    case Ch('<'):\r\n                        *out++ = Ch('&'); *out++ = Ch('l'); *out++ = Ch('t'); *out++ = Ch(';');\r\n                        break;\r\n                    case Ch('>'): \r\n                        *out++ = Ch('&'); *out++ = Ch('g'); *out++ = Ch('t'); *out++ = Ch(';');\r\n                        break;\r\n                    case Ch('\\''): \r\n                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('p'); *out++ = Ch('o'); *out++ = Ch('s'); *out++ = Ch(';');\r\n                        break;\r\n                    case Ch('\"'): \r\n                        *out++ = Ch('&'); *out++ = Ch('q'); *out++ = Ch('u'); *out++ = Ch('o'); *out++ = Ch('t'); *out++ = Ch(';');\r\n                        break;\r\n                    case Ch('&'): \r\n                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('m'); *out++ = Ch('p'); *out++ = Ch(';'); \r\n                        break;\r\n                    default:\r\n                        *out++ = *begin;    // No expansion, copy character\r\n                    }\r\n                }\r\n                ++begin;    // Step to next character\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // Fill given output iterator with repetitions of the same character\r\n        template<class OutIt, class Ch>\r\n        inline OutIt fill_chars(OutIt out, int n, Ch ch)\r\n        {\r\n            for (int i = 0; i < n; ++i)\r\n                *out++ = ch;\r\n            return out;\r\n        }\r\n\r\n        // Find character\r\n        template<class Ch, Ch ch>\r\n        inline bool find_char(const Ch *begin, const Ch *end)\r\n        {\r\n            while (begin != end)\r\n                if (*begin++ == ch)\r\n                    return true;\r\n            return false;\r\n        }\r\n\r\n        ///////////////////////////////////////////////////////////////////////////\r\n        // Internal printing operations\r\n\t\t\r\n\t\ttemplate<class OutIt, class Ch>\r\n\t\tOutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);\r\n\r\n        // Print children of the node                               \r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            for (xml_node<Ch> *child = node->first_node(); child; child = child->next_sibling())\r\n                out = print_node(out, child, flags, indent);\r\n            return out;\r\n        }\r\n\r\n        // Print attributes of the node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int flags)\r\n        {\r\n            for (xml_attribute<Ch> *attribute = node->first_attribute(); attribute; attribute = attribute->next_attribute())\r\n            {\r\n                if (attribute->name() && attribute->value())\r\n                {\r\n                    // Print attribute name\r\n                    *out = Ch(' '), ++out;\r\n                    out = copy_chars(attribute->name(), attribute->name() + attribute->name_size(), out);\r\n                    *out = Ch('='), ++out;\r\n                    // Print attribute value using appropriate quote type\r\n                    if (find_char<Ch, Ch('\"')>(attribute->value(), attribute->value() + attribute->value_size()))\r\n                    {\r\n                        *out = Ch('\\''), ++out;\r\n                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('\"'), out);\r\n                        *out = Ch('\\''), ++out;\r\n                    }\r\n                    else\r\n                    {\r\n                        *out = Ch('\"'), ++out;\r\n                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('\\''), out);\r\n                        *out = Ch('\"'), ++out;\r\n                    }\r\n                }\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // Print data node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            assert(node->type() == node_data);\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);\r\n            return out;\r\n        }\r\n\r\n        // Print data node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            assert(node->type() == node_cdata);\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            *out = Ch('<'); ++out;\r\n            *out = Ch('!'); ++out;\r\n            *out = Ch('['); ++out;\r\n            *out = Ch('C'); ++out;\r\n            *out = Ch('D'); ++out;\r\n            *out = Ch('A'); ++out;\r\n            *out = Ch('T'); ++out;\r\n            *out = Ch('A'); ++out;\r\n            *out = Ch('['); ++out;\r\n            out = copy_chars(node->value(), node->value() + node->value_size(), out);\r\n            *out = Ch(']'); ++out;\r\n            *out = Ch(']'); ++out;\r\n            *out = Ch('>'); ++out;\r\n            return out;\r\n        }\r\n\r\n        // Print element node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            assert(node->type() == node_element);\r\n\r\n            // Print element name and attributes, if any\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            *out = Ch('<'), ++out;\r\n            out = copy_chars(node->name(), node->name() + node->name_size(), out);\r\n            out = print_attributes(out, node, flags);\r\n            \r\n            // If node is childless\r\n            if (node->value_size() == 0 && !node->first_node())\r\n            {\r\n                // Print childless node tag ending\r\n                *out = Ch('/'), ++out;\r\n                *out = Ch('>'), ++out;\r\n            }\r\n            else\r\n            {\r\n                // Print normal node tag ending\r\n                *out = Ch('>'), ++out;\r\n\r\n                // Test if node contains a single data node only (and no other nodes)\r\n                xml_node<Ch> *child = node->first_node();\r\n                if (!child)\r\n                {\r\n                    // If node has no children, only print its value without indenting\r\n                    out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);\r\n                }\r\n                else if (child->next_sibling() == 0 && child->type() == node_data)\r\n                {\r\n                    // If node has a sole data child, only print its value without indenting\r\n                    out = copy_and_expand_chars(child->value(), child->value() + child->value_size(), Ch(0), out);\r\n                }\r\n                else\r\n                {\r\n                    // Print all children with full indenting\r\n                    if (!(flags & print_no_indenting))\r\n                        *out = Ch('\\n'), ++out;\r\n                    out = print_children(out, node, flags, indent + 1);\r\n                    if (!(flags & print_no_indenting))\r\n                        out = fill_chars(out, indent, Ch('\\t'));\r\n                }\r\n\r\n                // Print node end\r\n                *out = Ch('<'), ++out;\r\n                *out = Ch('/'), ++out;\r\n                out = copy_chars(node->name(), node->name() + node->name_size(), out);\r\n                *out = Ch('>'), ++out;\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // Print declaration node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            // Print declaration start\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            *out = Ch('<'), ++out;\r\n            *out = Ch('?'), ++out;\r\n            *out = Ch('x'), ++out;\r\n            *out = Ch('m'), ++out;\r\n            *out = Ch('l'), ++out;\r\n\r\n            // Print attributes\r\n            out = print_attributes(out, node, flags);\r\n            \r\n            // Print declaration end\r\n            *out = Ch('?'), ++out;\r\n            *out = Ch('>'), ++out;\r\n            \r\n            return out;\r\n        }\r\n\r\n        // Print comment node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            assert(node->type() == node_comment);\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            *out = Ch('<'), ++out;\r\n            *out = Ch('!'), ++out;\r\n            *out = Ch('-'), ++out;\r\n            *out = Ch('-'), ++out;\r\n            out = copy_chars(node->value(), node->value() + node->value_size(), out);\r\n            *out = Ch('-'), ++out;\r\n            *out = Ch('-'), ++out;\r\n            *out = Ch('>'), ++out;\r\n            return out;\r\n        }\r\n\r\n        // Print doctype node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            assert(node->type() == node_doctype);\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            *out = Ch('<'), ++out;\r\n            *out = Ch('!'), ++out;\r\n            *out = Ch('D'), ++out;\r\n            *out = Ch('O'), ++out;\r\n            *out = Ch('C'), ++out;\r\n            *out = Ch('T'), ++out;\r\n            *out = Ch('Y'), ++out;\r\n            *out = Ch('P'), ++out;\r\n            *out = Ch('E'), ++out;\r\n            *out = Ch(' '), ++out;\r\n            out = copy_chars(node->value(), node->value() + node->value_size(), out);\r\n            *out = Ch('>'), ++out;\r\n            return out;\r\n        }\r\n\r\n        // Print pi node\r\n        template<class OutIt, class Ch>\r\n        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n        {\r\n            assert(node->type() == node_pi);\r\n            if (!(flags & print_no_indenting))\r\n                out = fill_chars(out, indent, Ch('\\t'));\r\n            *out = Ch('<'), ++out;\r\n            *out = Ch('?'), ++out;\r\n            out = copy_chars(node->name(), node->name() + node->name_size(), out);\r\n            *out = Ch(' '), ++out;\r\n            out = copy_chars(node->value(), node->value() + node->value_size(), out);\r\n            *out = Ch('?'), ++out;\r\n            *out = Ch('>'), ++out;\r\n            return out;\r\n        }\r\n\r\n\t\t// Print node\r\n\t\ttemplate<class OutIt, class Ch>\r\n\t\tinline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)\r\n\t\t{\r\n\t\t\t// Print proper node type\r\n\t\t\tswitch (node->type())\r\n\t\t\t{\r\n\r\n\t\t\t\t// Document\r\n\t\t\tcase node_document:\r\n\t\t\t\tout = print_children(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Element\r\n\t\t\tcase node_element:\r\n\t\t\t\tout = print_element_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Data\r\n\t\t\tcase node_data:\r\n\t\t\t\tout = print_data_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// CDATA\r\n\t\t\tcase node_cdata:\r\n\t\t\t\tout = print_cdata_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Declaration\r\n\t\t\tcase node_declaration:\r\n\t\t\t\tout = print_declaration_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Comment\r\n\t\t\tcase node_comment:\r\n\t\t\t\tout = print_comment_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Doctype\r\n\t\t\tcase node_doctype:\r\n\t\t\t\tout = print_doctype_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Pi\r\n\t\t\tcase node_pi:\r\n\t\t\t\tout = print_pi_node(out, node, flags, indent);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Unknown\r\n\t\t\tdefault:\r\n\t\t\t\tassert(0);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// If indenting not disabled, add line break after node\r\n\t\t\tif (!(flags & print_no_indenting))\r\n\t\t\t\t*out = Ch('\\n'), ++out;\r\n\r\n\t\t\t// Return modified iterator\r\n\t\t\treturn out;\r\n\t\t}\r\n    }\r\n    //! \\endcond\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Printing\r\n\r\n    //! Prints XML to given output iterator.\r\n    //! \\param out Output iterator to print to.\r\n    //! \\param node Node to be printed. Pass xml_document to print entire document.\r\n    //! \\param flags Flags controlling how XML is printed.\r\n    //! \\return Output iterator pointing to position immediately after last character of printed text.\r\n    template<class OutIt, class Ch> \r\n    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)\r\n    {\r\n        return internal::print_node(out, &node, flags, 0);\r\n    }\r\n\r\n#ifndef RAPIDXML_NO_STREAMS\r\n\r\n    //! Prints XML to given output stream.\r\n    //! \\param out Output stream to print to.\r\n    //! \\param node Node to be printed. Pass xml_document to print entire document.\r\n    //! \\param flags Flags controlling how XML is printed.\r\n    //! \\return Output stream.\r\n    template<class Ch> \r\n    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)\r\n    {\r\n        print(std::ostream_iterator<Ch>(out), node, flags);\r\n        return out;\r\n    }\r\n\r\n    //! Prints formatted XML to given output stream. Uses default printing flags. Use print() function to customize printing process.\r\n    //! \\param out Output stream to print to.\r\n    //! \\param node Node to be printed.\r\n    //! \\return Output stream.\r\n    template<class Ch> \r\n    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)\r\n    {\r\n        return print(out, node);\r\n    }\r\n\r\n#endif\r\n\r\n}\r\n\r\n#endif\r\n","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n\r\nclass Piece;\r\n\r\n#define CELL_REF_LENGTH 10\r\n\r\nclass Cell\r\n{\r\npublic:\r\n\tCell();\r\n\t~Cell();\r\n\r\n\tvoid AddLink(direction_t dir, Cell* destination);\r\n\tCell* FollowLink(direction_t dir);\r\n\tchar *GetName() { return reference; }\r\n\tPiece *GetPiece() { return piece; }\r\nprivate:\r\n\tchar reference[CELL_REF_LENGTH];\r\n\r\n\tPiece *piece;\r\n\tstd::map<direction_t, Cell*> links;\r\n\t\r\n\tint coordX, coordY;\r\n\r\n\tfriend class MoveStep;\r\n\tfriend class GameParser;\r\n};\r\n\r\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n  \n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <intsize_t I, class T> class tuple_element; // undefined\ntemplate <intsize_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t _Ip, class ..._Tp>\n  using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <intsize_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <intsize_t I, class... T>\n    typename const tuple_element<I, tuple<T...>>::type &\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <intsize_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr T1 const& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// tuple_size\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<tuple<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\n// tuple_element\n\ntemplate <size_t _Ip, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, tuple<_Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Ip, class ..._Tp>\nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;\n#endif\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp, bool=is_empty<_Hp>::value\n#if __has_feature(is_final)\n                                 && !__is_final(_Hp)\n#endif\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)) ||\n                        (is_rvalue_reference<_Hp>::value &&\n                         !is_lvalue_reference<_Tp>::value),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <bool ...> struct __all;\n\ntemplate <>\nstruct __all<>\n{\n    static const bool value = true;\n};\n\ntemplate <bool _B0, bool ... _Bp>\nstruct __all<_B0, _Bp...>\n{\n    static const bool value = _B0 && __all<_Bp...>::value;\n};\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value)) \n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_constructible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value &&\n                         !__tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value,\n                         bool\n                      >::type =false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              class = typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple>::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple>::value &&\n                         !__tuple_convertible<_Tuple, tuple>::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n// get by type\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_helper;\n\n// -- find exactly one\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_checker {\n    static constexpr size_t value = _Idx;\n//  Check the rest of the list to make sure there's only one\n    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, \"type can only occur once in type list\" );\n    };\n\n\ntemplate <typename _T1, size_t _Idx>\nstruct __find_exactly_one_t_helper <_T1, _Idx> {\n    static constexpr size_t value = -1;\n    };\n\ntemplate <typename _T1, size_t _Idx, typename _Head, typename... _Args>\nstruct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {\n    static constexpr size_t value =\n        std::conditional<\n            std::is_same<_T1, _Head>::value,\n            __find_exactly_one_t_checker<_T1, _Idx,   _Args...>,\n            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>\n        >::type::value;\n    };\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t {\n    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;\n    static_assert ( value != -1, \"type not found in type list\" );\n    };\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_less<_Ip-1>()(__x, __y) ||\n             (!__tuple_less<_Ip-1>()(__y, __x) && _VSTD::get<_Ip-1>(__x) < _VSTD::get<_Ip-1>(__y));\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","#pragma once\r\n\r\n#if _DEBUG\r\n\t#define _CRTDBG_MAP_ALLOC\r\n\t#include <stdlib.h>\r\n\t#include <crtdbg.h>\r\n\t#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)\r\n\t#define new DEBUG_NEW\r\n#else\r\n\t#include <stdlib.h>\r\n#endif\r\n\r\n#ifdef EMSCRIPTEN\r\n#include <emscripten.h>\r\n#endif\r\n\r\n#include <list>\r\n#include <map>\r\n#include <set>\r\n#include <string>\r\n\r\nvoid ReportError(const char *msg, ...);\r\n\r\n#define NO_SVG\r\n\r\n// if some new implementation wishes to use SVG output, then simply duplicate this logic\r\n#ifdef EMSCRIPTEN\r\n#undef NO_SVG\r\n#endif\r\n\r\nstruct char_cmp {\r\n\tbool operator () (const char *a, const char *b) const\r\n\t{\r\n\t\treturn strcmp(a, b) < 0;\r\n\t}\r\n};\r\n\r\n#define DIRECTION_FORWARD 1\r\n#define DIRECTION_SAME 2\r\n#define FIRST_ABSOLUTE_DIRECTION 4\r\n\r\ntypedef unsigned int direction_t;\r\n\r\n#define FOR_EACH_DIR_IN_SET(dirs, i) for (direction_t i = FIRST_ABSOLUTE_DIRECTION; i <= dirs; i*=2) if ((dirs & i) != 0)","#include \"GameState.h\"\r\n#include \"Game.h\"\r\n#include \"Move.h\"\r\n#include \"MoveDefinition.h\"\r\n#include \"Piece.h\"\r\n\r\nGameState::GameState(Game *game, Player *currentPlayer, int turnNumber)\r\n{\r\n\tthis->game = game;\r\n\tthis->currentPlayer = currentPlayer;\r\n\tthis->turnNumber = turnNumber;\r\n}\r\n\r\n\r\nGameState::~GameState()\r\n{\r\n\t\r\n}\r\n\r\n\r\nstd::list<Move*> *GameState::DeterminePossibleMoves()\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\tCalculateMovesForPlayer(currentPlayer, moves);\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *GameState::DetermineThreatMoves()\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\r\n\tfor (auto it = game->players.begin(); it != game->players.end(); it++)\r\n\t{\r\n\t\tPlayer *opponent = *it;\r\n\t\tif (currentPlayer->GetRelationship(opponent) != Player::Enemy)\r\n\t\t\tcontinue;\r\n\r\n\t\tCalculateMovesForPlayer(opponent, moves);\r\n\t}\r\n\r\n\treturn moves;\r\n}\r\n\r\n\r\n// determine notation for each move (done all at once to ensure they are unique)\r\nstd::list<Move*> *GameState::PrepareMovesForTurn()\r\n{\r\n\tstd::map<char*, Move*, char_cmp> movesByNotation;\r\n\tstd::list<Move*> *possibleMoves = DeterminePossibleMoves();\r\n\r\n\tfor (auto it = possibleMoves->begin(); it != possibleMoves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n\r\n        // ensure unique notation\r\n\t\tfor (int detailLevel = 1; detailLevel <= MAX_NOTATION_DETAIL; detailLevel++)\r\n\t\t{\r\n\t\t\tchar *notation = move->DetermineNotation(detailLevel);\r\n\r\n\t\t\tauto existingIt = movesByNotation.find(notation);\r\n            if (existingIt != movesByNotation.end())\r\n\t\t\t{\r\n                // another move uses this notation. Calculate a new, more-specific notation for that other move.\r\n\t\t\t\tMove *other = existingIt->second;\r\n\t\t\t\tchar *otherNot = other->DetermineNotation(detailLevel + 1);\r\n\r\n\t\t\t\t// only save the other move with the more specific notation if we haven't done so already\r\n\t\t\t\tif (movesByNotation.find(otherNot) == movesByNotation.end())\r\n\t\t\t\t\tmovesByNotation.insert(std::pair<char*, Move*>(otherNot, other));\r\n            }\r\n            else\r\n\t\t\t{\r\n\t\t\t\tmovesByNotation.insert(std::pair<char*, Move*>(notation, move));\r\n                break;\r\n\t\t\t}\r\n        }\r\n\t}\r\n\r\n    return possibleMoves;\r\n}\r\n\r\n\r\nvoid GameState::CalculateMovesForPlayer(Player *player, std::list<Move*> *output)\r\n{\r\n\tstd::set<Piece*> pieces(player->piecesOnBoard);\r\n\tfor (auto it = pieces.begin(); it != pieces.end(); it++)\r\n\t{\r\n\t\tPiece *piece = *it;\r\n\t\tMove *moveTemplate = new Move(piece->GetOwner(), this, piece, piece->GetPosition());\r\n\r\n        // get promotion possibilities\r\n        //piece.pieceType.promotionOpportunities.each(function (op) {\r\n        //    if (!op.mandatory && op.type != PromotionType.EndOfMove && op.isAvailable(moveTemplate, this.game))\r\n        //        op.options.each(function (option) {\r\n        //            output.push(new Promotion(piece.ownerPlayer, piece, option, this.moveNumber, op.type == PromotionType.CountsAsMove));\r\n        //        });\r\n        //});\r\n\r\n        // and then get move possibilities\r\n\t\tauto moves = piece->GetType()->GetMoves();\r\n\t\tfor (auto it = moves.begin(); it != moves.end(); it++)\r\n\t\t{\r\n\t\t\tMoveDefinition *moveDef = *it;\r\n\t\t\tstd::list<Move*> *possibilities = moveDef->DetermineNextSteps(moveTemplate, piece, 0);\r\n\t\t\tfor (auto it2 = possibilities->begin(); it2 != possibilities->end(); it2++)\r\n\t\t\t{\r\n\t\t\t\tMove *move = *it2;\r\n        \r\n\t\t\t\tif (game->GetEndOfGame()->AnyIllegalMovesSpecified())\r\n\t\t\t\t{\r\n                    GameState *subsequentState = move->Perform(false);\r\n\t\t\t\t\tEndOfGame::CheckType_t result = game->GetEndOfGame()->CheckEndOfTurn(this, move);\r\n                    move->Reverse(false);\r\n\t\t\t\t\tdelete subsequentState;\r\n\r\n\t\t\t\t\tif (result == EndOfGame::IllegalMove)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdelete move;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n                }\r\n\r\n                output->push_back(move);\r\n            }\r\n\t\t\tdelete possibilities;\r\n\t\t}\r\n\r\n\t\tdelete moveTemplate;\r\n\t}\r\n\t\r\n    // now look at each held piece\r\n    //if (player.piecesHeld.length == 0)\r\n    //    continue;\r\n    \r\n    //pieces = player.piecesHeld.slice();\r\n    //this.game.board.cells.items.each(function (coord, cell) {\r\n    //    if (cell.value != Board.CellType.Normal)\r\n    //        return;\r\n    \r\n    //    for (var i = 0; i < pieces.length; i++) {\r\n    //        var move = new Move(piece.ownerPlayer, this, piece, null);\r\n    //        move.addStep(MoveStep.CreateDrop(piece, coord, piece.ownerPlayer));\r\n\r\n    //        if (this.game.rules.dropPiecesWhen == null || this.game.rules.dropPiecesWhen.isSatisfied(move, this))\r\n    //            output.push(move);\r\n    //    }\r\n    //});\r\n}","#include \"Definitions.h\"\r\n\r\n#include <stdarg.h>\r\n#include <stdio.h>\r\n#include <utility>\r\n#include <string.h>\r\n#include \"ai.h\"\r\n#include \"Game.h\"\r\n#include \"GameParser.h\"\r\n#include \"GameState.h\"\r\n#include \"TurnOrder.h\"\r\n\r\n#ifdef EMSCRIPTEN\r\n#define EXPOSE_METHOD extern \"C\" EMSCRIPTEN_KEEPALIVE \r\n#else\r\n#define EXPOSE_METHOD extern \"C\" __declspec(dllexport)\r\n#endif\r\n\r\nGame *game = 0;\r\n\r\n#ifndef NO_SVG\r\nstd::string *boardSVG = 0;\r\n#endif\r\n\r\nEXPOSE_METHOD\r\nbool Initialize(char* definition)\r\n{\r\n\tif (game != 0)\r\n\t\tdelete game;\r\n\r\n#ifndef NO_SVG\r\n\tif (boardSVG != 0)\r\n\t\tdelete boardSVG;\r\n\r\n\tboardSVG = new std::string();\r\n#endif\r\n\r\n\tGameParser *parser = new GameParser();\r\n#ifdef NO_SVG\r\n\tgame = parser->Parse(definition);\r\n#else\r\n\tgame = parser->Parse(definition, boardSVG);\r\n#endif\r\n\tdelete parser;\r\n\r\n\tif (game == 0)\r\n\t\treturn false;\r\n\r\n#ifdef CONSOLE\r\n\tprintf(\"Definition parsed successfully\\n\");\r\n#endif\r\n\r\n\tgame->Start();\r\n\treturn true;\r\n}\r\n\r\n#ifndef NO_SVG\r\nEXPOSE_METHOD\r\nconst char *GetBoardSVG()\r\n{\r\n\treturn boardSVG->c_str();\r\n}\r\n#endif\r\n\r\nEXPOSE_METHOD\r\nbool SetPlayerLocal(const char *playerName)\r\n{\r\n\tauto players = game->GetPlayers();\r\n\tfor (auto it = players.begin(); it != players.end(); it++)\r\n\t{\r\n\t\tPlayer *p = *it;\r\n\t\tif (strcmp(p->GetName(), playerName) == 0)\r\n\t\t{\r\n\t\t\tp->SetType(Player::Local);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tReportError(\"Player \\\"%s\\\" not found, cannot set as local\\n\", playerName);\r\n\treturn false;\r\n}\r\n\r\nEXPOSE_METHOD\r\nbool SetPlayerRemote(const char *playerName)\r\n{\r\n\tauto players = game->GetPlayers();\r\n\tfor (auto it = players.begin(); it != players.end(); it++)\r\n\t{\r\n\t\tPlayer *p = *it;\r\n\t\tif (strcmp(p->GetName(), playerName) == 0)\r\n\t\t{\r\n\t\t\tp->SetType(Player::Remote);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tReportError(\"Player \\\"%s\\\" not found, cannot set as remote\\n\", playerName);\r\n\treturn false;\r\n}\r\n\r\nEXPOSE_METHOD\r\nbool SetPlayerAI(const char *playerName, const char *aiName)\r\n{\r\n\tPlayerAI *ai;\r\n\tif (strcmp(aiName, \"random\") == 0)\r\n\t\tai = new AI_Random(game);\r\n\telse if (strcmp(aiName, \"random capture\") == 0)\r\n\t\tai = new AI_Random(game);\r\n\telse if (strcmp(aiName, \"alpha beta\") == 0)\r\n\t\tai = new AI_AlphaBeta(game, 3);\r\n\telse\r\n\t{\r\n\t\tReportError(\"AI \\\"%s\\\" not found, cannot set player \\\"%s\\\" as AI\\n\", aiName, playerName);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tauto players = game->GetPlayers();\r\n\tfor (auto it = players.begin(); it != players.end(); it++)\r\n\t{\r\n\t\tPlayer *p = *it;\r\n\t\tif (strcmp(p->GetName(), playerName) == 0)\r\n\t\t{\r\n\t\t\tp->SetAI(ai);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tdelete ai;\r\n\tReportError(\"Player \\\"%s\\\" not found, cannot set as AI\\n\", playerName);\r\n\treturn false;\r\n}\r\n\r\nEXPOSE_METHOD\r\nvoid Shutdown()\r\n{\r\n\tdelete game;\r\n\tgame = 0;\r\n}\r\n\r\nEXPOSE_METHOD\r\nstd::string *ListPossibleMoves()\r\n{\r\n\tstd::string *output = new std::string(\"Possible moves:\\n\");\r\n\r\n\tauto moves = game->GetPossibleMoves();\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n\t\toutput->append(move->GetNotation());\r\n\t\toutput->append(\"\\n\");\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\nEXPOSE_METHOD\r\nint PerformMove(const char *notation)\r\n{\r\n\t// See if this is a valid move, and if so, perform it. If not, return -1.\r\n\t// If the game has finished, return 0, otherwise, return 1.\r\n\r\n\tauto moves = game->GetPossibleMoves();\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n\t\tif (strcmp(notation, move->GetNotation()) == 0)\r\n\t\t{\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tauto result = game->PerformMove(move);\r\n\t\t\t\tswitch (result)\r\n\t\t\t\t{\r\n\t\t\t\tcase Game::GameComplete:\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\tcase Game::MoveComplete:\r\n\t\t\t\t\tif (game->GetCurrentState()->GetCurrentPlayer()->GetType() == Player::AI)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmove = game->GetCurrentState()->GetCurrentPlayer()->GetAI()->SelectMove();\r\n\t\t\t\t\t\tif (move == 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tReportError(\"AI failed to select a move\\n\");\r\n\t\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn 1;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tReportError(\"An error occurred performing a move\\n\");\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t} while (true);\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n\r\nvoid ReportError(const char *msg, ...)\r\n{\r\n\tprintf(\"Error: \");\r\n\r\n\tva_list args;\r\n\tva_start(args, msg);\r\n\tvprintf(msg, args);\r\n\tva_end(args);\r\n\r\n#ifdef EMSCRIPTEN\r\n\t// todo: show a popup dialog to indicate that the game has encountered an error\r\n#endif\r\n}\r\n\r\n#ifdef EMSCRIPTEN\r\nnamespace rapidxml\r\n{\r\n\tvoid parse_error_handler(const char *what, void *where) { ReportError(what); printf(\"\\n\"); abort(); }\r\n}\r\n#endif","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"EndOfGame.h\"\r\n\r\nclass Game;\r\nclass GameState;\r\nclass Move;\r\n\r\nclass PlayerAI\r\n{\r\npublic:\r\n\tPlayerAI(Game *game) { this->game = game; }\r\n\tvirtual ~PlayerAI() {\t}\r\n\r\n\tvirtual Move *SelectMove() = 0;\r\nprotected:\r\n\tGame *game;\r\n};\r\n\r\n\r\nclass AI_Random : public PlayerAI\r\n{\r\npublic:\r\n\tAI_Random(Game *game) : PlayerAI(game) { }\r\n\tvirtual Move *SelectMove();\r\n};\r\n\r\n\r\nclass AI_RandomCapture : public AI_Random\r\n{\r\npublic:\r\n\tAI_RandomCapture(Game *game) : AI_Random(game) { }\r\n\tvirtual Move *SelectMove();\r\n};\r\n\r\n\r\nclass AI_AlphaBeta : public PlayerAI\r\n{\r\npublic:\r\n\tAI_AlphaBeta(Game *game, int ply) : PlayerAI(game) { this->ply = ply; }\r\n\tvirtual Move *SelectMove();\r\nprivate:\r\n\tdouble FindBestScore(GameState *state, double alpha, double beta, int depth);\r\n\tdouble GetMoveScore(Move *move, double alpha, double beta, int depth);\r\n\tdouble GetScoreForEndOfGame(EndOfGame::CheckType_t result);\r\n\tdouble EvaluateBoard(GameState *state);\r\n\tint ply;\r\n};","#include \"Move.h\"\r\n#include \"MoveStep.h\"\r\n#include \"Game.h\"\r\n#include \"GameState.h\"\r\n#include \"TurnOrder.h\"\r\n\r\nMove::Move(Player *player, GameState *prevState, Piece *piece, Cell *startPos)\r\n{\r\n\tthis->player = player;\r\n\tthis->prevState = prevState;\r\n\tthis->piece = piece;\r\n\tthis->startPos = startPos;\r\n}\r\n\r\n\r\nMove::~Move()\r\n{\r\n\twhile (!steps.empty())\r\n\t\tdelete steps.front(), steps.pop_front();\r\n}\r\n\r\n\r\nMove *Move::Clone()\r\n{\r\n\tMove *move = new Move(player, prevState, piece, startPos);\r\n\tfor (auto it = steps.begin(); it != steps.end(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tmove->AddStep(new MoveStep(*step));\r\n\t}\r\n\r\n\tmove->references = references;\r\n\r\n\treturn move;\r\n}\r\n\r\n\r\nGameState *Move::Perform(bool updateDisplay)\r\n{\r\n\tfor (auto it = steps.begin(); it != steps.end(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\r\n\t\tif (!step->Perform(updateDisplay)) // move failed, roll back\r\n\t\t{\r\n\t\t\tif (it == steps.begin())\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\tbool reversing = true;\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tit--;\r\n\t\t\t\treversing = it != steps.begin();\r\n\r\n\t\t\t\tstep = *it;\r\n\t\t\t\tif (!step->Reverse(updateDisplay))\r\n\t\t\t\t{\r\n\t\t\t\t\tReportError(\"Encountered an error rolling back a failed move\\n\");\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t} while (reversing);\r\n\t\t\t\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tprevPieceMoveTurn = piece->lastMoveTurn;\r\n\tpiece->lastMoveTurn = prevState->turnNumber;\r\n\tpiece->moveNumber++;\r\n\r\n\treturn new GameState(prevState->game, prevState->game->GetTurnOrder()->GetNextPlayer(), prevState->turnNumber + 1);\r\n}\r\n\r\n\r\nbool Move::Reverse(bool updateDisplay)\r\n{\r\n\tfor (auto it = steps.rbegin(); it != steps.rend(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\r\n\t\tif (!step->Reverse(updateDisplay)) // move failed, roll back\r\n\t\t{\r\n\t\t\tif (it == steps.rbegin())\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tbool reversing = true;\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tit--;\r\n\t\t\t\treversing = it != steps.rbegin();\r\n\r\n\t\t\t\tstep = *it;\r\n\t\t\t\tif (!step->Perform(updateDisplay))\r\n\t\t\t\t{\r\n\t\t\t\t\tReportError(\"Encountered an error rolling back a failed move reversal\\n\");\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} while (reversing);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tpiece->lastMoveTurn = prevPieceMoveTurn;\r\n    piece->moveNumber--;\r\n\tprevState->game->GetTurnOrder()->StepBackward();\r\n\treturn true;\r\n}\r\n\r\n\r\nchar *Move::DetermineNotation(int detailLevel)\r\n{\r\n\tint numPlayers = prevState->game->players.size();\r\n\tint displayNumber = (prevState->turnNumber + numPlayers + 1) / numPlayers - 1;\r\n\tsprintf(notation, \"%i\", displayNumber);\r\n\r\n\tif (prevState->turnNumber % numPlayers == 1) // first player's move\r\n\t\tstrcat(notation, \".  \");\r\n\telse\r\n\t\tstrcat(notation, \"...\");\r\n\r\n    switch (detailLevel)\r\n\t{\r\n        case 1:\r\n\t\t\tstrcat(notation, piece->pieceType->notation);\r\n\t\t\tif (IsCapture())\r\n\t\t\t\tstrcat(notation, \"x\");\r\n\t\t\tstrcat(notation, GetEndPos()->GetName());\r\n            break;\r\n        case 2:\r\n\t\t\tstrcat(notation, piece->pieceType->notation);\r\n\t\t\tstrcat(notation, startPos->GetName());\r\n\t\t\tif (IsCapture())\r\n\t\t\t\tstrcat(notation, \"x\");\r\n\t\t\tstrcat(notation, GetEndPos()->GetName());\r\n            break;\r\n        default:\r\n\t\t\tstrcat(notation, piece->pieceType->notation);\r\n\r\n\t\t\tchar strID[8];\r\n\t\t\tsprintf(strID, \"(%i)\", piece->GetID());\r\n\t\t\tstrcat(notation, strID);\r\n\r\n\t\t\tstrcat(notation, startPos->GetName());\r\n\t\t\tif (IsCapture())\r\n\t\t\t\tstrcat(notation, \"x\");\r\n\t\t\tstrcat(notation, GetEndPos()->GetName());\r\n            break;\r\n    }\r\n\t\r\n    // add promotion letter onto the end\r\n    /*var promotion = GetPromotionType();\r\n    if (promotion != 0)\r\n        strcat(notation, promotion->notation;*/\r\n\r\n    // add a plus to the end if its check. add a hash if its checkmate.\r\n\r\n    // how to account for castling? some special moves simply need to specify their own special notation, i guess...\r\n\r\n\treturn notation;\r\n}\r\n\r\n\r\nvoid Move::AddPieceReference(Piece *piece, const char *ref)\r\n{\r\n\tauto it = references.find(ref);\r\n\tif (it != references.end())\r\n\t\tit->second = piece;\r\n\telse\r\n\t\treferences.insert(std::pair<const char*, Piece*>(ref, piece));\r\n}\r\n\r\n\r\nPiece *Move::GetPieceByReference(const char *ref)\r\n{\r\n\tif (strcmp(ref, \"self\") == 0)\r\n\t\treturn piece; // this is needed only by conditions code, it looks like. If they could be made to handle \"self\" separately, this wouldn't be needed.\r\n\r\n\tauto it = references.find(ref);\r\n\tif (it == references.end())\r\n\t\treturn 0;\r\n\treturn it->second;\r\n}\r\n\r\n\r\nCell *Move::GetEndPos()\r\n{\r\n\tfor (auto it = steps.rbegin(); it != steps.rend(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tif (step->GetPiece() == piece && step->toState == Piece::OnBoard)\r\n\t\t\treturn step->toPos;\r\n\t}\r\n\r\n\t// if this piece doesn't move, consider other pieces that it might move or capture\r\n\tfor (auto it = steps.rbegin(); it != steps.rend(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tif (step->toState == Piece::OnBoard)\r\n\t\t\treturn step->toPos;\r\n\t\telse if (step->fromState == Piece::OnBoard)\r\n\t\t\treturn step->fromPos;\r\n\t}\r\n\r\n    return startPos;\r\n}\r\n\r\n\r\nstd::list<Cell*> Move::GetAllPositions()\r\n{\r\n\tstd::list<Cell*> allPositions;\r\n\r\n\tfor (auto it = steps.begin(); it != steps.end(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tif (step->GetPiece() == piece && step->toState == Piece::OnBoard)\r\n\t\t\tallPositions.push_back(step->toPos);\r\n\t}\r\n\r\n\treturn allPositions;\r\n}\r\n\r\n\r\nbool Move::IsCapture()\r\n{\r\n\tfor (auto it = steps.begin(); it != steps.end(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tif (step->GetPiece() != piece && step->toState != Piece::OnBoard)\r\n\t\t\treturn true;\r\n\t}\r\n    return false;\r\n}\r\n\r\n\r\nbool Move::WouldCapture(Cell* target)\r\n{\r\n\tfor (auto it = steps.begin(); it != steps.end(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tif (step->GetPiece() != piece && step->toState != Piece::OnBoard && step->fromState == Piece::OnBoard && step->fromPos == target)\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\nPieceType *Move::GetPromotionType()\r\n{\r\n\tfor (auto it = steps.rbegin(); it != steps.rend(); it++)\r\n\t{\r\n\t\tMoveStep *step = *it;\r\n\t\tif (step->GetPiece() == piece && step->toType != step->fromType)\r\n\t\t\treturn step->toType;\r\n\t}\r\n\treturn 0;\r\n}","#pragma once\r\n\r\n#include \"Definitions.h\"\r\n#include \"Piece.h\"\r\n\r\nclass Game;\r\n\r\nclass MoveStep\r\n{\r\npublic:\r\n\tMoveStep(Piece *piece);\r\n\t~MoveStep();\r\n\r\n\tbool Perform(bool updateDisplay);\r\n\tbool Reverse(bool updateDisplay);\r\n\r\n\tPiece *GetPiece() { return piece; }\r\n\tdirection_t GetDirection() { return direction; }\r\n\tPiece::State_t GetFromState() { return fromState; }\r\n\tPiece::State_t GetToState() { return toState; }\r\n\tCell *GetFromPosition() { return fromPos; }\r\n\tCell *GetToPosition() { return toPos; }\r\n\r\n\tstatic MoveStep *CreateMove(Piece *piece, Cell *from, Cell *to, direction_t dir, int distance);\r\n\tstatic MoveStep *CreateCapture(Piece *piece, Cell *from, Player *capturedBy, bool toHeld);\r\n\tstatic MoveStep *CreateDrop(Piece *piece, Cell *to, Player *droppedBy);\r\n\tstatic MoveStep *CreatePromotion(Piece *piece, PieceType *fromType, PieceType *toType);\r\n\tstatic MoveStep *CreateSteal(Piece *piece, Player *fromOwner, Player *toOwner);\r\n\r\nprivate:\r\n\tbool Pickup(Piece::State_t state, Player *stateOwner, Cell *pos, Player *owner, PieceType *type);\r\n\tvoid Place(Piece::State_t state, Player *stateOwner, Cell *pos, Player *owner, PieceType *type);\r\n\tvoid UpdateDisplay();\r\n\r\n\tstatic int nextID;\r\n\tint uniqueID;\r\n\r\n\tPiece *piece;\r\n\tdirection_t direction;\r\n\tint distance;\r\n\tPiece::State_t fromState, toState;\r\n\tCell *fromPos, *toPos;\r\n\tPlayer *fromOwner, *toOwner;\r\n\tPlayer *fromStateOwner, *toStateOwner;\r\n\tPieceType *fromType, *toType;\r\n\r\n\tfriend class Distance;\r\n\tfriend class Move;\r\n};\r\n\r\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TUPLE\n#define _LIBCPP___TUPLE\n\n#include <__config>\n#include <cstddef>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__tuple_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY tuple_size;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<const _Tp>\n    : public tuple_size<_Tp> {};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<volatile _Tp>\n    : public tuple_size<_Tp> {};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<const volatile _Tp>\n    : public tuple_size<_Tp> {};\n\ntemplate <size_t _Ip, class _Tp> class _LIBCPP_TYPE_VIS_ONLY tuple_element;\n\ntemplate <size_t _Ip, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, const _Tp>\n{\npublic:\n    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;\n};\n\ntemplate <size_t _Ip, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, volatile _Tp>\n{\npublic:\n    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;\n};\n\ntemplate <size_t _Ip, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, const volatile _Tp>\n{\npublic:\n    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;\n};\n\ntemplate <class ..._Tp> class _LIBCPP_TYPE_VIS_ONLY tuple;\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY pair;\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\n\ntemplate <class _Tp> struct __tuple_like : false_type {};\n\ntemplate <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};\ntemplate <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};\ntemplate <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};\n\ntemplate <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};\ntemplate <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};\ntemplate <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};\n\ntemplate <size_t _Ip, class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class _T1, class _T2>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&\nget(array<_Tp, _Size>&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nget(const array<_Tp, _Size>&) _NOEXCEPT;\n\ntemplate <size_t _Ip, class _Tp, size_t _Size>\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nget(array<_Tp, _Size>&&) _NOEXCEPT;\n\n// __make_tuple_indices\n\ntemplate <size_t...> struct __tuple_indices {};\n\ntemplate <size_t _Sp, class _IntTuple, size_t _Ep>\nstruct __make_indices_imp;\n\ntemplate <size_t _Sp, size_t ..._Indices, size_t _Ep>\nstruct __make_indices_imp<_Sp, __tuple_indices<_Indices...>, _Ep>\n{\n    typedef typename __make_indices_imp<_Sp+1, __tuple_indices<_Indices..., _Sp>, _Ep>::type type;\n};\n\ntemplate <size_t _Ep, size_t ..._Indices>\nstruct __make_indices_imp<_Ep, __tuple_indices<_Indices...>, _Ep>\n{\n    typedef __tuple_indices<_Indices...> type;\n};\n\ntemplate <size_t _Ep, size_t _Sp = 0>\nstruct __make_tuple_indices\n{\n    static_assert(_Sp <= _Ep, \"__make_tuple_indices input error\");\n    typedef typename __make_indices_imp<_Sp, __tuple_indices<>, _Ep>::type type;\n};\n\n// __tuple_types\n\ntemplate <class ..._Tp> struct __tuple_types {};\n\ntemplate <size_t _Ip>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, __tuple_types<> >\n{\npublic:\n    static_assert(_Ip == 0, \"tuple_element index out of range\");\n    static_assert(_Ip != 0, \"tuple_element index out of range\");\n};\n\ntemplate <class _Hp, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, __tuple_types<_Hp, _Tp...> >\n{\npublic:\n    typedef _Hp type;\n};\n\ntemplate <size_t _Ip, class _Hp, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, __tuple_types<_Hp, _Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip-1, __tuple_types<_Tp...> >::type type;\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<__tuple_types<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\ntemplate <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};\n\n// __make_tuple_types\n\n// __make_tuple_types<_Tuple<_Types...>, _Ep, _Sp>::type is a\n// __tuple_types<_Types...> using only those _Types in the range [_Sp, _Ep).\n// _Sp defaults to 0 and _Ep defaults to tuple_size<_Tuple>.  If _Tuple is a\n// lvalue_reference type, then __tuple_types<_Types&...> is the result.\n\ntemplate <class _TupleTypes, class _Tp, size_t _Sp, size_t _Ep>\nstruct __make_tuple_types_imp;\n\ntemplate <class ..._Types, class _Tp, size_t _Sp, size_t _Ep>\nstruct __make_tuple_types_imp<__tuple_types<_Types...>, _Tp, _Sp, _Ep>\n{\n    typedef typename remove_reference<_Tp>::type _Tpr;\n    typedef typename __make_tuple_types_imp<__tuple_types<_Types...,\n                                            typename conditional<is_lvalue_reference<_Tp>::value,\n                                                typename tuple_element<_Sp, _Tpr>::type&,\n                                                typename tuple_element<_Sp, _Tpr>::type>::type>,\n                                            _Tp, _Sp+1, _Ep>::type type;\n};\n\ntemplate <class ..._Types, class _Tp, size_t _Ep>\nstruct __make_tuple_types_imp<__tuple_types<_Types...>, _Tp, _Ep, _Ep>\n{\n    typedef __tuple_types<_Types...> type;\n};\n\ntemplate <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value, size_t _Sp = 0>\nstruct __make_tuple_types\n{\n    static_assert(_Sp <= _Ep, \"__make_tuple_types input error\");\n    typedef typename __make_tuple_types_imp<__tuple_types<>, _Tp, _Sp, _Ep>::type type;\n};\n\n// __tuple_convertible\n\ntemplate <bool, class _Tp, class _Up>\nstruct __tuple_convertible_imp : public false_type {};\n\ntemplate <class _Tp0, class ..._Tp, class _Up0, class ..._Up>\nstruct __tuple_convertible_imp<true, __tuple_types<_Tp0, _Tp...>, __tuple_types<_Up0, _Up...> >\n    : public integral_constant<bool,\n                               is_convertible<_Tp0, _Up0>::value &&\n                               __tuple_convertible_imp<true, __tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {};\n\ntemplate <>\nstruct __tuple_convertible_imp<true, __tuple_types<>, __tuple_types<> >\n    : public true_type {};\n\ntemplate <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,\n                                bool = __tuple_like<_Up>::value>\nstruct __tuple_convertible\n    : public false_type {};\n\ntemplate <class _Tp, class _Up>\nstruct __tuple_convertible<_Tp, _Up, true, true>\n    : public __tuple_convertible_imp<tuple_size<typename remove_reference<_Tp>::type>::value ==\n                                     tuple_size<_Up>::value,\n             typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type>\n{};\n\n// __tuple_constructible\n\ntemplate <bool, class _Tp, class _Up>\nstruct __tuple_constructible_imp : public false_type {};\n\ntemplate <class _Tp0, class ..._Tp, class _Up0, class ..._Up>\nstruct __tuple_constructible_imp<true, __tuple_types<_Tp0, _Tp...>, __tuple_types<_Up0, _Up...> >\n    : public integral_constant<bool,\n                               is_constructible<_Up0, _Tp0>::value &&\n                               __tuple_constructible_imp<true, __tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {};\n\ntemplate <>\nstruct __tuple_constructible_imp<true, __tuple_types<>, __tuple_types<> >\n    : public true_type {};\n\ntemplate <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,\n                                bool = __tuple_like<_Up>::value>\nstruct __tuple_constructible\n    : public false_type {};\n\ntemplate <class _Tp, class _Up>\nstruct __tuple_constructible<_Tp, _Up, true, true>\n    : public __tuple_constructible_imp<tuple_size<typename remove_reference<_Tp>::type>::value ==\n                                     tuple_size<_Up>::value,\n             typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type>\n{};\n\n// __tuple_assignable\n\ntemplate <bool, class _Tp, class _Up>\nstruct __tuple_assignable_imp : public false_type {};\n\ntemplate <class _Tp0, class ..._Tp, class _Up0, class ..._Up>\nstruct __tuple_assignable_imp<true, __tuple_types<_Tp0, _Tp...>, __tuple_types<_Up0, _Up...> >\n    : public integral_constant<bool,\n                               is_assignable<_Up0&, _Tp0>::value &&\n                               __tuple_assignable_imp<true, __tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {};\n\ntemplate <>\nstruct __tuple_assignable_imp<true, __tuple_types<>, __tuple_types<> >\n    : public true_type {};\n\ntemplate <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,\n                                bool = __tuple_like<_Up>::value>\nstruct __tuple_assignable\n    : public false_type {};\n\ntemplate <class _Tp, class _Up>\nstruct __tuple_assignable<_Tp, _Up, true, true>\n    : public __tuple_assignable_imp<tuple_size<typename remove_reference<_Tp>::type>::value ==\n                                    tuple_size<_Up>::value,\n             typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type>\n{};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP___TUPLE\n","#include \"MoveConditions.h\"\r\n#include \"Board.h\"\r\n#include \"Game.h\"\r\n#include \"GameState.h\"\r\n#include \"Move.h\"\r\n#include \"MoveStep.h\"\r\n\r\nbool Condition::ResolveComparison(NumericComparison_t type, int val1, int val2)\r\n{\r\n\tswitch (type) {\r\n\tcase NumericComparison_t::Equals:\r\n\t\treturn val1 == val2;\r\n\tcase NumericComparison_t::LessThan:\r\n\t\treturn val1 < val2;\r\n\tcase NumericComparison_t::GreaterThan:\r\n\t\treturn val1 > val2;\r\n\tcase NumericComparison_t::LessThanOrEquals:\r\n\t\treturn val1 <= val2;\r\n\tcase NumericComparison_t::GreaterThanOrEquals:\r\n\t\treturn val1 >= val2;\r\n\tdefault:\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n\r\nMoveConditionGroup::MoveConditionGroup(GroupType_t type)\r\n{\r\n\tthis->type = type;\r\n}\r\n\r\n\r\nMoveConditionGroup::~MoveConditionGroup()\r\n{\r\n\tstd::list<MoveCondition*>::iterator it = elements.begin();\r\n\twhile (it != elements.end())\r\n\t{\r\n\t\tdelete (*it);\r\n\t\tit++;\r\n\t}\r\n}\r\n\r\n\r\nbool MoveConditionGroup::IsSatisfied(Move *move)\r\n{\r\n\tbool any = false;\r\n\r\n\tswitch (type) {\r\n\tcase GroupType_t::And:\r\n\t\tfor (auto it = elements.begin(); it != elements.end(); it++)\r\n            if (!(*it)->IsSatisfied(move))\r\n                return false;\r\n        return true;\r\n    case GroupType_t::Or:\r\n\t\tfor (auto it = elements.begin(); it != elements.end(); it++)\r\n\t\t\tif ((*it)->IsSatisfied(move))\r\n                return true;\r\n        return false;\r\n    case GroupType_t::Nand:\r\n\t\tfor (auto it = elements.begin(); it != elements.end(); it++)\r\n\t\t\tif (!(*it)->IsSatisfied(move))\r\n                return true;\r\n        return false;\r\n    case GroupType_t::Nor:\r\n\t\tfor (auto it = elements.begin(); it != elements.end(); it++)\r\n\t\t\tif ((*it)->IsSatisfied(move))\r\n                return false;\r\n        return true;\r\n    case GroupType_t::Xor:\r\n\t\tfor (auto it = elements.begin(); it != elements.end(); it++)\r\n\t\t{\r\n\t\t\tif ((*it)->IsSatisfied(move))\r\n\t\t\t{\r\n\t\t\t\tif (any)\r\n\t\t\t\t\treturn false;\r\n\t\t\t\telse\r\n\t\t\t\t\tany = true;\r\n\t\t\t}\r\n\t\t}\r\n        return any;\r\n\tdefault: // there are no other types!\r\n\t\treturn false;\r\n    }\r\n}\r\n\r\n\r\nbool MoveCondition_Type::IsSatisfied(Move *move)\r\n{\r\n\tPiece *other = move->GetPieceByReference(pieceRef);\r\n\tif (other == 0)\r\n\t{\r\n\t\tReportError(\"Referenced piece not found for \\\"type\\\" move condition: %s\\n\", pieceRef);\r\n\t\treturn false;\r\n\t}\r\n\treturn other->TypeMatches(type);\r\n}\r\n\r\n\r\nbool MoveCondition_Owner::IsSatisfied(Move *move)\r\n{\r\n\tPiece *other = move->GetPieceByReference(pieceRef);\r\n\tif (other == 0)\r\n\t{\r\n\t\tReportError(\"Referenced piece not found for \\\"owner\\\" move condition: %s\\n\", pieceRef);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (relationship == Player::Any)\r\n\t\treturn true;\r\n\r\n\treturn relationship == move->GetPlayer()->GetRelationship(other->GetOwner());\r\n}\r\n\r\n\r\nbool MoveCondition_MoveNumber::IsSatisfied(Move *move)\r\n{\r\n\tPiece *other = move->GetPieceByReference(pieceRef);\r\n\tif (other == 0)\r\n\t{\r\n\t\tReportError(\"Referenced piece not found for \\\"move number\\\" move condition: %s\\n\", pieceRef);\r\n\t\treturn false;\r\n\t}\r\n\r\n    return ResolveComparison(comparison, other->GetMoveNumber(), number);\r\n}\r\n\r\n\r\nbool MoveCondition_MaxDist::IsSatisfied(Move *move)\r\n{\r\n\tPiece *other = move->GetPieceByReference(pieceRef);\r\n\tif (other == 0)\r\n\t{\r\n\t\tReportError(\"Referenced piece not found for \\\"max dist\\\" move condition: %s\\n\", pieceRef);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tauto steps = move->GetSteps();\r\n\tMoveStep *previousStep = steps.empty() ? 0 : *steps.rbegin();\r\n\tdirection_t dirs = move->GetPlayer()->ResolveDirections(dir, previousStep != 0 && previousStep->GetDirection() != 0 ? previousStep->GetDirection() : move->GetPlayer()->GetForwardDirection());\r\n\tBoard *board = move->GetPrevState()->GetGame()->GetBoard();\r\n\r\n\tFOR_EACH_DIR_IN_SET(dirs, dir)\r\n\t{\r\n        int maxDist = board->GetMaxDistance(other->GetPosition(), dir);\r\n        if (ResolveComparison(comparison, maxDist, number))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool MoveCondition_TurnsSinceLastMove::IsSatisfied(Move *move)\r\n{\r\n\tPiece *other = move->GetPieceByReference(pieceRef);\r\n\tif (other == 0)\r\n\t{\r\n\t\tReportError(\"Referenced piece not found for \\\"turns since last move\\\" move condition: %s\\n\", pieceRef);\r\n\t\treturn false;\r\n\t}\r\n\r\n    return ResolveComparison(comparison, move->GetPrevState()->GetTurnNumber() - other->GetLastMoveTurn(), number);\r\n}\r\n\r\n\r\nbool MoveCondition_Threatened::alreadyChecking = false; // when performing moves to check this, don't go performing other moves for other \"threatened\" checks, or things get messy\r\nbool MoveCondition_Threatened::IsSatisfied(Move *move)\r\n{\r\n\tif (alreadyChecking)\r\n\t\treturn true;\r\n\r\n\talreadyChecking = true;\r\n\tbool retVal = CheckSatisfied(move);\r\n\talreadyChecking = false;\r\n\r\n\treturn retVal;\r\n}\r\n\r\nbool MoveCondition_Threatened::CheckSatisfied(Move *move)\r\n{\r\n\tMoveStep *step = *move->GetSteps().rbegin(); // all steps except the current one will already have been performed\r\n\r\n\tif (start && step->GetFromState() == Piece::OnBoard)\r\n\t{\r\n\t\tbool threatened = IsThreatened(move->GetPrevState(), step->GetFromPosition());\r\n\t\tif (threatened != value)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\tif (end && step->GetToState() == Piece::OnBoard)\r\n\t{\r\n\t\tif (!step->Perform(false))\r\n\t\t\treturn false;\r\n\r\n\t\tbool threatened = IsThreatened(move->GetPrevState(), step->GetToPosition());\r\n\t\tstep->Reverse(false);\r\n\r\n\t\tif (threatened != value)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool MoveCondition_Threatened::IsThreatened(GameState *state, Cell *position)\r\n{\r\n\tauto moves = state->DetermineThreatMoves();\r\n\t\r\n\tbool retVal = false;\r\n\tfor (auto it = moves->begin(); it != moves->end(); it++)\r\n\t{\r\n\t\tMove *move = *it;\r\n\t\tif (move->WouldCapture(position))\r\n\t\t{\r\n\t\t\tretVal = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\twhile (!moves->empty())\r\n\t\tdelete moves->front(), moves->pop_front();\r\n\tdelete moves;\r\n\t\r\n\treturn retVal;\r\n}","#include <utility>\r\n#include \"Board.h\"\r\n#include \"Game.h\"\r\n#include \"GameState.h\"\r\n#include \"Move.h\"\r\n#include \"MoveConditions.h\"\r\n#include \"MoveDefinition.h\"\r\n#include \"MoveStep.h\"\r\n\r\nMoveDefinition::MoveDefinition(const char *pieceRef, MoveConditionGroup *conditions, When_t when, direction_t direction)\r\n{\r\n\tstrcpy(this->pieceRef, pieceRef);\r\n\tthis->conditions = conditions;\r\n\tthis->direction = direction;\r\n\tthis->when = when;\r\n\tthis->moveSelf = strcmp(pieceRef, \"self\") == 0;\r\n}\r\n\r\n\r\nMoveDefinition::~MoveDefinition()\r\n{\r\n\tif (conditions != 0)\r\n\t\tdelete conditions;\r\n}\r\n\r\n\r\nstd::list<Move*> *Slide::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\r\n\t// some steps will specify a different piece to act upon, rather than the piece being moved\r\n\tif (!moveSelf)\r\n\t{\r\n\t\tpiece = baseMove->GetPieceByReference(pieceRef);\r\n\t\tif (piece == 0)\r\n\t\t{\r\n\t\t\tReportError(\"Referenced piece not found for slide move: %s\\n\", pieceRef);\r\n\t\t\treturn moves;\r\n\t\t}\r\n\t}\r\n\r\n\tPlayer *player = baseMove->GetPlayer();\r\n\tGame *game = player->GetGame();\r\n\tdirection_t dirs = player->ResolveDirections(direction, previousStep != 0 && previousStep->GetDirection() != 0 ? previousStep->GetDirection() : player->GetForwardDirection());\r\n\r\n\tFOR_EACH_DIR_IN_SET(dirs, dir)\r\n\t{\r\n\t\tint boardMaxDist = game->GetBoard()->GetMaxDistance(piece->GetPosition(), dir);\r\n\t\tint minDist = distance->GetValue(previousStep, boardMaxDist);\r\n\t\tint maxDist = distance->GetMaxValue(distanceMax, previousStep, boardMaxDist);\r\n\t\tCell *cell = piece->GetPosition();\r\n\t\r\n        for (int dist = 1; dist <= maxDist; dist++)\r\n\t\t{\r\n\t\t\tcell = cell->FollowLink(dir);\r\n            if (cell == 0)\r\n                break;\r\n\r\n            Piece *target = cell->GetPiece();\r\n            if (dist >= minDist)\r\n\t\t\t{\r\n\t\t\t\tMoveStep *captureStep = 0;\r\n\t\t\t\tif (target == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (when == Capturing)\r\n\t\t\t\t\t\tcontinue; // needs to be a capture for this slide to be valid, and there is no piece here. But there might be pieces beyond this one.\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (when == Moving)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\telse if (piece->CanCapture(target))\r\n\t\t\t\t\t\tcaptureStep = MoveStep::CreateCapture(target, cell, piece->GetOwner(), game->GetHoldCapturedPieces());\r\n                    else\r\n                        break; // cannot capture this piece. Slides cannot pass over pieces, so there can be no more valid slides in this direction.\r\n\t\t\t\t}\r\n\r\n                Move *move = baseMove->Clone();\r\n                if (captureStep != 0)\r\n\t\t\t\t{\r\n                    move->AddStep(captureStep);\r\n                    move->AddPieceReference(target, \"target\");\r\n                }\r\n\r\n                move->AddStep(MoveStep::CreateMove(piece, piece->GetPosition(), cell, dir, dist));\r\n\r\n\t\t\t\tif (conditions == 0 || conditions->IsSatisfied(move))\r\n\t\t\t\t\tmoves->push_back(move);\r\n\t\t\t\telse\r\n\t\t\t\t\tdelete move;\r\n            }\r\n\r\n            if (target != 0)\r\n                break; // Slides can't pass intervening pieces. As this cell was occupied, can be no more valid slides in this direction.\r\n        }\r\n    }\r\n\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *Leap::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\r\n\t// some steps will specify a different piece to act upon, rather than the piece being moved\r\n\tif (!moveSelf)\r\n\t{\r\n\t\tpiece = baseMove->GetPieceByReference(pieceRef);\r\n\t\tif (piece == 0)\r\n\t\t{\r\n\t\t\tReportError(\"Referenced piece not found for leap move: %s\\n\", pieceRef);\r\n\t\t\treturn moves;\r\n\t\t}\r\n\t}\r\n\r\n\tPlayer *player = baseMove->GetPlayer();\r\n\tGame *game = player->GetGame();\r\n\tdirection_t dirs = player->ResolveDirections(direction, previousStep != 0 && previousStep->GetDirection() != 0 ? previousStep->GetDirection() : player->GetForwardDirection());\r\n\t\r\n\tFOR_EACH_DIR_IN_SET(dirs, firstDir)\r\n\t{\r\n\t\tint boardMaxDist = game->GetBoard()->GetMaxDistance(piece->GetPosition(), firstDir);\r\n\t\tint minDist = distance->GetValue(previousStep, boardMaxDist);\r\n\t\tint maxDist = distance->GetMaxValue(distanceMax, previousStep, boardMaxDist);\r\n\r\n\t\t// may not have a second dir, but we need one to function here\r\n\t\tbool hasSecondDir = secondDir != 0;\r\n\t\tdirection_t secondDirs = hasSecondDir ? player->ResolveDirections(secondDir, firstDir) : firstDir;\r\n\t\t\r\n\t\tCell *straightCell = piece->GetPosition();\r\n\r\n        for (int dist = 1; dist <= maxDist; dist++)\r\n\t\t{\r\n\t\t\tstraightCell = straightCell->FollowLink(firstDir);\r\n            if (straightCell == 0)\r\n                break;\r\n\r\n            if (dist < minDist)\r\n                continue; // not yet reached minimum straight distance, so don't turn\r\n\r\n\t\t\tFOR_EACH_DIR_IN_SET(secondDirs, secondDir)\r\n\t\t\t{\r\n\t\t\t\tCell *destCell = straightCell;\r\n\t\t\t\tboardMaxDist = game->GetBoard()->GetMaxDistance(destCell, secondDir);\r\n\t\t\t\tint minDist2 = hasSecondDir ? secondDist->GetValue(previousStep, boardMaxDist) : 0;\r\n\t\t\t\tint maxDist2 = hasSecondDir ? secondDist->GetMaxValue(0, previousStep, boardMaxDist) : 0;\r\n\r\n\t\t\t\tfor (int secondDist = hasSecondDir ? 1 : 0; secondDist <= maxDist2; secondDist++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (secondDist > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdestCell = destCell->FollowLink(secondDir);\r\n\t\t\t\t\t\tif (destCell == 0)\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n                    Piece *target = destCell->GetPiece();\r\n                    if (secondDist >= minDist2)\r\n\t\t\t\t\t{\r\n                        MoveStep *captureStep = 0;\r\n\r\n\t\t\t\t\t\tif (target == 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (when == Capturing)\r\n\t\t\t\t\t\t\t\tcontinue; // needs to be a capture for this leap to be valid, and there is no piece here. But there might be pieces beyond this one.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (when != Moving && piece->CanCapture(target))\r\n\t\t\t\t\t\t\t\tcaptureStep = MoveStep::CreateCapture(target, destCell, piece->GetOwner(), game->GetHoldCapturedPieces());\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tcontinue; // cannot capture this piece, but unlike slides, leaps don't stop when a piece is in the way\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tMove *move = baseMove->Clone();\r\n\t\t\t\t\t\tif (captureStep != 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmove->AddStep(captureStep);\r\n\t\t\t\t\t\t\tmove->AddPieceReference(target, \"target\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmove->AddStep(MoveStep::CreateMove(piece, piece->GetPosition(), destCell, secondDir, secondDist > 0 ? secondDist : dist));\r\n\r\n\t\t\t\t\t\tif (conditions == 0 || conditions->IsSatisfied(move))\r\n\t\t\t\t\t\t\tmoves->push_back(move);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdelete move;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *Hop::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\r\n\t// some steps will specify a different piece to act upon, rather than the piece being moved\r\n\tif (!moveSelf)\r\n\t{\r\n\t\tpiece = baseMove->GetPieceByReference(pieceRef);\r\n\t\tif (piece == 0)\r\n\t\t{\r\n\t\t\tReportError(\"Referenced piece not found for hop move: %s\\n\", pieceRef);\r\n\t\t\treturn moves;\r\n\t\t}\r\n\t}\r\n\r\n\tPlayer *player = baseMove->GetPlayer();\r\n\tGame *game = player->GetGame();\r\n\tdirection_t dirs = player->ResolveDirections(direction, previousStep != 0 && previousStep->GetDirection() != 0 ? previousStep->GetDirection() : player->GetForwardDirection());\r\n\r\n\tFOR_EACH_DIR_IN_SET(dirs, dir)\r\n\t{\r\n\t\tint boardMaxDist = game->GetBoard()->GetMaxDistance(piece->GetPosition(), dir);\r\n\t\tint minDistTo = distToHurdle->GetValue(previousStep, boardMaxDist);\r\n\t\tint maxDistTo = distToHurdle->GetMaxValue(distToHurdleMax, previousStep, boardMaxDist);\r\n\t\tint minDistAfter = distAfterHurdle->GetValue(previousStep, boardMaxDist); // doesn't the 'board max' need recalculated based on hurdle position?\r\n\t\tint maxDistAfter = distAfterHurdle->GetMaxValue(distAfterHurdleMax, previousStep, boardMaxDist);\r\n\t\tCell *hurdleCell = piece->GetPosition();\r\n\t\t\r\n        for (int distTo = 1; distTo <= maxDistTo; distTo++)\r\n\t\t{\r\n\t\t\thurdleCell = hurdleCell->FollowLink(dir);\r\n            if (hurdleCell == 0)\r\n                break;\r\n\r\n            Piece *hurdle = hurdleCell->GetPiece();\r\n            if (hurdle == 0)\r\n                continue;\r\n\r\n            if (distTo < minDistTo)\r\n                break; // this piece is too close to hop over\r\n\r\n            if (captureHurdle && !piece->CanCapture(hurdle))\r\n                break; // can't capture this hurdle, so can't hop it\r\n\r\n            // now we've found the only possible hurdle. Do what we will with that, then there cannot be another hurdle, so break after\r\n            Cell *destCell = hurdleCell;\r\n            for (int distAfter = 1; distAfter <= maxDistAfter; distAfter++)\r\n\t\t\t{\r\n                destCell = destCell->FollowLink(dir);\r\n                if (destCell == 0)\r\n                    break;\r\n\r\n                Piece *target = destCell->GetPiece();\r\n\r\n                if (distAfter >= minDistAfter)\r\n\t\t\t\t{\r\n                    MoveStep *captureStep = 0;\r\n\t\t\t\t\tif (target == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (when == Capturing)\r\n\t\t\t\t\t\t\tcontinue; // needs to be a capture for this hop to be valid, and there is no piece here. But there might be pieces beyond this one.\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (when == Moving)\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\telse if (piece->CanCapture(target))\r\n\t\t\t\t\t\t\tcaptureStep = MoveStep::CreateCapture(target, destCell, piece->GetOwner(), game->GetHoldCapturedPieces());\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tbreak; // cannot capture this piece. Cannot hop over a second piece, so there can be no more valid hops in this direction.\r\n\t\t\t\t\t}\r\n\r\n                    Move *move = baseMove->Clone();\r\n                    move->AddPieceReference(hurdle, \"hurdle\");\r\n\r\n                    if (captureHurdle)\r\n\t\t\t\t\t{\r\n                        MoveStep *hurdleCaptureStep = MoveStep::CreateCapture(hurdle, hurdle->GetPosition(), piece->GetOwner(), game->GetHoldCapturedPieces());\r\n                        move->AddStep(hurdleCaptureStep);\r\n                    }\r\n\r\n                    if (captureStep != 0)\r\n\t\t\t\t\t{\r\n                        move->AddPieceReference(target, \"target\");\r\n                        move->AddStep(captureStep);\r\n                    }\r\n\r\n                    move->AddStep(MoveStep::CreateMove(piece, piece->GetPosition(), destCell, dir, distTo + distAfter));\r\n\r\n                    if (conditions == 0 || conditions->IsSatisfied(move))\r\n\t\t\t\t\t\tmoves->push_back(move);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdelete move;\r\n                }\r\n\r\n                if (target != 0)\r\n                    break; // whether we capture it or not, can't pass a second piece\r\n            }\r\n\r\n            break;\r\n        }\r\n    }\r\n\t\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *Shoot::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\t\r\n\t// some steps will specify a different piece to act upon, rather than the piece being moved\r\n\tif (!moveSelf)\r\n\t{\r\n\t\tpiece = baseMove->GetPieceByReference(pieceRef);\r\n\t\tif (piece == 0)\r\n\t\t{\r\n\t\t\tReportError(\"Referenced piece not found for shoot move: %s\\n\", pieceRef);\r\n\t\t\treturn moves;\r\n\t\t}\r\n\t}\r\n\r\n\tPlayer *player = baseMove->GetPlayer();\r\n\tGame *game = player->GetGame();\r\n\tdirection_t dirs = player->ResolveDirections(direction, previousStep != 0 && previousStep->GetDirection() != 0 ? previousStep->GetDirection() : player->GetForwardDirection());\r\n\r\n\tFOR_EACH_DIR_IN_SET(dirs, firstDir)\r\n\t{\r\n\t\tint boardMaxDist = game->GetBoard()->GetMaxDistance(piece->GetPosition(), firstDir);\r\n\t\tint minDist = distance->GetValue(previousStep, boardMaxDist);\r\n\t\tint maxDist = distance->GetMaxValue(distanceMax, previousStep, boardMaxDist);\r\n\r\n\t\t// may not have a second dir, but we need one to function here\r\n\t\tbool hasSecondDir = secondDir != 0;\r\n\t\tdirection_t secondDirs = hasSecondDir ? player->ResolveDirections(secondDir, firstDir) : firstDir;\r\n\t\t\r\n\t\tCell *straightCell = piece->GetPosition();\r\n\r\n\t\tfor (int dist = 1; dist <= maxDist; dist++)\r\n\t\t{\r\n\t\t\tstraightCell = straightCell->FollowLink(firstDir);\r\n\t\t\tif (straightCell == 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tif (dist < minDist)\r\n\t\t\t\tcontinue; // not yet reached minimum straight distance, so don't turn\r\n\r\n\t\t\tFOR_EACH_DIR_IN_SET(secondDirs, secondDir)\r\n\t\t\t{\r\n\t\t\t\tCell *destCell = straightCell;\r\n\t\t\t\tboardMaxDist = game->GetBoard()->GetMaxDistance(destCell, secondDir);\r\n\t\t\t\tint minDist2 = hasSecondDir ? secondDist->GetValue(previousStep, boardMaxDist) : 0;\r\n\t\t\t\tint maxDist2 = hasSecondDir ? secondDist->GetMaxValue(0, previousStep, boardMaxDist) : 0;\r\n\r\n\t\t\t\tfor (int secondDist = hasSecondDir ? 1 : 0; secondDist <= maxDist2; secondDist++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (secondDist > 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdestCell = destCell->FollowLink(secondDir);\r\n\t\t\t\t\t\tif (destCell == 0)\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tPiece *target = destCell->GetPiece();\r\n\t\t\t\t\tif (secondDist >= minDist2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMoveStep *captureStep = 0;\r\n\r\n\t\t\t\t\t\tif (target == 0)\r\n\t\t\t\t\t\t\tcontinue; // needs to be a capture for this shoot to be valid, and there is no piece here. But there might be pieces beyond this one.\r\n\t\t\t\t\t\telse if (piece->CanCapture(target))\r\n\t\t\t\t\t\t\tcaptureStep = MoveStep::CreateCapture(target, destCell, piece->GetOwner(), game->GetHoldCapturedPieces());\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tbreak; // cannot capture this piece, and unlike leaps, shoots don't continue past other pieces\r\n\r\n\t\t\t\t\t\tMove *move = baseMove->Clone();\r\n\t\t\t\t\t\tmove->AddStep(captureStep);\r\n\t\t\t\t\t\tmove->AddPieceReference(target, \"target\");\r\n\r\n\t\t\t\t\t\tif (conditions == 0 || conditions->IsSatisfied(move))\r\n\t\t\t\t\t\t\tmoves->push_back(move);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdelete move;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *MoveLike::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tif (likeTarget)\r\n\t{\r\n        // difficult special case - we don't know what piece we're to move like until we've already made the move\r\n        return AppendMoveLikeTarget(baseMove, piece, previousStep);\r\n    }\r\n\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\r\n\t// some steps will specify a different piece to act upon, rather than the piece being moved\r\n\tPiece *other = baseMove->GetPieceByReference(pieceRef);\r\n\tif (other == 0)\r\n\t{\r\n\t\tReportError(\"Referenced piece not found for move like move: %s\\n\", pieceRef);\r\n\t\treturn moves;\r\n\t}\r\n\t\r\n    // iterate over all possible moves of the specific piece being referenced, but *for* the piece being moved\r\n\tstd::list<MoveDefinition*> otherMoves = other->GetType()->GetMoves();\r\n\tfor (auto it = otherMoves.begin(); it != otherMoves.end(); it++)\r\n\t{\r\n\t\tMoveDefinition *moveDef = *it;\r\n\t\tstd::list<Move*> *possibilities = moveDef->DetermineNextSteps(baseMove, piece, previousStep);\r\n\r\n\t\tfor (auto it2 = possibilities->begin(); it2 != possibilities->end(); it2++)\r\n            moves->push_back(*it2);\r\n\r\n\t\tdelete possibilities;\r\n    }\r\n\r\n\treturn moves;\r\n}\r\n\r\n\r\nbool MoveLike::AllowMoveLikeTarget = true;\r\nstd::list<Move*> *MoveLike::AppendMoveLikeTarget(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\tif (!AllowMoveLikeTarget)\r\n        return moves; // 'move like target' shouldn't try to capture other pieces using 'move like target' - that's nonsense\r\n\r\n    AllowMoveLikeTarget = false;\r\n\r\n\tPlayer *player = baseMove->GetPlayer();\r\n\tGame *game = player->GetGame();\r\n\r\n    // loop through all possible piece types, try out every move, and then if the piece(s) captured are of the same type, use it\r\n\tstd::list<PieceType*> pieceTypes = game->GetAllPieceTypes();\r\n\tfor (auto it = pieceTypes.begin(); it != pieceTypes.end(); it++)\r\n\t{\r\n\t\tPieceType *pieceType = *it;\r\n\r\n\t\tstd::list<MoveDefinition*> typeMoves = pieceType->GetMoves();\r\n\t\tfor (auto it2 = typeMoves.begin(); it2 != typeMoves.end(); it2++)\r\n\t\t{\r\n\t\t\tMoveDefinition *moveDef = *it2;\r\n\t\t\tstd::list<Move*> *possibilities = moveDef->DetermineNextSteps(baseMove, piece, previousStep);\r\n\r\n\t\t\tfor (auto it3 = possibilities->begin(); it3 != possibilities->end(); it3++)\r\n\t\t\t{\r\n\t\t\t\tMove *newMove = *it3;\r\n\t\t\t\tbool moveIsOk = false;\r\n\r\n\t\t\t\tstd::list<MoveStep*> steps = newMove->GetSteps();\r\n\t\t\t\tint prevNumSteps = baseMove->GetSteps().size();\r\n\t\t\t\tfor (auto it4 = std::next(steps.begin(), prevNumSteps); it4 != steps.end(); it4++) // for each of the NEW steps added\r\n\t\t\t\t{\r\n\t\t\t\t\tMoveStep *step = *it4;\r\n\t\t\t\t\tif (step->GetToState() != Piece::OnBoard)\r\n\t\t\t\t\t{// moving another piece off the board qualifies this as a capture\r\n\t\t\t\t\t\tPiece *target = step->GetPiece();\r\n\t\t\t\t\t\tif (target == piece)\r\n\t\t\t\t\t\t\tcontinue; // if capturing like a 'kamakaze' piece, it should be OK to capture yourself, so ignore this\r\n\r\n\t\t\t\t\t\tif (target != 0 && target->GetType() == pieceType && piece->CanCapture(target))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmoveIsOk = true;\r\n\t\t\t\t\t\t\t// debatable: do we want an option to allow capturing multiple pieces, as long as ONE is of the target type? If so, you'd break here instead of below\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmoveIsOk = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (moveIsOk) // must be a capture, and every piece captured must be of pieceType (or be this same piece, for kamikaze purposes)\r\n\t\t\t\t\tmoves->push_back(newMove);\r\n\t\t\t\telse\r\n\t\t\t\t\tdelete newMove;\r\n\t\t\t}\r\n\r\n\t\t\tdelete possibilities;\r\n\t\t}\r\n\t}\r\n\r\n    AllowMoveLikeTarget = true;\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *ReferencePiece::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>();\r\n\t\r\n\tPiece *other = 0;\r\n\tPlayer *player = baseMove->GetPlayer();\r\n\tGame *game = player->GetGame();\r\n\r\n\tif (direction != 0 && distance != 0)\r\n\t{\r\n\t\tdirection_t dirs = player->ResolveDirections(direction, previousStep != 0 && previousStep->GetDirection() != 0 ? previousStep->GetDirection() : player->GetForwardDirection());\r\n\r\n\t\tFOR_EACH_DIR_IN_SET(dirs, dir)\r\n\t\t{\r\n\t\t\tint boardMaxDist = game->GetBoard()->GetMaxDistance(piece->GetPosition(), dir);\r\n\t\t\tint minDist = distance->GetValue(previousStep, boardMaxDist);\r\n\t\t\tint maxDist = distance->GetMaxValue(0, previousStep, boardMaxDist);\r\n\t\t\tCell *cell = piece->GetPosition();\r\n\r\n\t\t\tfor (int dist = 1; dist <= maxDist; dist++)\r\n\t\t\t{\r\n\t\t\t\tcell = cell->FollowLink(dir);\r\n\t\t\t\tif (cell == 0)\r\n\t\t\t\t\tbreak;\r\n\r\n                if (dist < minDist)\r\n                    continue;\r\n\r\n                other = cell->GetPiece();\r\n\t\t\t\tif (other == 0)\r\n                    continue;\r\n\r\n\t\t\t\tif (!other->TypeMatches(otherPieceType))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tif (relationship != Player::Any && player->GetRelationship(other->GetOwner()) != relationship)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tMove *move = baseMove->Clone();\r\n\t\t\t\tmove->AddPieceReference(other, otherPieceRef);\r\n\t\t\t\tmoves->push_back(move);\r\n            }\r\n        }\r\n    }\r\n\telse\r\n    {\r\n\t\tstd::list<Player*> players = game->GetPlayers();\r\n\t\tfor (auto it = players.begin(); it != players.end(); it++)\r\n\t\t{\r\n\t\t\tPlayer *otherPlayer = *it;\r\n\r\n\t\t\tif (relationship != Player::Any && player->GetRelationship(otherPlayer) != relationship)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tstd::set<Piece*> pieces = otherPlayer->GetPiecesOnBoard();\r\n\t\t\tfor (auto it2 = pieces.begin(); it2 != pieces.end(); it2++)\r\n\t\t\t{\r\n\t\t\t\tPiece *otherPiece = *it2;\r\n\r\n\t\t\t\tif (!otherPiece->TypeMatches(otherPieceType))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tMove *move = baseMove->Clone();\r\n\t\t\t\tmove->AddPieceReference(other, otherPieceRef);\r\n\t\t\t\tmoves->push_back(move);\r\n            }\r\n        }\r\n\t}\r\n\t\r\n\treturn moves;\r\n}\r\n\r\n\r\nstd::list<Move*> *MoveGroup::DetermineNextSteps(Move *baseMove, Piece *piece, MoveStep *previousStep)\r\n{\r\n\tstd::list<Move*> *moves = new std::list<Move*>(), *prevStepMoves = new std::list<Move*>(), *currentStepMoves = new std::list<Move*>();\r\n\tprevStepMoves->push_back(baseMove->Clone());\r\n\t\r\n\tfor (int rep = 1; rep <= maxOccurs; rep++)\r\n\t{\r\n\t\tfor (auto itStep = contents.begin(); itStep != contents.end(); itStep++)\r\n\t\t{\r\n\t\t\tMoveDefinition *stepDef = *itStep;\r\n\r\n\t\t\tfor (auto itPrevMove = prevStepMoves->begin(); itPrevMove != prevStepMoves->end(); itPrevMove++)\r\n\t\t\t{\r\n\t\t\t\tMove *prevMove = *itPrevMove;\r\n\r\n\t\t\t\tstd::list<MoveStep*> steps = prevMove->GetSteps();\r\n\t\t\t\tfor (auto itDoStep = steps.begin(); itDoStep != steps.end(); itDoStep++)\r\n\t\t\t\t\t(*itDoStep)->Perform(false);\r\n\r\n\t\t\t\tstd::list<Move*> *nextMovesForStep = stepDef->DetermineNextSteps(prevMove, piece, steps.size() > 0 ? *steps.rbegin() : previousStep);\r\n\t\t\t\tcurrentStepMoves->splice(currentStepMoves->end(), *nextMovesForStep);\r\n\t\t\t\tdelete nextMovesForStep;\r\n\r\n\t\t\t\tfor (auto itUndoStep = steps.rbegin(); itUndoStep != steps.rend(); itUndoStep++)\r\n\t\t\t\t\t(*itUndoStep)->Reverse(false);\r\n\t\t\t}\r\n\r\n\t\t\tstd::list<Move*> *tmp = prevStepMoves;\r\n\t\t\tprevStepMoves = currentStepMoves;\r\n\t\t\tcurrentStepMoves = tmp;\r\n\r\n\t\t\twhile (!currentStepMoves->empty())\r\n\t\t\t\tdelete currentStepMoves->front(), currentStepMoves->pop_front();\r\n\r\n\t\t\tif (prevStepMoves->size() == 0)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n        \r\n\t\tif (prevStepMoves->size() == 0) // this FULL iteration through the loop ended with no suitable moves\r\n\t\t\tbreak;\r\n           \r\n\t\tif (rep >= minOccurs)\r\n\t\t\tmoves->splice(moves->end(), *prevStepMoves);\r\n\t}\r\n\r\n\r\n\twhile (!prevStepMoves->empty())\r\n\t\tdelete prevStepMoves->front(), prevStepMoves->pop_front();\r\n\tdelete prevStepMoves;\r\n\tdelete currentStepMoves;\r\n\r\n\t// this group failed, but it wasn't essential, so return the previous move, as that's still valid on its own\r\n\tif (stepOutIfFail && moves->size() == 0 && baseMove->GetSteps().size() > 0)\r\n\t\tmoves->push_back(baseMove->Clone());\r\n\r\n\treturn moves;\r\n}","#include \"MoveStep.h\"\r\n#include \"Game.h\"\r\n#include \"Piece.h\"\r\n\r\nint MoveStep::nextID = 1;\r\n\r\nMoveStep::MoveStep(Piece *piece)\r\n{\r\n\tuniqueID = MoveStep::nextID++;\r\n\tthis->piece = piece;\r\n    fromPos = toPos = 0;\r\n\tfromOwner = toOwner = piece->GetOwner();\r\n\tfromStateOwner = toStateOwner = 0;\r\n\tfromType = toType = piece->GetType();\r\n    direction = 0; // used only for resolving relative directions of subsequent steps\r\n}\r\n\r\n\r\nMoveStep::~MoveStep()\r\n{\r\n}\r\n\r\n\r\nbool MoveStep::Perform(bool updateDisplay)\r\n{\r\n\tif (!Pickup(fromState, fromStateOwner, fromPos, fromOwner, fromType))\r\n\t\treturn false;\r\n\r\n\tPlace(toState, toStateOwner, toPos, toOwner, toType);\r\n\r\n\tif (updateDisplay)\r\n\t\tUpdateDisplay();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\nbool MoveStep::Reverse(bool updateDisplay)\r\n{\r\n\tif (!Pickup(toState, toStateOwner, toPos, toOwner, toType))\r\n\t\treturn false;\r\n\r\n\tPlace(fromState, fromStateOwner, fromPos, fromOwner, fromType);\r\n\r\n\tif (updateDisplay)\r\n\t\tUpdateDisplay();\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\nbool MoveStep::Pickup(Piece::State_t state, Player *stateOwner, Cell *pos, Player *owner, PieceType *type)\r\n{\r\n\tif (piece->GetState() != state) // piece isn't in the expected state, quit\r\n\t{\r\n\t\t//console.log('state is wrong: got ' + this.piece.pieceState + ', expected ' + state + ' for ' + this.piece.ownerPlayer.name + ' ' + this.piece.pieceType.name);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (piece->GetOwner() != owner)\r\n\t{\r\n\t\t//console.log('owner is wrong: got ' + this.piece.ownerPlayer.name + ', expected ' + owner.name + ' for ' + this.piece.ownerPlayer.name + ' ' + this.piece.pieceType.name);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (piece->GetStateOwner() != stateOwner)\r\n\t{\r\n\t\t//console.log('state owner is wrong: got ' + (this.piece.stateOwner == null ? '[null]' : this.piece.stateOwner.name) + ', expected ' + (stateOwner == null ? '[null]' : stateOwner.name) + ' for ' + this.piece.ownerPlayer.name + ' ' + this.piece.pieceType.name);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tswitch (state)\r\n\t{\r\n\tcase Piece::OnBoard:\r\n\t\tif (piece->GetPosition() != pos)\r\n\t\t{\r\n\t\t\t//console.log('position is wrong: got ' + this.piece.position.name + ', expected ' + pos.name + ' for ' + this.piece.ownerPlayer.name + ' ' + this.piece.pieceType.name);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (toState != fromState || fromOwner != toOwner)\r\n\t\t\towner->piecesOnBoard.erase(piece);\r\n\t\tpos->piece = 0;\r\n\t\treturn true;\r\n\r\n\tcase Piece::Captured:\r\n\t\tif (stateOwner == 0 || stateOwner->piecesCaptured.erase(piece) == 0)\r\n\t\t\treturn false; // wasn't captured by that player after all ... can't perform this action\r\n\t\treturn true;\r\n\r\n\tcase Piece::Held:\r\n\t\tif (stateOwner == 0 || stateOwner->piecesHeld.erase(piece) == 0)\r\n\t\t\treturn false; // wasn't held by that player after all ... can't perform this action\r\n\t\treturn true;\r\n\tdefault:\r\n\t\treturn false;// throw 'Unexpected piece state in MoveStep.pickup: ' + state;\r\n\t}\r\n}\r\n\r\n\r\nvoid MoveStep::Place(Piece::State_t state, Player *stateOwner, Cell *pos, Player *owner, PieceType *type)\r\n{\r\n    piece->pieceState = state;\r\n\tpiece->stateOwner = stateOwner;\r\n\tpiece->position = pos;\r\n\tpiece->owner = owner;\r\n\tpiece->pieceType = type;\r\n    \r\n\tswitch (state) {\r\n\tcase Piece::State_t::OnBoard:\r\n\t\tpos->piece = piece;\r\n\t\tif (toState != fromState || fromOwner != toOwner)\r\n\t\t\towner->piecesOnBoard.insert(piece);\r\n\t\tbreak;\r\n\tcase Piece::State_t::Captured:\r\n\t\tstateOwner->piecesCaptured.insert(piece);\r\n\t\tbreak;\r\n\tcase Piece::State_t::Held:\r\n\t\tstateOwner->piecesHeld.insert(piece);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\treturn; //throw 'Unexpected piece state in MoveStep.place: ' + state;\r\n\t}\r\n}\r\n\r\n\r\nvoid MoveStep::UpdateDisplay()\r\n{\r\n\t// todo ... implement this somehow\r\n}\r\n\r\n\r\nMoveStep* MoveStep::CreateMove(Piece *piece, Cell *from, Cell *to, direction_t dir, int distance)\r\n{\r\n\tMoveStep *step = new MoveStep(piece);\r\n\tstep->fromState = step->toState = Piece::State_t::OnBoard;\r\n\tstep->fromPos = from;\r\n\tstep->toPos = to;\r\n\tstep->direction = dir;\r\n\tstep->distance = distance;\r\n\treturn step;\r\n};\r\n\r\n\r\nMoveStep* MoveStep::CreateCapture(Piece *piece, Cell *from, Player *capturedBy, bool toHeld)\r\n{\r\n\tMoveStep *step = new MoveStep(piece);\r\n\tstep->fromState = Piece::State_t::OnBoard;\r\n\tstep->toState = toHeld ? Piece::State_t::Held : Piece::State_t::Captured;\r\n\tstep->fromPos = from;\r\n\tstep->toStateOwner = capturedBy;\r\n\tstep->distance = 0;\r\n\treturn step;\r\n};\r\n\r\n\r\nMoveStep* MoveStep::CreateDrop(Piece *piece, Cell *to, Player *droppedBy)\r\n{\r\n\tMoveStep *step = new MoveStep(piece);\r\n\tstep->fromState = Piece::State_t::Held;\r\n\tstep->toState = Piece::State_t::OnBoard;\r\n\tstep->fromStateOwner = droppedBy;\r\n\tstep->toPos = to;\r\n\tstep->distance = 0;\r\n\treturn step;\r\n};\r\n\r\n\r\nMoveStep* MoveStep::CreatePromotion(Piece *piece, PieceType *fromType, PieceType *toType)\r\n{\r\n\tMoveStep *step = new MoveStep(piece);\r\n\tstep->fromState = step->toState = piece->GetState();\r\n\tstep->fromStateOwner = step->toStateOwner = piece->GetStateOwner();\r\n\tstep->fromPos = step->toPos = piece->GetPosition();\r\n\tstep->fromType = fromType;\r\n\tstep->toType = toType;\r\n\tstep->distance = 0;\r\n\treturn step;\r\n};\r\n\r\n\r\nMoveStep* MoveStep::CreateSteal(Piece *piece, Player *fromOwner, Player *toOwner)\r\n{\r\n\tMoveStep *step = new MoveStep(piece);\r\n\tstep->fromState = step->toState = piece->GetState();\r\n\tstep->fromStateOwner = step->toStateOwner = piece->GetStateOwner();\r\n\tstep->fromPos = step->toPos = piece->GetPosition();\r\n\tstep->fromOwner = fromOwner;\r\n\tstep->toOwner = toOwner;\r\n\tstep->distance = 0;\r\n\treturn step;\r\n};","#include \"Piece.h\"\r\n\r\nint Piece::nextID = 1;\r\n\r\nPiece::Piece(Player *owner, PieceType *type, Cell *position, State_t state, Player *stateOwner)\r\n{\r\n\tuniqueID = Piece::nextID++; // prefix this with a \"p\" in the DOM, i guess\r\n\tthis->owner = owner;\r\n\tthis->position = position;\r\n\tthis->pieceType = type;\r\n\tthis->pieceState = state;\r\n\tthis->stateOwner = stateOwner;\r\n\tmoveNumber = 1;\t\t// how is this set, when loaded?\r\n\tlastMoveTurn = 0;\t// how is this set, when loaded?\r\n}\r\n\r\n\r\nPiece::~Piece()\r\n{\r\n}\r\n\r\n\r\nbool Piece::CanCapture(Piece *target)\r\n{\r\n\treturn owner->GetRelationship(target->owner) == Player::Enemy;\r\n}\r\n\r\nbool Piece::TypeMatches(PieceType *type)\r\n{\r\n\tif (type == 0) // \"any\"\r\n\t\treturn true;\r\n\treturn type == pieceType;\r\n}","#include \"PieceType.h\"\r\n#include \"MoveDefinition.h\"\r\n\r\nPieceType::PieceType()\r\n{\r\n\tcapturedAs = this;\r\n}\r\n\r\n\r\nPieceType::~PieceType()\r\n{\r\n\twhile (!moves.empty())\r\n\t\tdelete moves.front(), moves.pop_front();\r\n\r\n#ifndef NO_SVG\r\n\tfor (auto it = appearances.begin(); it != appearances.end(); it++)\r\n\t\tdelete [] it->second;\r\n#endif\r\n}\r\n","#include \"ai.h\"\r\n#include \"Piece.h\"\r\n#include \"Player.h\"\r\n#include \"Game.h\"\r\n#include \"Board.h\"\r\n\r\nint Player::nextID = 1;\r\n\r\nPlayer::Player(Game *game, char *name, direction_t forwardDir)\r\n{\r\n\tthis->game = game;\r\n\tthis->type = Local;\r\n\tthis->forwardDir = forwardDir;\r\n\tstrcpy(this->name, name);\r\n\tid = Player::nextID++;\r\n\tai = 0;\r\n}\r\n\r\n\r\nPlayer::~Player()\r\n{\r\n\tfor (auto it = piecesOnBoard.begin(); it != piecesOnBoard.end(); it++)\r\n\t\tdelete *it;\r\n\r\n\tfor (auto it = piecesHeld.begin(); it != piecesHeld.end(); it++)\r\n\t\tdelete *it;\r\n\r\n\tfor (auto it = piecesCaptured.begin(); it != piecesCaptured.end(); it++)\r\n\t\tdelete *it;\r\n\r\n\tif (ai != 0)\r\n\t\tdelete ai;\r\n}\r\n\r\n\r\nvoid Player::SetAI(PlayerAI* ai)\r\n{\r\n\tif (ai != this->ai && this->ai != 0)\r\n\t\tdelete this->ai;\r\n\tthis->ai = ai;\r\n\r\n\tif (ai != 0)\r\n\t\tSetType(AI);\r\n}\r\n\r\ndirection_t Player::ResolveDirections(direction_t dir, direction_t prevDir)\r\n{\r\n\tif (dir == DIRECTION_FORWARD)\r\n\t\treturn forwardDir;\r\n\r\n\treturn game->GetBoard()->ResolveDirections(dir, prevDir);\r\n}\r\n\r\n\r\nPlayer::Relationship_t Player::GetRelationship(Player *other)\r\n{\r\n\tif (this == other)\r\n\t\treturn Self;\r\n\telse\r\n\t\treturn Enemy;\r\n}\r\n\r\n","#include \"StateConditions.h\"\r\n#include \"GameState.h\"\r\n#include \"MoveConditions.h\"\r\n#include \"Piece.h\"\r\n\r\nStateConditionGroup::StateConditionGroup(GroupType_t type)\r\n{\r\n\tthis->type = type;\r\n}\r\n\r\n\r\nStateConditionGroup::~StateConditionGroup()\r\n{\r\n\tstd::list<StateCondition*>::iterator it = elements.begin();\r\n\twhile (it != elements.end())\r\n\t{\r\n\t\tdelete (*it);\r\n\t\tit++;\r\n\t}\r\n}\r\n\r\n\r\nbool StateConditionGroup::IsSatisfied(GameState *state, bool canMove)\r\n{\r\n\tstd::list<StateCondition*>::iterator it = elements.begin();\r\n\tbool any = false;\r\n\r\n\tswitch (type) {\r\n\tcase GroupType_t::And:\r\n\t\twhile (it != elements.end())\r\n\t\t{\r\n\t\t\tif (!(*it)->IsSatisfied(state, canMove))\r\n\t\t\t\treturn false;\r\n\t\t\tit++;\r\n\t\t}\r\n\t\treturn true;\r\n\tcase GroupType_t::Or:\r\n\t\twhile (it != elements.end())\r\n\t\t{\r\n\t\t\tif ((*it)->IsSatisfied(state, canMove))\r\n\t\t\t\treturn true;\r\n\t\t\tit++;\r\n\t\t}\r\n\t\treturn false;\r\n\tcase GroupType_t::Nand:\r\n\t\twhile (it != elements.end())\r\n\t\t{\r\n\t\t\tif (!(*it)->IsSatisfied(state, canMove))\r\n\t\t\t\treturn true;\r\n\t\t\tit++;\r\n\t\t}\r\n\t\treturn false;\r\n\tcase GroupType_t::Nor:\r\n\t\twhile (it != elements.end())\r\n\t\t{\r\n\t\t\tif ((*it)->IsSatisfied(state, canMove))\r\n\t\t\t\treturn false;\r\n\t\t\tit++;\r\n\t\t}\r\n\t\treturn true;\r\n\tcase GroupType_t::Xor:\r\n\t\twhile (it != elements.end())\r\n\t\t{\r\n\t\t\tif ((*it)->IsSatisfied(state, canMove))\r\n\t\t\t{\r\n\t\t\t\tif (any)\r\n\t\t\t\t\treturn false;\r\n\t\t\t\telse\r\n\t\t\t\t\tany = true;\r\n\t\t\t}\r\n\t\t\tit++;\r\n\t\t}\r\n\t\treturn any;\r\n\tdefault: // there are no other types!\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n\r\nbool StateCondition_CannotMove::IsSatisfied(GameState *state, bool canMove)\r\n{\r\n\treturn !canMove;\r\n}\r\n\r\n\r\nbool StateCondition_Threatened::IsSatisfied(GameState *state, bool canMove)\r\n{\r\n\tif (MoveCondition_Threatened::alreadyChecking)\r\n        return false; // assume NOT threatened\r\n\r\n\tauto pieces = state->GetCurrentPlayer()->GetPiecesOnBoard();\r\n\tfor (auto it = pieces.begin(); it != pieces.end(); it++)\r\n\t{\r\n\t\tPiece *piece = *it;\r\n\t\tif (!piece->TypeMatches(type))\r\n            continue;\r\n\t\t\r\n        MoveCondition_Threatened::alreadyChecking = true;\r\n        bool threatened = MoveCondition_Threatened::IsThreatened(state, piece->GetPosition());\r\n        MoveCondition_Threatened::alreadyChecking = false;\r\n\t\t\r\n        if (threatened)\r\n            return true;\r\n    }\r\n\r\n\treturn false;\r\n}","#include \"TurnOrder.h\"\r\n#include \"Player.h\"\r\n\r\nTurnRepeat::TurnRepeat(int count)\r\n{\r\n\tmaxRepeats = count;\r\n\tcurrentIteration = 0;\r\n\tstate = AtStart;\r\n}\r\n\r\n\r\nTurnRepeat::~TurnRepeat()\r\n{\r\n\twhile (!steps.empty())\r\n\t\tdelete steps.front(), steps.pop_front();\r\n}\r\n\r\n\r\nTurnStep* TurnRepeat::GetNext(bool forwards)\r\n{\r\n\tif (state == AtStart)\r\n\t{\r\n\t\tif (!forwards)\r\n\t\t\treturn 0;\r\n\r\n\t\tit = steps.begin();\r\n\t}\r\n\telse if (state == AtEnd)\r\n\t{\r\n\t\tif (forwards)\r\n\t\t\treturn 0;\r\n\r\n\t\tit = steps.end();\r\n\t\tit--;\r\n\t}\r\n\r\n\tif (state != AtEnd && !(*it)->IsStep())\r\n\t{\r\n\t\tTurnRepeat *repeat = (TurnRepeat*)*it;\r\n\t\tTurnStep *step = repeat->GetNext(forwards);\r\n\t\tif (step != 0)\r\n\t\t{\r\n\t\t\tstate = InMiddle;\r\n\t\t\treturn step;\r\n\t\t}\r\n\t}\r\n\r\n\tif (state != InMiddle) // on the first use, don't increment this iterator\r\n\t\tstate = InMiddle;\r\n\telse if (forwards)\r\n\t{\r\n\t\tit++;\r\n\t\tif (it == steps.end())\r\n\t\t{\r\n\t\t\tif (maxRepeats != 0 && currentIteration >= maxRepeats - 1)\r\n\t\t\t{\r\n\t\t\t\tstate = AtEnd;\r\n\t\t\t\treturn 0; // gone past the end on last iteration\r\n\t\t\t}\r\n\r\n\t\t\tcurrentIteration++;\r\n\t\t\tit = steps.begin();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (it == steps.begin())\r\n\t\t{\r\n\t\t\tif (maxRepeats != 0 && currentIteration <= 0)\r\n\t\t\t{\r\n\t\t\t\tstate = AtStart;\r\n\t\t\t\treturn 0; // gone past the beginning on first iteration\r\n\t\t\t}\r\n\r\n\t\t\tcurrentIteration--;\r\n\t\t\tit = steps.end();\r\n\t\t\tit--;\r\n\t\t}\r\n\t\telse\r\n\t\t\tit--;\r\n\t}\r\n\r\n\tif ((*it)->IsStep())\r\n\t{\r\n\t\tTurnStep *step = (TurnStep*)*it;\r\n\t\treturn step;\r\n\t}\r\n\r\n\t// arriving into a repeat for the first time, so reset it\r\n\tTurnRepeat *repeat = (TurnRepeat*)*it;\r\n\tif (forwards)\r\n\t{\r\n\t\trepeat->currentIteration = 0;\r\n\t\trepeat->state = AtStart;\r\n\t}\r\n\telse\r\n\t{\r\n\t\trepeat->currentIteration = repeat->maxRepeats - 1;\r\n\t\trepeat->state = AtEnd;\r\n\t}\r\n\treturn repeat->GetNext(forwards);\r\n}\r\n\r\n\r\nTurnOrder::TurnOrder() : TurnRepeat(1)\r\n{\r\n\r\n}\r\n\r\n\r\nTurnOrder::~TurnOrder()\r\n{\r\n\r\n}\r\n\r\n\r\nTurnOrder *TurnOrder::CreateDefault(std::list<Player*> players)\r\n{\r\n\tTurnOrder *order = new TurnOrder();\r\n\r\n\tTurnRepeat *repeat = new TurnRepeat(0);\r\n\torder->steps.push_back(repeat);\r\n\r\n\tfor (auto it = players.begin(); it != players.end(); it++)\r\n\t\trepeat->steps.push_back(new TurnStep(*it));\r\n\r\n\treturn order;\r\n}\r\n\r\n\r\nPlayer *TurnOrder::GetNextPlayer()\r\n{\r\n\tcurrentStep = GetNext(true);\r\n\tif (currentStep == 0)\r\n\t\treturn 0; \r\n\treturn currentStep->GetPlayer();\r\n}\r\n\r\n\r\nvoid TurnOrder::StepBackward()\r\n{\r\n\tcurrentStep = GetNext(false);\r\n}\r\n"]}